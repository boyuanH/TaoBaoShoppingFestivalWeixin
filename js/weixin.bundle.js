! function(t) {
	function e(i) {
		if(n[i])
			return n[i].exports;
		var r = n[i] = {
			exports: {},
			id: i,
			loaded: !1
		};
		return t[i].call(r.exports, r, r.exports, e),
			r.loaded = !0,
			r.exports
	}
	var n = {};
	return e.m = t,
		e.c = n,
		e.p = "",
		e(0)
}([function(t, e, n) {
	"use strict";

	function i(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function r(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function o() {
		E = new _.default,
			E.domElement.style.position = "absolute",
			E.domElement.style.top = "0px",
			E.domElement.style.right = "0px",
			E.domElement.style.transform = "scale(2)",
			E.domElement.style.transformOrigin = "right top",
			document.querySelector("#container").appendChild(E.domElement)
	}

	function a() {
		if(v.default.isAndroid && w.os.version.lt(5))
			return void(location.href = b.default.downGradeLink);
		v.default.isIOS || document.body.classList.add("android"),
			v.default.isWeixin && document.body.classList.add("weixin");
		var t = v.default.isAudioPlay;
		p.default.init().then(function() {
			var e = (new d.default).start(function() {
					t && M.default.play()
				}).stop(function() {
					t = v.default.isAudioPlay,
						M.default.stop()
				}),
				n = v.default.isIOS,
				i = v.default.isTaobao,
				r = !1;
			n && i && (r = !0),
				S && (r = !1),
				r ? e.register(u.default.init).active() : u.default.init();
			var o = (0,
				l.default)();
			o.addEventListener("frameupdate", function(t) {
					r && !e.isActive() || u.default.update(t.detail.timestep)
				}),
				o.addEventListener("framedraw", function(t) {
					r && !e.isActive() || (S && E.update(),
						u.default.draw(t.detail.interpolation))
				}),
				o.start()
		})
	}
	var s = n(1),
		l = r(s),
		c = n(5),
		u = r(c),
		h = n(118),
		d = r(h),
		f = n(14),
		p = r(f),
		m = n(11),
		v = r(m),
		g = n(119),
		_ = r(g),
		y = n(24),
		b = r(y),
		x = n(12),
		w = i(x),
		T = n(58),
		M = r(T),
		E = void 0,
		S = location.search.indexOf("test") > -1;
	S && o(),
		a()
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r() {
		function t(t, e) {
			i[t] || (i[t] = []),
				i[t].push(e)
		}

		function e(t) {
			i[t.type] && i[t.type].forEach(function(e) {
				e(t)
			})
		}

		function n(t, e) {
			if(i[t])
				for(var n = 0, r = listners.length; n < r; n++)
					if(listners[n] === e) {
						i.splice(index, 1);
						break
					}
		}
		var i = [];
		return {
			addEventListener: t,
			dispatchEvent: e,
			removeEventListener: n
		}
	}

	function o(t) {
		function e() {
			return w || (w = !0,
					M = (0,
						s.default)(function(t) {
						c(1),
							b = !0,
							p = t,
							v = t,
							g = 0,
							M = (0,
								s.default)(o)
					})),
				this
		}

		function n() {
			return b = !1,
				w = !1,
				s.default.cancel(M),
				this
		}

		function i() {
			p += d,
				a(p, d),
				l(d * E()),
				c(1),
				u(m, T)
		}

		function o(t) {
			if(t < p + y)
				return void(M = (0,
					s.default)(o));
			for(f += t - p,
				p = t,
				a(t, f),
				t > v + 1e3 && (m = .25 * g + .75 * m,
					v = t,
					g = 0),
				g++,
				_ = 0; f >= d;)
				if(l(d * E()),
					f -= d,
					++_ >= 240) {
					T = !0;
					break
				}
			c(f / d),
				u(m, T),
				T = !1,
				M = (0,
					s.default)(o)
		}

		function a(t, e) {
			h.dispatchEvent(new CustomEvent("framestart", {
				detail: {
					timestamp: t,
					frameDelta: e
				}
			}))
		}

		function l(t) {
			h.dispatchEvent(new CustomEvent("frameupdate", {
				detail: {
					timestep: t
				}
			}))
		}

		function c(t) {
			h.dispatchEvent(new CustomEvent("framedraw", {
				detail: {
					interpolation: t
				}
			}))
		}

		function u(t, e) {
			h.dispatchEvent(new CustomEvent("frameend", {
				detail: {
					fps: t,
					panic: e
				}
			}))
		}
		t = t || {};
		var h = r(),
			d = t.timestep || 1e3 / 60,
			f = 0,
			p = 0,
			m = 60,
			v = 0,
			g = 0,
			_ = 0,
			y = 0,
			b = !1,
			x = !1,
			w = !1,
			T = !1,
			M = void 0,
			E = function() {
				var t = 1;
				return function(e) {
					return e && (t = e),
						t
				}
			}();
		return document.addEventListener("visibilitychange", function(t) {
				t.target.hidden ? b && (x = !0,
					n()) : x && (x = !1,
					e())
			}, !1),
			h.start = e,
			h.stop = n,
			h.step = i,
			h.speed = E,
			h
	}
	Object.defineProperty(e, "__esModule", {
			value: !0
		}),
		e.default = o;
	var a = n(2),
		s = i(a)
}, function(t, e, n) {
	(function(e) {
		for(var i = n(3), r = "undefined" == typeof window ? e : window, o = ["moz", "webkit"], a = "AnimationFrame", s = r["request" + a], l = r["cancel" + a] || r["cancelRequest" + a], c = 0; !s && c < o.length; c++)
			s = r[o[c] + "Request" + a],
			l = r[o[c] + "Cancel" + a] || r[o[c] + "CancelRequest" + a];
		if(!s || !l) {
			var u = 0,
				h = 0,
				d = [],
				f = 1e3 / 60;
			s = function(t) {
					if(0 === d.length) {
						var e = i(),
							n = Math.max(0, f - (e - u));
						u = n + e,
							setTimeout(function() {
								var t = d.slice(0);
								d.length = 0;
								for(var e = 0; e < t.length; e++)
									if(!t[e].cancelled)
										try {
											t[e].callback(u)
										} catch(t) {
											setTimeout(function() {
												throw t
											}, 0)
										}
							}, Math.round(n))
					}
					return d.push({
							handle: ++h,
							callback: t,
							cancelled: !1
						}),
						h
				},
				l = function(t) {
					for(var e = 0; e < d.length; e++)
						d[e].handle === t && (d[e].cancelled = !0)
				}
		}
		t.exports = function(t) {
				return s.call(r, t)
			},
			t.exports.cancel = function() {
				l.apply(r, arguments)
			},
			t.exports.polyfill = function() {
				r.requestAnimationFrame = s,
					r.cancelAnimationFrame = l
			}
	}).call(e, function() {
		return this
	}())
}, function(t, e, n) {
	(function(e) {
		(function() {
			var n, i, r, o, a, s;
			"undefined" != typeof performance && null !== performance && performance.now ? t.exports = function() {
					return performance.now()
				} :
				"undefined" != typeof e && null !== e && e.hrtime ? (t.exports = function() {
						return(n() - a) / 1e6
					},
					i = e.hrtime,
					n = function() {
						var t;
						return t = i(),
							1e9 * t[0] + t[1]
					},
					o = n(),
					s = 1e9 * e.uptime(),
					a = o - s) : Date.now ? (t.exports = function() {
						return Date.now() - r
					},
					r = Date.now()) : (t.exports = function() {
						return(new Date).getTime() - r
					},
					r = (new Date).getTime())
		}).call(this)
	}).call(e, n(4))
}, function(t, e) {
	function n() {
		throw new Error("setTimeout has not been defined")
	}

	function i() {
		throw new Error("clearTimeout has not been defined")
	}

	function r(t) {
		if(u === setTimeout)
			return setTimeout(t, 0);
		if((u === n || !u) && setTimeout)
			return u = setTimeout,
				setTimeout(t, 0);
		try {
			return u(t, 0)
		} catch(e) {
			try {
				return u.call(null, t, 0)
			} catch(e) {
				return u.call(this, t, 0)
			}
		}
	}

	function o(t) {
		if(h === clearTimeout)
			return clearTimeout(t);
		if((h === i || !h) && clearTimeout)
			return h = clearTimeout,
				clearTimeout(t);
		try {
			return h(t)
		} catch(e) {
			try {
				return h.call(null, t)
			} catch(e) {
				return h.call(this, t)
			}
		}
	}

	function a() {
		m && f && (m = !1,
			f.length ? p = f.concat(p) : v = -1,
			p.length && s())
	}

	function s() {
		if(!m) {
			var t = r(a);
			m = !0;
			for(var e = p.length; e;) {
				for(f = p,
					p = []; ++v < e;)
					f && f[v].run();
				v = -1,
					e = p.length
			}
			f = null,
				m = !1,
				o(t)
		}
	}

	function l(t, e) {
		this.fun = t,
			this.array = e
	}

	function c() {}
	var u, h, d = t.exports = {};
	! function() {
		try {
			u = "function" == typeof setTimeout ? setTimeout : n
		} catch(t) {
			u = n
		}
		try {
			h = "function" == typeof clearTimeout ? clearTimeout : i
		} catch(t) {
			h = i
		}
	}();
	var f, p = [],
		m = !1,
		v = -1;
	d.nextTick = function(t) {
			var e = new Array(arguments.length - 1);
			if(arguments.length > 1)
				for(var n = 1; n < arguments.length; n++)
					e[n - 1] = arguments[n];
			p.push(new l(t, e)),
				1 !== p.length || m || r(s)
		},
		l.prototype.run = function() {
			this.fun.apply(null, this.array)
		},
		d.title = "browser",
		d.browser = !0,
		d.env = {},
		d.argv = [],
		d.version = "",
		d.versions = {},
		d.on = c,
		d.addListener = c,
		d.once = c,
		d.off = c,
		d.removeListener = c,
		d.removeAllListeners = c,
		d.emit = c,
		d.prependListener = c,
		d.prependOnceListener = c,
		d.listeners = function(t) {
			return []
		},
		d.binding = function(t) {
			throw new Error("process.binding is not supported")
		},
		d.cwd = function() {
			return "/"
		},
		d.chdir = function(t) {
			throw new Error("process.chdir is not supported")
		},
		d.umask = function() {
			return 0
		}
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r() {
		M.default.moveSpeed = 0,
			c.default.init(),
			setTimeout(function() {
				h.default.init()
			}, 1e3),
			f.default.init(),
			m.default.init(c.default.getStageCamera(), c.default.getRendererDom()),
			o();
		var t = new Promise(function(t, e) {
			M.default.isWeixin ? document.querySelector("#loading").addEventListener("click", function() {
				var e = h.default.getSubVideo();
				e.play(),
					t()
			}) : setTimeout(t, 2e3)
		});
		F.default.init(),
			t.then(function() {
				g.default.trigger(tt),
					N.default.end(),
					setTimeout(function() {
						c.default.showAvatar()
					}, 500),
					setTimeout(function() {
						F.default.showTips()
					}, 1e3),
					setTimeout(function() {
						M.default.moveSpeed = W
					}, 5e3)
			})
	}

	function o() {
		g.default.on(Y, function(t) {
			M.default.status = 1,
				M.default.moveSpeed = 0;
			var e = M.default.isIOS && !M.default.ip6;
			e || I.default.hide(),
				(0,
					y.default)("enterPortal", {
					portal: t
				}),
				h.default.setVideo(t).then(function() {
					setTimeout(function() {
						M.default.status = 2,
							document.body.classList.add("in-sub"),
							e || (h.default.show(),
								c.default.hide()),
							h.default.start()
					}, 1e3)
				})
		});
		var t = M.default.moveSpeed;
		g.default.on(K, function() {
				0 === M.default.status ? 0 === M.default.moveSpeed ? (M.default.moveSpeed = t,
					t = 0,
					M.default.lookingAround = !1) : (t = M.default.moveSpeed,
					M.default.moveSpeed = 0,
					M.default.lookingAround = !0) : 2 === M.default.status && h.default.togglePlay()
			}),
			g.default.on(q, function() {
				M.default.status = 1,
					document.body.classList.remove("in-sub");
				var t = M.default.isIOS && !M.default.ip6;
				t || (h.default.hide(),
						c.default.show()),
					setTimeout(function() {
						M.default.status = 0,
							M.default.moveSpeed = W,
							M.default.exploreCount += 1,
							C.default.showAndHide(),
							M.default.entryCount++,
							t || I.default.show()
					}, 1e3)
			}),
			g.default.on(Z, function() {
				M.default.status = 0,
					M.default.moveSpeed = 0,
					M.default.orientationControlling = !1,
					setTimeout(function() {
						document.body.classList.add("end"),
							S.default.show(),
							C.default.show()
					}, 1e3)
			}),
			g.default.on(Q, function() {
				M.default.isTaobao ? (0,
					b.goTickets)() : A.default.show()
			}),
			g.default.on(J, function() {
				M.default.isTaobao ? (0,
					b.share)() : (R.default.show(),
					setTimeout(function() {
						R.default.hide()
					}, 2e3))
			}),
			g.default.on($, function() {
				M.default.status = 3,
					setTimeout(function() {
						location.reload()
					}, 50)
			});
		var e = M.default.isAudioPlay;
		document.addEventListener("visibilitychange", function(t) {
				t.target.hidden ? (e = M.default.isAudioPlay,
					f.default.stop()) : e && f.default.play()
			}, !1),
			window.onresize = function() {
				g.default.trigger(tt)
			}
	}

	function a(t) {
		2 !== M.default.status ? (c.default.update(t),
				m.default.update()) : h.default.update(t),
			f.default.update(t)
	}

	function s(t) {
		if(2 !== M.default.status)
			V.default.draw(U.default.getScene(), U.default.getCamera());
		else {
			var e = M.default.isIOS && !M.default.ip6;
			e && V.default.draw(H.default.getScene(), H.default.getCamera())
		}
	}
	Object.defineProperty(e, "__esModule", {
			value: !0
		}),
		n(6);
	var l = n(7),
		c = i(l),
		u = n(53),
		h = i(u),
		d = n(58),
		f = i(d),
		p = n(60),
		m = i(p),
		v = n(30),
		g = i(v),
		_ = n(109),
		y = i(_),
		b = n(56),
		x = n(10),
		w = i(x),
		T = n(11),
		M = i(T),
		E = n(110),
		S = i(E),
		X = n(111),
		A = i(X),
		P = n(112),
		R = i(P),
		O = n(113),
		C = i(O),
		L = n(114),
		I = i(L),
		D = n(115),
		B = (i(D),
			n(116)),
		F = i(B),
		z = n(22),
		N = i(z);
	n(117);
	var k = n(8),
		U = i(k),
		j = n(52),
		V = i(j),
		G = n(53),
		H = i(G),
		W = w.default.MOVE_SPEED,
		Y = w.default.ENTER_DISTRICT,
		q = w.default.LEAVE_DISTRICT,
		Z = w.default.MEET_END,
		Q = w.default.TICKET_CLICK,
		J = w.default.SHARE_CLICK,
		K = w.default.TRY_OVERLOOK,
		$ = w.default.REPLAY_CLICK,
		tt = w.default.WINDOW_RESIZE;
	M.default.enterSubDistricts,
		M.default.leaveSubDistricts;
	e.default = {
		init: r,
		update: a,
		draw: s
	}
}, function(t, e) {
	"undefined" == typeof window && (window = {
			ctrl: {},
			lib: {}
		}), !window.ctrl && (window.ctrl = {}), !window.lib && (window.lib = {}), ! function(t) {
			"use strict";

			function e(t, e) {
				for(var n = t; n;) {
					if(n.contains(e) || n == e)
						return n;
					n = n.parentNode
				}
				return null
			}

			function n(t, e, n) {
				var i = l.createEvent("HTMLEvents");
				if(i.initEvent(e, !0, !0),
					"object" == typeof n)
					for(var r in n)
						i[r] = n[r];
				t.dispatchEvent(i)
			}

			function i(t, e, n, i, r, o, a, s) {
				var l = Math.atan2(s - o, a - r) - Math.atan2(i - e, n - t),
					c = Math.sqrt((Math.pow(s - o, 2) + Math.pow(a - r, 2)) / (Math.pow(i - e, 2) + Math.pow(n - t, 2))),
					u = [r - c * t * Math.cos(l) + c * e * Math.sin(l), o - c * e * Math.cos(l) - c * t * Math.sin(l)];
				return {
					rotate: l,
					scale: c,
					translate: u,
					matrix: [
						[c * Math.cos(l), -c * Math.sin(l), u[0]],
						[c * Math.sin(l), c * Math.cos(l), u[1]],
						[0, 0, 1]
					]
				}
			}

			function r(t) {
				0 === Object.keys(h).length && (c.addEventListener("touchmove", o, !1),
					c.addEventListener("touchend", a, !1),
					c.addEventListener("touchcancel", s, !1));
				for(var i = 0; i < t.changedTouches.length; i++) {
					var r = t.changedTouches[i],
						l = {};
					for(var d in r)
						l[d] = r[d];
					var f = {
						startTouch: l,
						startTime: Date.now(),
						status: "tapping",
						element: t.srcElement || t.target,
						pressingHandler: setTimeout(function(e) {
							return function() {
								"tapping" === f.status && (f.status = "pressing",
										n(e, "press", {
											touchEvent: t
										})),
									clearTimeout(f.pressingHandler),
									f.pressingHandler = null
							}
						}(t.srcElement || t.target), 500)
					};
					h[r.identifier] = f
				}
				if(2 == Object.keys(h).length) {
					var p = [];
					for(var d in h)
						p.push(h[d].element);
					n(e(p[0], p[1]), "dualtouchstart", {
						touches: u.call(t.touches),
						touchEvent: t
					})
				}
			}

			function o(t) {
				for(var r = 0; r < t.changedTouches.length; r++) {
					var o = t.changedTouches[r],
						a = h[o.identifier];
					if(!a)
						return;
					a.lastTouch || (a.lastTouch = a.startTouch),
						a.lastTime || (a.lastTime = a.startTime),
						a.velocityX || (a.velocityX = 0),
						a.velocityY || (a.velocityY = 0),
						a.duration || (a.duration = 0);
					var s = Date.now() - a.lastTime,
						l = (o.clientX - a.lastTouch.clientX) / s,
						c = (o.clientY - a.lastTouch.clientY) / s,
						u = 70;
					s > u && (s = u),
						a.duration + s > u && (a.duration = u - s),
						a.velocityX = (a.velocityX * a.duration + l * s) / (a.duration + s),
						a.velocityY = (a.velocityY * a.duration + c * s) / (a.duration + s),
						a.duration += s,
						a.lastTouch = {};
					for(var d in o)
						a.lastTouch[d] = o[d];
					a.lastTime = Date.now();
					var f = o.clientX - a.startTouch.clientX,
						p = o.clientY - a.startTouch.clientY,
						m = Math.sqrt(Math.pow(f, 2) + Math.pow(p, 2));
					("tapping" === a.status || "pressing" === a.status) && m > 10 && (a.status = "panning",
							a.isVertical = !(Math.abs(f) > Math.abs(p)),
							n(a.element, "panstart", {
								touch: o,
								touchEvent: t,
								isVertical: a.isVertical
							}),
							n(a.element, (a.isVertical ? "vertical" : "horizontal") + "panstart", {
								touch: o,
								touchEvent: t
							})),
						"panning" === a.status && (a.panTime = Date.now(),
							n(a.element, "pan", {
								displacementX: f,
								displacementY: p,
								touch: o,
								touchEvent: t,
								isVertical: a.isVertical
							}),
							a.isVertical ? n(a.element, "verticalpan", {
								displacementY: p,
								touch: o,
								touchEvent: t
							}) : n(a.element, "horizontalpan", {
								displacementX: f,
								touch: o,
								touchEvent: t
							}))
				}
				if(2 == Object.keys(h).length) {
					for(var v, g = [], _ = [], y = [], r = 0; r < t.touches.length; r++) {
						var o = t.touches[r],
							a = h[o.identifier];
						g.push([a.startTouch.clientX, a.startTouch.clientY]),
							_.push([o.clientX, o.clientY])
					}
					for(var d in h)
						y.push(h[d].element);
					v = i(g[0][0], g[0][1], g[1][0], g[1][1], _[0][0], _[0][1], _[1][0], _[1][1]),
						n(e(y[0], y[1]), "dualtouch", {
							transform: v,
							touches: t.touches,
							touchEvent: t
						})
				}
			}

			function a(t) {
				if(2 == Object.keys(h).length) {
					var i = [];
					for(var r in h)
						i.push(h[r].element);
					n(e(i[0], i[1]), "dualtouchend", {
						touches: u.call(t.touches),
						touchEvent: t
					})
				}
				for(var l = 0; l < t.changedTouches.length; l++) {
					var f = t.changedTouches[l],
						p = f.identifier,
						m = h[p];
					if(m) {
						if(m.pressingHandler && (clearTimeout(m.pressingHandler),
								m.pressingHandler = null),
							"tapping" === m.status && (m.timestamp = Date.now(),
								n(m.element, "tap", {
									touch: f,
									touchEvent: t
								}),
								d && m.timestamp - d.timestamp < 300 && n(m.element, "doubletap", {
									touch: f,
									touchEvent: t
								}),
								d = m),
							"panning" === m.status) {
							var v = Date.now(),
								g = v - m.startTime,
								_ = ((f.clientX - m.startTouch.clientX) / g,
									(f.clientY - m.startTouch.clientY) / g,
									f.clientX - m.startTouch.clientX),
								y = f.clientY - m.startTouch.clientY,
								b = Math.sqrt(m.velocityY * m.velocityY + m.velocityX * m.velocityX),
								x = b > .5 && v - m.lastTime < 100,
								w = {
									duration: g,
									isflick: x,
									velocityX: m.velocityX,
									velocityY: m.velocityY,
									displacementX: _,
									displacementY: y,
									touch: f,
									touchEvent: t,
									isVertical: m.isVertical
								};
							n(m.element, "panend", w),
								x && (n(m.element, "flick", w),
									m.isVertical ? n(m.element, "verticalflick", w) : n(m.element, "horizontalflick", w))
						}
						"pressing" === m.status && n(m.element, "pressend", {
								touch: f,
								touchEvent: t
							}),
							delete h[p]
					}
				}
				0 === Object.keys(h).length && (c.removeEventListener("touchmove", o, !1),
					c.removeEventListener("touchend", a, !1),
					c.removeEventListener("touchcancel", s, !1))
			}

			function s(t) {
				if(2 == Object.keys(h).length) {
					var i = [];
					for(var r in h)
						i.push(h[r].element);
					n(e(i[0], i[1]), "dualtouchend", {
						touches: u.call(t.touches),
						touchEvent: t
					})
				}
				for(var l = 0; l < t.changedTouches.length; l++) {
					var d = t.changedTouches[l],
						f = d.identifier,
						p = h[f];
					p && (p.pressingHandler && (clearTimeout(p.pressingHandler),
							p.pressingHandler = null),
						"panning" === p.status && n(p.element, "panend", {
							touch: d,
							touchEvent: t
						}),
						"pressing" === p.status && n(p.element, "pressend", {
							touch: d,
							touchEvent: t
						}),
						delete h[f])
				}
				0 === Object.keys(h).length && (c.removeEventListener("touchmove", o, !1),
					c.removeEventListener("touchend", a, !1),
					c.removeEventListener("touchcancel", s, !1))
			}
			var l = t.document,
				c = l.documentElement,
				u = Array.prototype.slice,
				h = {},
				d = null;
			c.addEventListener("touchstart", r, !1)
		}(window, window.lib || (window.lib = {})),
		t.exports = window.lib.gesture
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r() {
		d.default.getScene() || d.default.init();
		var t = d.default.getScene();
		p.default.init(t),
			v.default.init(t),
			w.default.init(t),
			M.default.init(t),
			b.default.init(t),
			_.default.init(t),
			S.default.init(I),
			C.default.on(L, function() {
				b.default.float()
			})
	}

	function o() {
		b.default.show()
	}

	function a(t) {
		var e = t * A.default.moveSpeed;
		v.default.update(e),
			M.default.update(e, t),
			w.default.update(),
			A.default.orientationControlling && (b.default.update(t),
				d.default.update()),
			_.default.update(e, t),
			p.default.update(e, t)
	}

	function s() {
		return d.default.getCamera()
	}

	function l() {
		return S.default.getRenderer().domElement
	}

	function c() {
		I.style.visibility = "visible"
	}

	function u() {
		I.style.visibility = "hidden"
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var h = n(8),
		d = i(h),
		f = n(17),
		p = i(f),
		m = n(28),
		v = i(m),
		g = n(29),
		_ = i(g),
		y = n(31),
		b = i(y),
		x = n(32),
		w = i(x),
		T = n(49),
		M = i(T),
		E = n(52),
		S = i(E),
		X = n(11),
		A = i(X),
		P = n(10),
		R = i(P),
		O = n(30),
		C = i(O),
		L = (R.default.ACCEL,
			R.default.MOVE_STEP,
			R.default.MEET_END),
		I = (R.default.SCREEN_WIDTH,
			R.default.SCREEN_HEIGHT,
			document.querySelector("#main-districts"));
	e.default = {
		init: r,
		show: c,
		hide: u,
		showAvatar: o,
		update: a,
		getStageCamera: s,
		getRendererDom: l
	}
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function o() {
		X = new d.Scene,
			X.fog = new d.Fog(y, .8 * E, 1.5 *E),
			X.background = P
	}

	function a() {
		return X
	}

	function s() {
		return A
	}

	function l() {
		location.search.indexOf("overlook") > -1 ? (A = new f.OrthographicCamera(M / -.04, M / .04, S / .04, S / -.04, 1, 15e5),
			location.search.indexOf("side") > -1 && (A.position.x = -5e3)) : (A = new d.PerspectiveCamera(100, M / S, 1, 1.5 * E),
			A.position.x = b,
			A.position.y = x,
			A.position.z = w)
	}

	function c() {
		R = new f.AmbientLight(4276545, .01),
			R.color.r = R.color.g = R.color.b = 41,
			X.add(R),
			C.forEach(function(t) {
				var e = new f.SpotLight(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
				e.position.set(t.position.x, t.position.y, t.position.z),
					X.add(e);
				var n = new f.Object3D;
				n.position.set(0, 3600, e.position.z),
					X.add(n),
					e.target = n;
				var i = new f.SpotLightHelper(e);
				e.lightHelper = i,
					e.lightHelper.visible = !1,
					X.add(i),
					O.push(e)
			})
	}

	function u() {
		0 === g.default.status ? X.background = P : X.background = null;
		var t = (g.default.expectedControlX,
				g.default.expectedControlY),
			e = 1;
		A.position.y = 1e3 + t / e * T,
			g.default.lookingAround || A.lookAt(new f.Vector3(A.position.x, A.position.y, -9999))
	}

	function h(t) {
		o(),
			l(),
			c()
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var d = n(9),
		f = r(d),
		p = n(10),
		m = i(p),
		v = n(11),
		g = i(v),
		_ = n(14),
		y = (i(_),
			n(26),
			m.default.FLOOR_DEPTH,
			m.default.FOG_COLOR),
		b = (m.default.FINAL_MAX_SPEED,
			m.default.MOVE_STEP,
			m.default.CAMERA_X),
		x = m.default.CAMERA_Y,
		w = m.default.CAMERA_Z,
		T = (m.default.X_LIMIT,
			m.default.Y_LIMIT),
		M = m.default.SCREEN_WIDTH,
		E = m.default.BUILDING_DEPTH,
		S = m.default.SCREEN_HEIGHT,
		X = void 0,
		A = void 0,
		P = (new f.CubeTextureLoader).setCrossOrigin("anonymous").load(["./img/TB1yM4lSXXXXXatXpXXXXXXXXXX-1024-1024.png", "./img/TB1yM4lSXXXXXatXpXXXXXXXXXX-1024-1024.png", "./img/TB1yM4lSXXXXXatXpXXXXXXXXXX-1024-1024.png", "./img/TB1yM4lSXXXXXatXpXXXXXXXXXX-1024-1024.png", "./img/TB1yM4lSXXXXXatXpXXXXXXXXXX-1024-1024.png", "./img/TB1Eg.RRVXXXXc9XVXXXXXXXXXX-1024-1024.jpg"]),
		R = void 0,
		O = [],
		C = g.default.lights;
	e.default = {
		init: h,
		getScene: a,
		getCamera: s,
		update: u
	}
}, function(t, e, n) {
	! function(t, n) {
		n(e)
	}(this, function(t) {
		"use strict";

		function e() {}

		function n(t, e) {
			this.x = t || 0,
				this.y = e || 0
		}

		function i(t, e, r, o, a, s, l, c, u, h) {
			Object.defineProperty(this, "id", {
					value: ws++
				}),
				this.uuid = xs.generateUUID(),
				this.name = "",
				this.image = void 0 !== t ? t : i.DEFAULT_IMAGE,
				this.mipmaps = [],
				this.mapping = void 0 !== e ? e : i.DEFAULT_MAPPING,
				this.wrapS = void 0 !== r ? r : va,
				this.wrapT = void 0 !== o ? o : va,
				this.magFilter = void 0 !== a ? a : xa,
				this.minFilter = void 0 !== s ? s : Ta,
				this.anisotropy = void 0 !== u ? u : 1,
				this.format = void 0 !== l ? l : za,
				this.type = void 0 !== c ? c : Ma,
				this.offset = new n(0, 0),
				this.repeat = new n(1, 1),
				this.generateMipmaps = !0,
				this.premultiplyAlpha = !1,
				this.flipY = !0,
				this.unpackAlignment = 4,
				this.encoding = void 0 !== h ? h : hs,
				this.version = 0,
				this.onUpdate = null
		}

		function r(t, e, n, i) {
			this.x = t || 0,
				this.y = e || 0,
				this.z = n || 0,
				this.w = void 0 !== i ? i : 1
		}

		function o(t, e, n) {
			this.uuid = xs.generateUUID(),
				this.width = t,
				this.height = e,
				this.scissor = new r(0, 0, t, e),
				this.scissorTest = !1,
				this.viewport = new r(0, 0, t, e),
				n = n || {},
				void 0 === n.minFilter && (n.minFilter = xa),
				this.texture = new i(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding),
				this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer,
				this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer,
				this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
		}

		function a(t, e, n) {
			o.call(this, t, e, n),
				this.activeCubeFace = 0,
				this.activeMipMapLevel = 0
		}

		function s(t, e, n, i) {
			this._x = t || 0,
				this._y = e || 0,
				this._z = n || 0,
				this._w = void 0 !== i ? i : 1
		}

		function l(t, e, n) {
			this.x = t || 0,
				this.y = e || 0,
				this.z = n || 0
		}

		function c() {
			this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
				arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
		}

		function u(t, e, n, r, o, a, s, l, c, u, h, d) {
			i.call(this, null, a, s, l, c, u, r, o, h, d),
				this.image = {
					data: t,
					width: e,
					height: n
				},
				this.magFilter = void 0 !== c ? c : _a,
				this.minFilter = void 0 !== u ? u : _a,
				this.generateMipmaps = !1,
				this.flipY = !1,
				this.unpackAlignment = 1
		}

		function h(t, e, n, r, o, a, s, l, c, u) {
			t = void 0 !== t ? t : [],
				e = void 0 !== e ? e : la,
				i.call(this, t, e, n, r, o, a, s, l, c, u),
				this.flipY = !1
		}

		function d() {
			this.seq = [],
				this.map = {}
		}

		function f(t, e, n) {
			var i = t[0];
			if(i <= 0 || i > 0)
				return t;
			var r = e * n,
				o = Es[r];
			if(void 0 === o && (o = new Float32Array(r),
					Es[r] = o),
				0 !== e) {
				i.toArray(o, 0);
				for(var a = 1, s = 0; a !== e; ++a)
					s += n,
					t[a].toArray(o, s)
			}
			return o
		}

		function p(t, e) {
			var n = Ss[e];
			void 0 === n && (n = new Int32Array(e),
				Ss[e] = n);
			for(var i = 0; i !== e; ++i)
				n[i] = t.allocTextureUnit();
			return n
		}

		function m(t, e) {
			t.uniform1f(this.addr, e)
		}

		function v(t, e) {
			t.uniform1i(this.addr, e)
		}

		function g(t, e) {
			void 0 === e.x ? t.uniform2fv(this.addr, e) : t.uniform2f(this.addr, e.x, e.y)
		}

		function _(t, e) {
			void 0 !== e.x ? t.uniform3f(this.addr, e.x, e.y, e.z) : void 0 !== e.r ? t.uniform3f(this.addr, e.r, e.g, e.b) : t.uniform3fv(this.addr, e)
		}

		function y(t, e) {
			void 0 === e.x ? t.uniform4fv(this.addr, e) : t.uniform4f(this.addr, e.x, e.y, e.z, e.w)
		}

		function b(t, e) {
			t.uniformMatrix2fv(this.addr, !1, e.elements || e)
		}

		function x(t, e) {
			void 0 === e.elements ? t.uniformMatrix3fv(this.addr, !1, e) : (As.set(e.elements),
				t.uniformMatrix3fv(this.addr, !1, As))
		}

		function w(t, e) {
			void 0 === e.elements ? t.uniformMatrix4fv(this.addr, !1, e) : (Xs.set(e.elements),
				t.uniformMatrix4fv(this.addr, !1, Xs))
		}

		function T(t, e, n) {
			var i = n.allocTextureUnit();
			t.uniform1i(this.addr, i),
				n.setTexture2D(e || Ts, i)
		}

		function M(t, e, n) {
			var i = n.allocTextureUnit();
			t.uniform1i(this.addr, i),
				n.setTextureCube(e || Ms, i)
		}

		function E(t, e) {
			t.uniform2iv(this.addr, e)
		}

		function S(t, e) {
			t.uniform3iv(this.addr, e)
		}

		function X(t, e) {
			t.uniform4iv(this.addr, e)
		}

		function A(t) {
			switch(t) {
				case 5126:
					return m;
				case 35664:
					return g;
				case 35665:
					return _;
				case 35666:
					return y;
				case 35674:
					return b;
				case 35675:
					return x;
				case 35676:
					return w;
				case 35678:
					return T;
				case 35680:
					return M;
				case 5124:
				case 35670:
					return v;
				case 35667:
				case 35671:
					return E;
				case 35668:
				case 35672:
					return S;
				case 35669:
				case 35673:
					return X
			}
		}

		function P(t, e) {
			t.uniform1fv(this.addr, e)
		}

		function R(t, e) {
			t.uniform1iv(this.addr, e)
		}

		function O(t, e) {
			t.uniform2fv(this.addr, f(e, this.size, 2))
		}

		function C(t, e) {
			t.uniform3fv(this.addr, f(e, this.size, 3))
		}

		function L(t, e) {
			t.uniform4fv(this.addr, f(e, this.size, 4))
		}

		function I(t, e) {
			t.uniformMatrix2fv(this.addr, !1, f(e, this.size, 4))
		}

		function D(t, e) {
			t.uniformMatrix3fv(this.addr, !1, f(e, this.size, 9))
		}

		function B(t, e) {
			t.uniformMatrix4fv(this.addr, !1, f(e, this.size, 16))
		}

		function F(t, e, n) {
			var i = e.length,
				r = p(n, i);
			t.uniform1iv(this.addr, r);
			for(var o = 0; o !== i; ++o)
				n.setTexture2D(e[o] || Ts, r[o])
		}

		function z(t, e, n) {
			var i = e.length,
				r = p(n, i);
			t.uniform1iv(this.addr, r);
			for(var o = 0; o !== i; ++o)
				n.setTextureCube(e[o] || Ms, r[o])
		}

		function N(t) {
			switch(t) {
				case 5126:
					return P;
				case 35664:
					return O;
				case 35665:
					return C;
				case 35666:
					return L;
				case 35674:
					return I;
				case 35675:
					return D;
				case 35676:
					return B;
				case 35678:
					return F;
				case 35680:
					return z;
				case 5124:
				case 35670:
					return R;
				case 35667:
				case 35671:
					return E;
				case 35668:
				case 35672:
					return S;
				case 35669:
				case 35673:
					return X
			}
		}

		function k(t, e, n) {
			this.id = t,
				this.addr = n,
				this.setValue = A(e.type)
		}

		function U(t, e, n) {
			this.id = t,
				this.addr = n,
				this.size = e.size,
				this.setValue = N(e.type)
		}

		function j(t) {
			this.id = t,
				d.call(this)
		}

		function V(t, e) {
			t.seq.push(e),
				t.map[e.id] = e
		}

		function G(t, e, n) {
			var i = t.name,
				r = i.length;
			for(Ps.lastIndex = 0;;) {
				var o = Ps.exec(i),
					a = Ps.lastIndex,
					s = o[1],
					l = "]" === o[2],
					c = o[3];
				if(l && (s |= 0),
					void 0 === c || "[" === c && a + 2 === r) {
					V(n, void 0 === c ? new k(s, t, e) : new U(s, t, e));
					break
				}
				var u = n.map,
					h = u[s];
				void 0 === h && (h = new j(s),
						V(n, h)),
					n = h
			}
		}

		function H(t, e, n) {
			d.call(this),
				this.renderer = n;
			for(var i = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), r = 0; r < i; ++r) {
				var o = t.getActiveUniform(e, r),
					a = o.name,
					s = t.getUniformLocation(e, a);
				G(o, s, this)
			}
		}

		function W(t, e, n) {
			return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
		}

		function Y(t, e) {
			this.min = void 0 !== t ? t : new n(+(1 / 0), +(1 / 0)),
				this.max = void 0 !== e ? e : new n(-(1 / 0), -(1 / 0))
		}

		function q(t, e) {
			function i() {
				var t = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
					e = new Uint16Array([0, 1, 2, 0, 2, 3]);
				o = p.createBuffer(),
					a = p.createBuffer(),
					p.bindBuffer(p.ARRAY_BUFFER, o),
					p.bufferData(p.ARRAY_BUFFER, t, p.STATIC_DRAW),
					p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, a),
					p.bufferData(p.ELEMENT_ARRAY_BUFFER, e, p.STATIC_DRAW),
					d = p.createTexture(),
					f = p.createTexture(),
					m.bindTexture(p.TEXTURE_2D, d),
					p.texImage2D(p.TEXTURE_2D, 0, p.RGB, 16, 16, 0, p.RGB, p.UNSIGNED_BYTE, null),
					p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE),
					p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE),
					p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, p.NEAREST),
					p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, p.NEAREST),
					m.bindTexture(p.TEXTURE_2D, f),
					p.texImage2D(p.TEXTURE_2D, 0, p.RGBA, 16, 16, 0, p.RGBA, p.UNSIGNED_BYTE, null),
					p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE),
					p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE),
					p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, p.NEAREST),
					p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, p.NEAREST),
					s = {
						vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
						fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
					},
					c = r(s),
					u = {
						vertex: p.getAttribLocation(c, "position"),
						uv: p.getAttribLocation(c, "uv")
					},
					h = {
						renderType: p.getUniformLocation(c, "renderType"),
						map: p.getUniformLocation(c, "map"),
						occlusionMap: p.getUniformLocation(c, "occlusionMap"),
						opacity: p.getUniformLocation(c, "opacity"),
						color: p.getUniformLocation(c, "color"),
						scale: p.getUniformLocation(c, "scale"),
						rotation: p.getUniformLocation(c, "rotation"),
						screenPosition: p.getUniformLocation(c, "screenPosition")
					}
			}

			function r(e) {
				var n = p.createProgram(),
					i = p.createShader(p.FRAGMENT_SHADER),
					r = p.createShader(p.VERTEX_SHADER),
					o = "precision " + t.getPrecision() + " float;\n";
				return p.shaderSource(i, o + e.fragmentShader),
					p.shaderSource(r, o + e.vertexShader),
					p.compileShader(i),
					p.compileShader(r),
					p.attachShader(n, i),
					p.attachShader(n, r),
					p.linkProgram(n),
					n
			}
			var o, a, s, c, u, h, d, f, p = t.context,
				m = t.state;
			this.render = function(r, s, v) {
				if(0 !== e.length) {
					var g = new l,
						_ = v.w / v.z,
						y = .5 * v.z,
						b = .5 * v.w,
						x = 16 / v.w,
						w = new n(x * _, x),
						T = new l(1, 1, 0),
						M = new n(1, 1),
						E = new Y;
					E.min.set(v.x, v.y),
						E.max.set(v.x + (v.z - 16), v.y + (v.w - 16)),
						void 0 === c && i(),
						p.useProgram(c),
						m.initAttributes(),
						m.enableAttribute(u.vertex),
						m.enableAttribute(u.uv),
						m.disableUnusedAttributes(),
						p.uniform1i(h.occlusionMap, 0),
						p.uniform1i(h.map, 1),
						p.bindBuffer(p.ARRAY_BUFFER, o),
						p.vertexAttribPointer(u.vertex, 2, p.FLOAT, !1, 16, 0),
						p.vertexAttribPointer(u.uv, 2, p.FLOAT, !1, 16, 8),
						p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, a),
						m.disable(p.CULL_FACE),
						m.buffers.depth.setMask(!1);
					for(var S = 0, X = e.length; S < X; S++) {
						x = 16 / v.w,
							w.set(x * _, x);
						var A = e[S];
						if(g.set(A.matrixWorld.elements[12], A.matrixWorld.elements[13], A.matrixWorld.elements[14]),
							g.applyMatrix4(s.matrixWorldInverse),
							g.applyMatrix4(s.projectionMatrix),
							T.copy(g),
							M.x = v.x + T.x * y + y - 8,
							M.y = v.y + T.y * b + b - 8,
							E.containsPoint(M) === !0) {
							m.activeTexture(p.TEXTURE0),
								m.bindTexture(p.TEXTURE_2D, null),
								m.activeTexture(p.TEXTURE1),
								m.bindTexture(p.TEXTURE_2D, d),
								p.copyTexImage2D(p.TEXTURE_2D, 0, p.RGB, M.x, M.y, 16, 16, 0),
								p.uniform1i(h.renderType, 0),
								p.uniform2f(h.scale, w.x, w.y),
								p.uniform3f(h.screenPosition, T.x, T.y, T.z),
								m.disable(p.BLEND),
								m.enable(p.DEPTH_TEST),
								p.drawElements(p.TRIANGLES, 6, p.UNSIGNED_SHORT, 0),
								m.activeTexture(p.TEXTURE0),
								m.bindTexture(p.TEXTURE_2D, f),
								p.copyTexImage2D(p.TEXTURE_2D, 0, p.RGBA, M.x, M.y, 16, 16, 0),
								p.uniform1i(h.renderType, 1),
								m.disable(p.DEPTH_TEST),
								m.activeTexture(p.TEXTURE1),
								m.bindTexture(p.TEXTURE_2D, d),
								p.drawElements(p.TRIANGLES, 6, p.UNSIGNED_SHORT, 0),
								A.positionScreen.copy(T),
								A.customUpdateCallback ? A.customUpdateCallback(A) : A.updateLensFlares(),
								p.uniform1i(h.renderType, 2),
								m.enable(p.BLEND);
							for(var P = 0, R = A.lensFlares.length; P < R; P++) {
								var O = A.lensFlares[P];
								O.opacity > .001 && O.scale > .001 && (T.x = O.x,
									T.y = O.y,
									T.z = O.z,
									x = O.size * O.scale / v.w,
									w.x = x * _,
									w.y = x,
									p.uniform3f(h.screenPosition, T.x, T.y, T.z),
									p.uniform2f(h.scale, w.x, w.y),
									p.uniform1f(h.rotation, O.rotation),
									p.uniform1f(h.opacity, O.opacity),
									p.uniform3f(h.color, O.color.r, O.color.g, O.color.b),
									m.setBlending(O.blending, O.blendEquation, O.blendSrc, O.blendDst),
									t.setTexture2D(O.texture, 1),
									p.drawElements(p.TRIANGLES, 6, p.UNSIGNED_SHORT, 0))
							}
						}
					}
					m.enable(p.CULL_FACE),
						m.enable(p.DEPTH_TEST),
						m.buffers.depth.setMask(!0),
						t.resetGLState()
				}
			}
		}

		function Z(t, e) {
			function n() {
				var t = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
					e = new Uint16Array([0, 1, 2, 0, 2, 3]);
				a = p.createBuffer(),
					c = p.createBuffer(),
					p.bindBuffer(p.ARRAY_BUFFER, a),
					p.bufferData(p.ARRAY_BUFFER, t, p.STATIC_DRAW),
					p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, c),
					p.bufferData(p.ELEMENT_ARRAY_BUFFER, e, p.STATIC_DRAW),
					u = r(),
					h = {
						position: p.getAttribLocation(u, "position"),
						uv: p.getAttribLocation(u, "uv")
					},
					d = {
						uvOffset: p.getUniformLocation(u, "uvOffset"),
						uvScale: p.getUniformLocation(u, "uvScale"),
						rotation: p.getUniformLocation(u, "rotation"),
						scale: p.getUniformLocation(u, "scale"),
						color: p.getUniformLocation(u, "color"),
						map: p.getUniformLocation(u, "map"),
						opacity: p.getUniformLocation(u, "opacity"),
						modelViewMatrix: p.getUniformLocation(u, "modelViewMatrix"),
						projectionMatrix: p.getUniformLocation(u, "projectionMatrix"),
						fogType: p.getUniformLocation(u, "fogType"),
						fogDensity: p.getUniformLocation(u, "fogDensity"),
						fogNear: p.getUniformLocation(u, "fogNear"),
						fogFar: p.getUniformLocation(u, "fogFar"),
						fogColor: p.getUniformLocation(u, "fogColor"),
						alphaTest: p.getUniformLocation(u, "alphaTest")
					};
				var n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
				n.width = 8,
					n.height = 8;
				var o = n.getContext("2d");
				o.fillStyle = "white",
					o.fillRect(0, 0, 8, 8),
					f = new i(n),
					f.needsUpdate = !0
			}

			function r() {
				var e = p.createProgram(),
					n = p.createShader(p.VERTEX_SHADER),
					i = p.createShader(p.FRAGMENT_SHADER);
				return p.shaderSource(n, ["precision " + t.getPrecision() + " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}"].join("\n")),
					p.shaderSource(i, ["precision " + t.getPrecision() + " float;", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\n")),
					p.compileShader(n),
					p.compileShader(i),
					p.attachShader(e, n),
					p.attachShader(e, i),
					p.linkProgram(e),
					e
			}

			function o(t, e) {
				return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : e.id - t.id
			}
			var a, c, u, h, d, f, p = t.context,
				m = t.state,
				v = new l,
				g = new s,
				_ = new l;
			this.render = function(i, r) {
				if(0 !== e.length) {
					void 0 === u && n(),
						p.useProgram(u),
						m.initAttributes(),
						m.enableAttribute(h.position),
						m.enableAttribute(h.uv),
						m.disableUnusedAttributes(),
						m.disable(p.CULL_FACE),
						m.enable(p.BLEND),
						p.bindBuffer(p.ARRAY_BUFFER, a),
						p.vertexAttribPointer(h.position, 2, p.FLOAT, !1, 16, 0),
						p.vertexAttribPointer(h.uv, 2, p.FLOAT, !1, 16, 8),
						p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, c),
						p.uniformMatrix4fv(d.projectionMatrix, !1, r.projectionMatrix.elements),
						m.activeTexture(p.TEXTURE0),
						p.uniform1i(d.map, 0);
					var s = 0,
						l = 0,
						y = i.fog;
					y ? (p.uniform3f(d.fogColor, y.color.r, y.color.g, y.color.b),
						y.isFog ? (p.uniform1f(d.fogNear, y.near),
							p.uniform1f(d.fogFar, y.far),
							p.uniform1i(d.fogType, 1),
							s = 1,
							l = 1) : y.isFogExp2 && (p.uniform1f(d.fogDensity, y.density),
							p.uniform1i(d.fogType, 2),
							s = 2,
							l = 2)) : (p.uniform1i(d.fogType, 0),
						s = 0,
						l = 0);
					for(var b = 0, x = e.length; b < x; b++) {
						var w = e[b];
						w.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, w.matrixWorld),
							w.z = -w.modelViewMatrix.elements[14]
					}
					e.sort(o);
					for(var T = [], b = 0, x = e.length; b < x; b++) {
						var w = e[b],
							M = w.material;
						if(M.visible !== !1) {
							p.uniform1f(d.alphaTest, M.alphaTest),
								p.uniformMatrix4fv(d.modelViewMatrix, !1, w.modelViewMatrix.elements),
								w.matrixWorld.decompose(v, g, _),
								T[0] = _.x,
								T[1] = _.y;
							var E = 0;
							i.fog && M.fog && (E = l),
								s !== E && (p.uniform1i(d.fogType, E),
									s = E),
								null !== M.map ? (p.uniform2f(d.uvOffset, M.map.offset.x, M.map.offset.y),
									p.uniform2f(d.uvScale, M.map.repeat.x, M.map.repeat.y)) : (p.uniform2f(d.uvOffset, 0, 0),
									p.uniform2f(d.uvScale, 1, 1)),
								p.uniform1f(d.opacity, M.opacity),
								p.uniform3f(d.color, M.color.r, M.color.g, M.color.b),
								p.uniform1f(d.rotation, M.rotation),
								p.uniform2fv(d.scale, T),
								m.setBlending(M.blending, M.blendEquation, M.blendSrc, M.blendDst),
								m.buffers.depth.setTest(M.depthTest),
								m.buffers.depth.setMask(M.depthWrite),
								M.map ? t.setTexture2D(M.map, 0) : t.setTexture2D(f, 0),
								p.drawElements(p.TRIANGLES, 6, p.UNSIGNED_SHORT, 0)
						}
					}
					m.enable(p.CULL_FACE),
						t.resetGLState()
				}
			}
		}

		function Q() {
			Object.defineProperty(this, "id", {
					value: Fc++
				}),
				this.uuid = xs.generateUUID(),
				this.name = "",
				this.type = "Material",
				this.fog = !0,
				this.lights = !0,
				this.blending = Mo,
				this.side = mo,
				this.shading = yo,
				this.vertexColors = bo,
				this.opacity = 1,
				this.transparent = !1,
				this.blendSrc = zo,
				this.blendDst = No,
				this.blendEquation = Po,
				this.blendSrcAlpha = null,
				this.blendDstAlpha = null,
				this.blendEquationAlpha = null,
				this.depthFunc = qo,
				this.depthTest = !0,
				this.depthWrite = !0,
				this.clippingPlanes = null,
				this.clipIntersection = !1,
				this.clipShadows = !1,
				this.colorWrite = !0,
				this.precision = null,
				this.polygonOffset = !1,
				this.polygonOffsetFactor = 0,
				this.polygonOffsetUnits = 0,
				this.dithering = !1,
				this.alphaTest = 0,
				this.premultipliedAlpha = !1,
				this.overdraw = 0,
				this.visible = !0,
				this.needsUpdate = !0
		}

		function J(t) {
			Q.call(this),
				this.type = "ShaderMaterial",
				this.defines = {},
				this.uniforms = {},
				this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
				this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
				this.linewidth = 1,
				this.wireframe = !1,
				this.wireframeLinewidth = 1,
				this.fog = !1,
				this.lights = !1,
				this.clipping = !1,
				this.skinning = !1,
				this.morphTargets = !1,
				this.morphNormals = !1,
				this.extensions = {
					derivatives: !1,
					fragDepth: !1,
					drawBuffers: !1,
					shaderTextureLOD: !1
				},
				this.defaultAttributeValues = {
					color: [1, 1, 1],
					uv: [0, 0],
					uv2: [0, 0]
				},
				this.index0AttributeName = void 0,
				void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
					this.setValues(t))
		}

		function K(t) {
			Q.call(this),
				this.type = "MeshDepthMaterial",
				this.depthPacking = ys,
				this.skinning = !1,
				this.morphTargets = !1,
				this.map = null,
				this.alphaMap = null,
				this.displacementMap = null,
				this.displacementScale = 1,
				this.displacementBias = 0,
				this.wireframe = !1,
				this.wireframeLinewidth = 1,
				this.fog = !1,
				this.lights = !1,
				this.setValues(t)
		}

		function $(t, e) {
			this.min = void 0 !== t ? t : new l(+(1 / 0), +(1 / 0), +(1 / 0)),
				this.max = void 0 !== e ? e : new l(-(1 / 0), -(1 / 0), -(1 / 0))
		}

		function tt(t, e) {
			this.center = void 0 !== t ? t : new l,
				this.radius = void 0 !== e ? e : 0
		}

		function et() {
			this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
				arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
		}

		function nt(t, e) {
			this.normal = void 0 !== t ? t : new l(1, 0, 0),
				this.constant = void 0 !== e ? e : 0
		}

		function it(t, e, n, i, r, o) {
			this.planes = [void 0 !== t ? t : new nt, void 0 !== e ? e : new nt, void 0 !== n ? n : new nt, void 0 !== i ? i : new nt, void 0 !== r ? r : new nt, void 0 !== o ? o : new nt]
		}

		function rt(t, e, i, a) {
			function s(e, n, i, r) {
				var o = e.geometry,
					a = null,
					s = T,
					l = e.customDepthMaterial;
				if(i && (s = M,
						l = e.customDistanceMaterial),
					l)
					a = l;
				else {
					var c = !1;
					n.morphTargets && (o && o.isBufferGeometry ? c = o.morphAttributes && o.morphAttributes.position && o.morphAttributes.position.length > 0 : o && o.isGeometry && (c = o.morphTargets && o.morphTargets.length > 0)),
						e.isSkinnedMesh && n.skinning === !1 && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e);
					var u = e.isSkinnedMesh && n.skinning,
						h = 0;
					c && (h |= b),
						u && (h |= x),
						a = s[h]
				}
				if(t.localClippingEnabled && n.clipShadows === !0 && 0 !== n.clippingPlanes.length) {
					var d = a.uuid,
						f = n.uuid,
						p = E[d];
					void 0 === p && (p = {},
						E[d] = p);
					var m = p[f];
					void 0 === m && (m = a.clone(),
							p[f] = m),
						a = m
				}
				a.visible = n.visible,
					a.wireframe = n.wireframe;
				var v = n.side;
				return F.renderSingleSided && v == go && (v = mo),
					F.renderReverseSided && (v === mo ? v = vo : v === vo && (v = mo)),
					a.side = v,
					a.clipShadows = n.clipShadows,
					a.clippingPlanes = n.clippingPlanes,
					a.wireframeLinewidth = n.wireframeLinewidth,
					a.linewidth = n.linewidth,
					i && void 0 !== a.uniforms.lightPos && a.uniforms.lightPos.value.copy(r),
					a
			}

			function u(e, n, r, o) {
				if(e.visible !== !1) {
					var a = e.layers.test(n.layers);
					if(a && (e.isMesh || e.isLine || e.isPoints) && e.castShadow && (!e.frustumCulled || f.intersectsObject(e))) {
						e.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, e.matrixWorld);
						var l = i.update(e),
							c = e.material;
						if(Array.isArray(c))
							for(var h = l.groups, d = 0, p = h.length; d < p; d++) {
								var m = h[d],
									v = c[m.materialIndex];
								if(v && v.visible) {
									var g = s(e, v, o, y);
									t.renderBufferDirect(r, null, l, g, e, m)
								}
							}
						else if(c.visible) {
							var g = s(e, c, o, y);
							t.renderBufferDirect(r, null, l, g, e, null)
						}
					}
					for(var _ = e.children, b = 0, x = _.length; b < x; b++)
						u(_[b], n, r, o)
				}
			}
			var h = t.context,
				d = t.state,
				f = new it,
				p = new c,
				m = e.shadows,
				v = new n,
				g = new n(a.maxTextureSize, a.maxTextureSize),
				_ = new l,
				y = new l,
				b = 1,
				x = 2,
				w = (b | x) + 1,
				T = new Array(w),
				M = new Array(w),
				E = {},
				S = [new l(1, 0, 0), new l(-1, 0, 0), new l(0, 0, 1), new l(0, 0, -1), new l(0, 1, 0), new l(0, -1, 0)],
				X = [new l(0, 1, 0), new l(0, 1, 0), new l(0, 1, 0), new l(0, 1, 0), new l(0, 0, 1), new l(0, 0, -1)],
				A = [new r, new r, new r, new r, new r, new r],
				P = new K;
			P.depthPacking = bs,
				P.clipping = !0;
			for(var R = Bc.distanceRGBA, O = Cs.clone(R.uniforms), C = 0; C !== w; ++C) {
				var L = 0 !== (C & b),
					I = 0 !== (C & x),
					D = P.clone();
				D.morphTargets = L,
					D.skinning = I,
					T[C] = D;
				var B = new J({
					defines: {
						USE_SHADOWMAP: ""
					},
					uniforms: O,
					vertexShader: R.vertexShader,
					fragmentShader: R.fragmentShader,
					morphTargets: L,
					skinning: I,
					clipping: !0
				});
				M[C] = B
			}
			var F = this;
			this.enabled = !1,
				this.autoUpdate = !0,
				this.needsUpdate = !1,
				this.type = fo,
				this.renderReverseSided = !0,
				this.renderSingleSided = !0,
				this.render = function(e, n) {
					if(F.enabled !== !1 && (F.autoUpdate !== !1 || F.needsUpdate !== !1) && 0 !== m.length) {
						d.disable(h.BLEND),
							d.buffers.color.setClear(1, 1, 1, 1),
							d.buffers.depth.setTest(!0),
							d.setScissorTest(!1);
						for(var i, r, a = 0, s = m.length; a < s; a++) {
							var l = m[a],
								c = l.shadow;
							if(void 0 !== c) {
								var b = c.camera,
									x = c.matrix;
								if(y.setFromMatrixPosition(l.matrixWorld),
									b.position.copy(y),
									v.copy(c.mapSize),
									v.min(g),
									l && l.isPointLight) {
									i = 6,
										r = !0;
									var w = v.x,
										T = v.y;
									A[0].set(2 * w, T, w, T),
										A[1].set(0, T, w, T),
										A[2].set(3 * w, T, w, T),
										A[3].set(w, T, w, T),
										A[4].set(3 * w, 0, w, T),
										A[5].set(w, 0, w, T),
										v.x *= 4,
										v.y *= 2,
										x.makeTranslation(-y.x, -y.y, -y.z)
								} else
									i = 1,
									r = !1,
									_.setFromMatrixPosition(l.target.matrixWorld),
									b.lookAt(_),
									b.updateMatrixWorld(),
									b.matrixWorldInverse.getInverse(b.matrixWorld),
									x.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
									x.multiply(b.projectionMatrix),
									x.multiply(b.matrixWorldInverse);
								if(null === c.map) {
									var M = {
										minFilter: _a,
										magFilter: _a,
										format: za
									};
									c.map = new o(v.x, v.y, M),
										c.map.texture.name = l.name + ".shadowMap",
										b.updateProjectionMatrix()
								}
								c.isSpotLightShadow && c.update(l);
								var E = c.map;
								t.setRenderTarget(E),
									t.clear();
								for(var P = 0; P < i; P++) {
									if(r) {
										_.copy(b.position),
											_.add(S[P]),
											b.up.copy(X[P]),
											b.lookAt(_),
											b.updateMatrixWorld(),
											b.matrixWorldInverse.getInverse(b.matrixWorld);
										var R = A[P];
										d.viewport(R)
									}
									p.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse),
										f.setFromMatrix(p),
										u(e, n, b, r)
								}
							} else
								console.warn("THREE.WebGLShadowMap:", l, "has no shadow.")
						}
						var O = t.getClearColor(),
							C = t.getClearAlpha();
						t.setClearColor(O, C),
							F.needsUpdate = !1
					}
				}
		}

		function ot(t, e) {
			this.origin = void 0 !== t ? t : new l,
				this.direction = void 0 !== e ? e : new l
		}

		function at(t, e, n, i) {
			this._x = t || 0,
				this._y = e || 0,
				this._z = n || 0,
				this._order = i || at.DefaultOrder
		}

		function st() {
			this.mask = 1
		}

		function lt() {
			function t() {
				r.setFromEuler(i, !1)
			}

			function e() {
				i.setFromQuaternion(r, void 0, !1)
			}
			Object.defineProperty(this, "id", {
					value: zc++
				}),
				this.uuid = xs.generateUUID(),
				this.name = "",
				this.type = "Object3D",
				this.parent = null,
				this.children = [],
				this.up = lt.DefaultUp.clone();
			var n = new l,
				i = new at,
				r = new s,
				o = new l(1, 1, 1);
			i.onChange(t),
				r.onChange(e),
				Object.defineProperties(this, {
					position: {
						enumerable: !0,
						value: n
					},
					rotation: {
						enumerable: !0,
						value: i
					},
					quaternion: {
						enumerable: !0,
						value: r
					},
					scale: {
						enumerable: !0,
						value: o
					},
					modelViewMatrix: {
						value: new c
					},
					normalMatrix: {
						value: new et
					}
				}),
				this.matrix = new c,
				this.matrixWorld = new c,
				this.matrixAutoUpdate = lt.DefaultMatrixAutoUpdate,
				this.matrixWorldNeedsUpdate = !1,
				this.layers = new st,
				this.visible = !0,
				this.castShadow = !1,
				this.receiveShadow = !1,
				this.frustumCulled = !0,
				this.renderOrder = 0,
				this.userData = {},
				this.onBeforeRender = function() {},
				this.onAfterRender = function() {}
		}

		function ct(t, e) {
			this.start = void 0 !== t ? t : new l,
				this.end = void 0 !== e ? e : new l
		}

		function ut(t, e, n) {
			this.a = void 0 !== t ? t : new l,
				this.b = void 0 !== e ? e : new l,
				this.c = void 0 !== n ? n : new l
		}

		function ht(t, e, n, i, r, o) {
			this.a = t,
				this.b = e,
				this.c = n,
				this.normal = i && i.isVector3 ? i : new l,
				this.vertexNormals = Array.isArray(i) ? i : [],
				this.color = r && r.isColor ? r : new W,
				this.vertexColors = Array.isArray(r) ? r : [],
				this.materialIndex = void 0 !== o ? o : 0
		}

		function dt(t) {
			Q.call(this),
				this.type = "MeshBasicMaterial",
				this.color = new W(16777215),
				this.map = null,
				this.lightMap = null,
				this.lightMapIntensity = 1,
				this.aoMap = null,
				this.aoMapIntensity = 1,
				this.specularMap = null,
				this.alphaMap = null,
				this.envMap = null,
				this.combine = $o,
				this.reflectivity = 1,
				this.refractionRatio = .98,
				this.wireframe = !1,
				this.wireframeLinewidth = 1,
				this.wireframeLinecap = "round",
				this.wireframeLinejoin = "round",
				this.skinning = !1,
				this.morphTargets = !1,
				this.lights = !1,
				this.setValues(t)
		}

		function ft(t, e, n) {
			if(Array.isArray(t))
				throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
			this.uuid = xs.generateUUID(),
				this.array = t,
				this.itemSize = e,
				this.count = void 0 !== t ? t.length / e : 0,
				this.normalized = n === !0,
				this.dynamic = !1,
				this.updateRange = {
					offset: 0,
					count: -1
				},
				this.onUploadCallback = function() {},
				this.version = 0
		}

		function pt(t, e) {
			ft.call(this, new Int8Array(t), e)
		}

		function mt(t, e) {
			ft.call(this, new Uint8Array(t), e)
		}

		function vt(t, e) {
			ft.call(this, new Uint8ClampedArray(t), e)
		}

		function gt(t, e) {
			ft.call(this, new Int16Array(t), e)
		}

		function _t(t, e) {
			ft.call(this, new Uint16Array(t), e)
		}

		function yt(t, e) {
			ft.call(this, new Int32Array(t), e)
		}

		function bt(t, e) {
			ft.call(this, new Uint32Array(t), e)
		}

		function xt(t, e) {
			ft.call(this, new Float32Array(t), e)
		}

		function wt(t, e) {
			ft.call(this, new Float64Array(t), e)
		}

		function Tt() {
			this.indices = [],
				this.vertices = [],
				this.normals = [],
				this.colors = [],
				this.uvs = [],
				this.uvs2 = [],
				this.groups = [],
				this.morphTargets = {},
				this.skinWeights = [],
				this.skinIndices = [],
				this.boundingBox = null,
				this.boundingSphere = null,
				this.verticesNeedUpdate = !1,
				this.normalsNeedUpdate = !1,
				this.colorsNeedUpdate = !1,
				this.uvsNeedUpdate = !1,
				this.groupsNeedUpdate = !1
		}

		function Mt(t) {
			if(0 === t.length)
				return -(1 / 0);
			for(var e = t[0], n = 1, i = t.length; n < i; ++n)
				t[n] > e && (e = t[n]);
			return e
		}

		function Et() {
			return Nc++
		}

		function St() {
			Object.defineProperty(this, "id", {
					value: Et()
				}),
				this.uuid = xs.generateUUID(),
				this.name = "",
				this.type = "Geometry",
				this.vertices = [],
				this.colors = [],
				this.faces = [],
				this.faceVertexUvs = [
					[]
				],
				this.morphTargets = [],
				this.morphNormals = [],
				this.skinWeights = [],
				this.skinIndices = [],
				this.lineDistances = [],
				this.boundingBox = null,
				this.boundingSphere = null,
				this.elementsNeedUpdate = !1,
				this.verticesNeedUpdate = !1,
				this.uvsNeedUpdate = !1,
				this.normalsNeedUpdate = !1,
				this.colorsNeedUpdate = !1,
				this.lineDistancesNeedUpdate = !1,
				this.groupsNeedUpdate = !1
		}

		function Xt() {
			Object.defineProperty(this, "id", {
					value: Et()
				}),
				this.uuid = xs.generateUUID(),
				this.name = "",
				this.type = "BufferGeometry",
				this.index = null,
				this.attributes = {},
				this.morphAttributes = {},
				this.groups = [],
				this.boundingBox = null,
				this.boundingSphere = null,
				this.drawRange = {
					start: 0,
					count: 1 / 0
				}
		}

		function At(t, e) {
			lt.call(this),
				this.type = "Mesh",
				this.geometry = void 0 !== t ? t : new Xt,
				this.material = void 0 !== e ? e : new dt({
					color: 16777215 * Math.random()
				}),
				this.drawMode = ls,
				this.updateMorphTargets()
		}

		function Pt(t, e, n, i, r, o) {
			St.call(this),
				this.type = "BoxGeometry",
				this.parameters = {
					width: t,
					height: e,
					depth: n,
					widthSegments: i,
					heightSegments: r,
					depthSegments: o
				},
				this.fromBufferGeometry(new Rt(t, e, n, i, r, o)),
				this.mergeVertices()
		}

		function Rt(t, e, n, i, r, o) {
			function a(t, e, n, i, r, o, a, m, v, g, _) {
				var y, b, x = o / v,
					w = a / g,
					T = o / 2,
					M = a / 2,
					E = m / 2,
					S = v + 1,
					X = g + 1,
					A = 0,
					P = 0,
					R = new l;
				for(b = 0; b < X; b++) {
					var O = b * w - M;
					for(y = 0; y < S; y++) {
						var C = y * x - T;
						R[t] = C * i,
							R[e] = O * r,
							R[n] = E,
							u.push(R.x, R.y, R.z),
							R[t] = 0,
							R[e] = 0,
							R[n] = m > 0 ? 1 : -1,
							h.push(R.x, R.y, R.z),
							d.push(y / v),
							d.push(1 - b / g),
							A += 1
					}
				}
				for(b = 0; b < g; b++)
					for(y = 0; y < v; y++) {
						var L = f + y + S * b,
							I = f + y + S * (b + 1),
							D = f + (y + 1) + S * (b + 1),
							B = f + (y + 1) + S * b;
						c.push(L, I, B),
							c.push(I, D, B),
							P += 6
					}
				s.addGroup(p, P, _),
					p += P,
					f += A
			}
			Xt.call(this),
				this.type = "BoxBufferGeometry",
				this.parameters = {
					width: t,
					height: e,
					depth: n,
					widthSegments: i,
					heightSegments: r,
					depthSegments: o
				};
			var s = this;
			i = Math.floor(i) || 1,
				r = Math.floor(r) || 1,
				o = Math.floor(o) || 1;
			var c = [],
				u = [],
				h = [],
				d = [],
				f = 0,
				p = 0;
			a("z", "y", "x", -1, -1, n, e, t, o, r, 0),
				a("z", "y", "x", 1, -1, n, e, -t, o, r, 1),
				a("x", "z", "y", 1, 1, t, n, e, i, o, 2),
				a("x", "z", "y", 1, -1, t, n, -e, i, o, 3),
				a("x", "y", "z", 1, -1, t, e, n, i, r, 4),
				a("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
				this.setIndex(c),
				this.addAttribute("position", new xt(u, 3)),
				this.addAttribute("normal", new xt(h, 3)),
				this.addAttribute("uv", new xt(d, 2))
		}

		function Ot(t, e, n, i) {
			St.call(this),
				this.type = "PlaneGeometry",
				this.parameters = {
					width: t,
					height: e,
					widthSegments: n,
					heightSegments: i
				},
				this.fromBufferGeometry(new Ct(t, e, n, i)),
				this.mergeVertices()
		}

		function Ct(t, e, n, i) {
			Xt.call(this),
				this.type = "PlaneBufferGeometry",
				this.parameters = {
					width: t,
					height: e,
					widthSegments: n,
					heightSegments: i
				};
			var r, o, a = t / 2,
				s = e / 2,
				l = Math.floor(n) || 1,
				c = Math.floor(i) || 1,
				u = l + 1,
				h = c + 1,
				d = t / l,
				f = e / c,
				p = [],
				m = [],
				v = [],
				g = [];
			for(o = 0; o < h; o++) {
				var _ = o * f - s;
				for(r = 0; r < u; r++) {
					var y = r * d - a;
					m.push(y, -_, 0),
						v.push(0, 0, 1),
						g.push(r / l),
						g.push(1 - o / c)
				}
			}
			for(o = 0; o < c; o++)
				for(r = 0; r < l; r++) {
					var b = r + u * o,
						x = r + u * (o + 1),
						w = r + 1 + u * (o + 1),
						T = r + 1 + u * o;
					p.push(b, x, T),
						p.push(x, w, T)
				}
			this.setIndex(p),
				this.addAttribute("position", new xt(m, 3)),
				this.addAttribute("normal", new xt(v, 3)),
				this.addAttribute("uv", new xt(g, 2))
		}

		function Lt() {
			lt.call(this),
				this.type = "Camera",
				this.matrixWorldInverse = new c,
				this.projectionMatrix = new c
		}

		function It(t, e, n, i) {
			Lt.call(this),
				this.type = "PerspectiveCamera",
				this.fov = void 0 !== t ? t : 50,
				this.zoom = 1,
				this.near = void 0 !== n ? n : .1,
				this.far = void 0 !== i ? i : 2e3,
				this.focus = 10,
				this.aspect = void 0 !== e ? e : 1,
				this.view = null,
				this.filmGauge = 35,
				this.filmOffset = 0,
				this.updateProjectionMatrix()
		}

		function Dt(t, e, n, i, r, o) {
			Lt.call(this),
				this.type = "OrthographicCamera",
				this.zoom = 1,
				this.view = null,
				this.left = t,
				this.right = e,
				this.top = n,
				this.bottom = i,
				this.near = void 0 !== r ? r : .1,
				this.far = void 0 !== o ? o : 2e3,
				this.updateProjectionMatrix()
		}

		function Bt(t) {
			function e(e, n) {
				var i = e.array,
					r = e.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW,
					o = t.createBuffer();
				t.bindBuffer(n, o),
					t.bufferData(n, i, r),
					e.onUploadCallback();
				var a = t.FLOAT;
				return i instanceof Float32Array ? a = t.FLOAT : i instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : i instanceof Uint16Array ? a = t.UNSIGNED_SHORT : i instanceof Int16Array ? a = t.SHORT : i instanceof Uint32Array ? a = t.UNSIGNED_INT : i instanceof Int32Array ? a = t.INT : i instanceof Int8Array ? a = t.BYTE : i instanceof Uint8Array && (a = t.UNSIGNED_BYTE), {
					buffer: o,
					type: a,
					bytesPerElement: i.BYTES_PER_ELEMENT,
					version: e.version
				}
			}

			function n(e, n, i) {
				var r = n.array,
					o = n.updateRange;
				t.bindBuffer(i, e),
					n.dynamic === !1 ? t.bufferData(i, r, t.STATIC_DRAW) : o.count === -1 ? t.bufferSubData(i, 0, r) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(i, o.offset * r.BYTES_PER_ELEMENT, r.subarray(o.offset, o.offset + o.count)),
						o.count = 0)
			}

			function i(t) {
				return t.isInterleavedBufferAttribute && (t = t.data),
					a[t.uuid]
			}

			function r(e) {
				var n = a[e.uuid];
				n && (t.deleteBuffer(n.buffer),
					delete a[e.uuid])
			}

			function o(t, i) {
				t.isInterleavedBufferAttribute && (t = t.data);
				var r = a[t.uuid];
				void 0 === r ? a[t.uuid] = e(t, i) : r.version < t.version && (n(r.buffer, t, i),
					r.version = t.version)
			}
			var a = {};
			return {
				get: i,
				remove: r,
				update: o
			}
		}

		function Ft(t, e) {
			return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
		}

		function zt(t, e) {
			return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
		}

		function Nt() {
			function t() {
				o = -1,
					s = -1
			}

			function e(t, e, n, i, l) {
				var c, u;
				n.transparent ? (c = a,
					u = ++s) : (c = r,
					u = ++o);
				var h = c[u];
				h ? (h.id = t.id,
					h.object = t,
					h.geometry = e,
					h.material = n,
					h.program = n.program,
					h.renderOrder = t.renderOrder,
					h.z = i,
					h.group = l) : (h = {
						id: t.id,
						object: t,
						geometry: e,
						material: n,
						program: n.program,
						renderOrder: t.renderOrder,
						z: i,
						group: l
					},
					c.push(h))
			}

			function n() {
				r.length = o + 1,
					a.length = s + 1
			}

			function i() {
				r.sort(Ft),
					a.sort(zt)
			}
			var r = [],
				o = -1,
				a = [],
				s = -1;
			return {
				opaque: r,
				transparent: a,
				init: t,
				push: e,
				finish: n,
				sort: i
			}
		}

		function kt() {
			function t(t, e) {
				var i = t.id + "," + e.id,
					r = n[i];
				return void 0 === r && (r = new Nt,
						n[i] = r),
					r
			}

			function e() {
				n = {}
			}
			var n = {};
			return {
				get: t,
				dispose: e
			}
		}

		function Ut(t, e, n) {
			function i(t) {
				s = t
			}

			function r(n) {
				n.array instanceof Uint32Array && e.get("OES_element_index_uint") ? (l = t.UNSIGNED_INT,
					c = 4) : n.array instanceof Uint16Array ? (l = t.UNSIGNED_SHORT,
					c = 2) : (l = t.UNSIGNED_BYTE,
					c = 1)
			}

			function o(e, i) {
				t.drawElements(s, i, l, e * c),
					n.calls++,
					n.vertices += i,
					s === t.TRIANGLES && (n.faces += i / 3)
			}

			function a(i, r, o) {
				var a = e.get("ANGLE_instanced_arrays");
				return null === a ? void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (a.drawElementsInstancedANGLE(s, o, l, r * c, i.maxInstancedCount),
					n.calls++,
					n.vertices += o * i.maxInstancedCount,
					void(s === t.TRIANGLES && (n.faces += i.maxInstancedCount * o / 3)))
			}
			var s, l, c;
			this.setMode = i,
				this.setIndex = r,
				this.render = o,
				this.renderInstances = a
		}

		function jt(t, e, n) {
			function i(t) {
				a = t
			}

			function r(e, i) {
				t.drawArrays(a, e, i),
					n.calls++,
					n.vertices += i,
					a === t.TRIANGLES && (n.faces += i / 3)
			}

			function o(i, r, o) {
				var s = e.get("ANGLE_instanced_arrays");
				if(null === s)
					return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
				var l = i.attributes.position;
				l.isInterleavedBufferAttribute ? (o = l.data.count,
						s.drawArraysInstancedANGLE(a, 0, o, i.maxInstancedCount)) : s.drawArraysInstancedANGLE(a, r, o, i.maxInstancedCount),
					n.calls++,
					n.vertices += o * i.maxInstancedCount,
					a === t.TRIANGLES && (n.faces += i.maxInstancedCount * o / 3)
			}
			var a;
			this.setMode = i,
				this.render = r,
				this.renderInstances = o
		}

		function Vt(t, e, n) {
			function i(t) {
				var r = t.target,
					o = s[r.id];
				null !== o.index && e.remove(o.index);
				for(var a in o.attributes)
					e.remove(o.attributes[a]);
				r.removeEventListener("dispose", i),
					delete s[r.id];
				var c = l[r.id];
				c && (e.remove(c),
						delete l[r.id]),
					c = l[o.id],
					c && (e.remove(c),
						delete l[o.id]),
					n.geometries--
			}

			function r(t, e) {
				var r = s[e.id];
				return r ? r : (e.addEventListener("dispose", i),
					e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Xt).setFromObject(t)),
						r = e._bufferGeometry),
					s[e.id] = r,
					n.geometries++,
					r)
			}

			function o(n) {
				var i = n.index,
					r = n.attributes;
				null !== i && e.update(i, t.ELEMENT_ARRAY_BUFFER);
				for(var o in r)
					e.update(r[o], t.ARRAY_BUFFER);
				var a = n.morphAttributes;
				for(var o in a)
					for(var s = a[o], l = 0, c = s.length; l < c; l++)
						e.update(s[l], t.ARRAY_BUFFER)
			}

			function a(n) {
				var i = l[n.id];
				if(i)
					return i;
				var r = [],
					o = n.index,
					a = n.attributes;
				if(null !== o)
					for(var s = o.array, c = 0, u = s.length; c < u; c += 3) {
						var h = s[c + 0],
							d = s[c + 1],
							f = s[c + 2];
						r.push(h, d, d, f, f, h)
					}
				else
					for(var s = a.position.array, c = 0, u = s.length / 3 - 1; c < u; c += 3) {
						var h = c + 0,
							d = c + 1,
							f = c + 2;
						r.push(h, d, d, f, f, h)
					}
				return i = new(Mt(r) > 65535 ? bt : _t)(r, 1),
					e.update(i, t.ELEMENT_ARRAY_BUFFER),
					l[n.id] = i,
					i
			}
			var s = {},
				l = {};
			return {
				get: r,
				update: o,
				getWireframeAttribute: a
			}
		}

		function Gt() {
			var t = {};
			return {
				get: function(e) {
					if(void 0 !== t[e.id])
						return t[e.id];
					var i;
					switch(e.type) {
						case "DirectionalLight":
							i = {
								direction: new l,
								color: new W,
								shadow: !1,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new n
							};
							break;
						case "SpotLight":
							i = {
								position: new l,
								direction: new l,
								color: new W,
								distance: 0,
								coneCos: 0,
								penumbraCos: 0,
								decay: 0,
								shadow: !1,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new n
							};
							break;
						case "PointLight":
							i = {
								position: new l,
								color: new W,
								distance: 0,
								decay: 0,
								shadow: !1,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new n
							};
							break;
						case "HemisphereLight":
							i = {
								direction: new l,
								skyColor: new W,
								groundColor: new W
							};
							break;
						case "RectAreaLight":
							i = {
								color: new W,
								position: new l,
								halfWidth: new l,
								halfHeight: new l
							}
					}
					return t[e.id] = i,
						i
				}
			}
		}

		function Ht(t, e, n) {
			function i(t) {
				var i = n.frame,
					r = t.geometry,
					a = e.get(t, r);
				return o[a.id] !== i && (r.isGeometry && a.updateFromObject(t),
						e.update(a),
						o[a.id] = i),
					a
			}

			function r() {
				o = {}
			}
			var o = {};
			return {
				update: i,
				clear: r
			}
		}

		function Wt(t) {
			for(var e = t.split("\n"), n = 0; n < e.length; n++)
				e[n] = n + 1 + ": " + e[n];
			return e.join("\n")
		}

		function Yt(t, e, n) {
			var i = t.createShader(e);
			return t.shaderSource(i, n),
				t.compileShader(i),
				t.getShaderParameter(i, t.COMPILE_STATUS) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."),
				"" !== t.getShaderInfoLog(i) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === t.VERTEX_SHADER ? "vertex" : "fragment", t.getShaderInfoLog(i), Wt(n)),
				i
		}

		function qt(t) {
			switch(t) {
				case hs:
					return ["Linear", "( value )"];
				case ds:
					return ["sRGB", "( value )"];
				case ps:
					return ["RGBE", "( value )"];
				case vs:
					return ["RGBM", "( value, 7.0 )"];
				case gs:
					return ["RGBM", "( value, 16.0 )"];
				case _s:
					return ["RGBD", "( value, 256.0 )"];
				case fs:
					return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
				default:
					throw new Error("unsupported encoding: " + t)
			}
		}

		function Zt(t, e) {
			var n = qt(e);
			return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
		}

		function Qt(t, e) {
			var n = qt(e);
			return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
		}

		function Jt(t, e) {
			var n;
			switch(e) {
				case ia:
					n = "Linear";
					break;
				case ra:
					n = "Reinhard";
					break;
				case oa:
					n = "Uncharted2";
					break;
				case aa:
					n = "OptimizedCineon";
					break;
				default:
					throw new Error("unsupported toneMapping: " + e)
			}
			return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
		}

		function Kt(t, e, n) {
			t = t || {};
			var i = [t.derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
			return i.filter(ee).join("\n")
		}

		function $t(t) {
			var e = [];
			for(var n in t) {
				var i = t[n];
				i !== !1 && e.push("#define " + n + " " + i)
			}
			return e.join("\n")
		}

		function te(t, e, n) {
			for(var i = {}, r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), o = 0; o < r; o++) {
				var a = t.getActiveAttrib(e, o),
					s = a.name;
				i[s] = t.getAttribLocation(e, s)
			}
			return i
		}

		function ee(t) {
			return "" !== t
		}

		function ne(t, e) {
			return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
		}

		function ie(t) {
			function e(t, e) {
				var n = Dc[e];
				if(void 0 === n)
					throw new Error("Can not resolve #include <" + e + ">");
				return ie(n)
			}
			var n = /^[ \t]*#include +<([\w\d.]+)>/gm;
			return t.replace(n, e)
		}

		function re(t) {
			function e(t, e, n, i) {
				for(var r = "", o = parseInt(e); o < parseInt(n); o++)
					r += i.replace(/\[ i \]/g, "[ " + o + " ]");
				return r
			}
			var n = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
			return t.replace(n, e)
		}

		function oe(t, e, n, i) {
			var r = t.context,
				o = n.extensions,
				a = n.defines,
				s = n.__webglShader.vertexShader,
				l = n.__webglShader.fragmentShader,
				c = "SHADOWMAP_TYPE_BASIC";
			i.shadowMapType === fo ? c = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === po && (c = "SHADOWMAP_TYPE_PCF_SOFT");
			var u = "ENVMAP_TYPE_CUBE",
				h = "ENVMAP_MODE_REFLECTION",
				d = "ENVMAP_BLENDING_MULTIPLY";
			if(i.envMap) {
				switch(n.envMap.mapping) {
					case la:
					case ca:
						u = "ENVMAP_TYPE_CUBE";
						break;
					case fa:
					case pa:
						u = "ENVMAP_TYPE_CUBE_UV";
						break;
					case ua:
					case ha:
						u = "ENVMAP_TYPE_EQUIREC";
						break;
					case da:
						u = "ENVMAP_TYPE_SPHERE"
				}
				switch(n.envMap.mapping) {
					case ca:
					case ha:
						h = "ENVMAP_MODE_REFRACTION"
				}
				switch(n.combine) {
					case $o:
						d = "ENVMAP_BLENDING_MULTIPLY";
						break;
					case ta:
						d = "ENVMAP_BLENDING_MIX";
						break;
					case ea:
						d = "ENVMAP_BLENDING_ADD"
				}
			}
			var f, p, m = t.gammaFactor > 0 ? t.gammaFactor : 1,
				v = Kt(o, i, t.extensions),
				g = $t(a),
				_ = r.createProgram();
			n.isRawShaderMaterial ? (f = [g, "\n"].filter(ee).join("\n"),
					p = [v, g, "\n"].filter(ee).join("\n")) : (f = ["precision " + i.precision + " float;", "precision " + i.precision + " int;", "#define SHADER_NAME " + n.__webglShader.name, g, i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + m, "#define MAX_BONES " + i.maxBones, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + h : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.vertexColors ? "#define USE_COLOR" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.useVertexTexture ? "#define BONE_TEXTURE" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && i.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + i.numClippingPlanes, i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + c : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && t.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ee).join("\n"),
					p = [v, "precision " + i.precision + " float;", "precision " + i.precision + " int;", "#define SHADER_NAME " + n.__webglShader.name, g, i.alphaTest ? "#define ALPHATEST " + i.alphaTest : "", "#define GAMMA_FACTOR " + m, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + u : "", i.envMap ? "#define " + h : "", i.envMap ? "#define " + d : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.vertexColors ? "#define USE_COLOR" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + i.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (i.numClippingPlanes - i.numClipIntersection), i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + c : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && t.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", i.envMap && t.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", i.toneMapping !== na ? "#define TONE_MAPPING" : "", i.toneMapping !== na ? Dc.tonemapping_pars_fragment : "", i.toneMapping !== na ? Jt("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", i.outputEncoding || i.mapEncoding || i.envMapEncoding || i.emissiveMapEncoding ? Dc.encodings_pars_fragment : "", i.mapEncoding ? Zt("mapTexelToLinear", i.mapEncoding) : "", i.envMapEncoding ? Zt("envMapTexelToLinear", i.envMapEncoding) : "", i.emissiveMapEncoding ? Zt("emissiveMapTexelToLinear", i.emissiveMapEncoding) : "", i.outputEncoding ? Qt("linearToOutputTexel", i.outputEncoding) : "", i.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(ee).join("\n")),
				s = ie(s, i),
				s = ne(s, i),
				l = ie(l, i),
				l = ne(l, i),
				n.isShaderMaterial || (s = re(s),
					l = re(l));
			var y = f + s,
				b = p + l,
				x = Yt(r, r.VERTEX_SHADER, y),
				w = Yt(r, r.FRAGMENT_SHADER, b);
			r.attachShader(_, x),
				r.attachShader(_, w),
				void 0 !== n.index0AttributeName ? r.bindAttribLocation(_, 0, n.index0AttributeName) : i.morphTargets === !0 && r.bindAttribLocation(_, 0, "position"),
				r.linkProgram(_);
			var T = r.getProgramInfoLog(_),
				M = r.getShaderInfoLog(x),
				E = r.getShaderInfoLog(w),
				S = !0,
				X = !0;
			r.getProgramParameter(_, r.LINK_STATUS) === !1 ? (S = !1,
					console.error("THREE.WebGLProgram: shader error: ", r.getError(), "gl.VALIDATE_STATUS", r.getProgramParameter(_, r.VALIDATE_STATUS), "gl.getProgramInfoLog", T, M, E)) : "" !== T ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", T) : "" !== M && "" !== E || (X = !1),
				X && (this.diagnostics = {
					runnable: S,
					material: n,
					programLog: T,
					vertexShader: {
						log: M,
						prefix: f
					},
					fragmentShader: {
						log: E,
						prefix: p
					}
				}),
				r.deleteShader(x),
				r.deleteShader(w);
			var A;
			this.getUniforms = function() {
				return void 0 === A && (A = new H(r, _, t)),
					A
			};
			var P;
			return this.getAttributes = function() {
					return void 0 === P && (P = te(r, _)),
						P
				},
				this.destroy = function() {
					r.deleteProgram(_),
						this.program = void 0
				},
				Object.defineProperties(this, {
					uniforms: {
						get: function() {
							return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."),
								this.getUniforms()
						}
					},
					attributes: {
						get: function() {
							return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."),
								this.getAttributes()
						}
					}
				}),
				this.id = kc++,
				this.code = e,
				this.usedTimes = 1,
				this.program = _,
				this.vertexShader = x,
				this.fragmentShader = w,
				this
		}

		function ae(t, e) {
			function n(t) {
				var n = t.skeleton,
					i = n.bones;
				if(e.floatVertexTextures)
					return 1024;
				var r = e.maxVertexUniforms,
					o = Math.floor((r - 20) / 4),
					a = Math.min(o, i.length);
				return a < i.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + i.length + " bones. This GPU supports " + a + "."),
					0) : a
			}

			function i(t, e) {
				var n;
				return t ? t.isTexture ? n = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
						n = t.texture.encoding) : n = hs,
					n === hs && e && (n = fs),
					n
			}
			var r = [],
				o = {
					MeshDepthMaterial: "depth",
					MeshNormalMaterial: "normal",
					MeshBasicMaterial: "basic",
					MeshLambertMaterial: "lambert",
					MeshPhongMaterial: "phong",
					MeshToonMaterial: "phong",
					MeshStandardMaterial: "physical",
					MeshPhysicalMaterial: "physical",
					LineBasicMaterial: "basic",
					LineDashedMaterial: "dashed",
					PointsMaterial: "points"
				},
				a = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];
			this.getParameters = function(r, a, s, l, c, u) {
					var h = o[r.type],
						d = u.isSkinnedMesh ? n(u) : 0,
						f = t.getPrecision();
					null !== r.precision && (f = e.getMaxPrecision(r.precision),
						f !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", f, "instead."));
					var p = t.getRenderTarget(),
						m = {
							shaderID: h,
							precision: f,
							supportsVertexTextures: e.vertexTextures,
							outputEncoding: i(p ? p.texture : null, t.gammaOutput),
							map: !!r.map,
							mapEncoding: i(r.map, t.gammaInput),
							envMap: !!r.envMap,
							envMapMode: r.envMap && r.envMap.mapping,
							envMapEncoding: i(r.envMap, t.gammaInput),
							envMapCubeUV: !!r.envMap && (r.envMap.mapping === fa || r.envMap.mapping === pa),
							lightMap: !!r.lightMap,
							aoMap: !!r.aoMap,
							emissiveMap: !!r.emissiveMap,
							emissiveMapEncoding: i(r.emissiveMap, t.gammaInput),
							bumpMap: !!r.bumpMap,
							normalMap: !!r.normalMap,
							displacementMap: !!r.displacementMap,
							roughnessMap: !!r.roughnessMap,
							metalnessMap: !!r.metalnessMap,
							specularMap: !!r.specularMap,
							alphaMap: !!r.alphaMap,
							gradientMap: !!r.gradientMap,
							combine: r.combine,
							vertexColors: r.vertexColors,
							fog: !!s,
							useFog: r.fog,
							fogExp: s && s.isFogExp2,
							flatShading: r.shading === _o,
							sizeAttenuation: r.sizeAttenuation,
							logarithmicDepthBuffer: e.logarithmicDepthBuffer,
							skinning: r.skinning && d > 0,
							maxBones: d,
							useVertexTexture: e.floatVertexTextures,
							morphTargets: r.morphTargets,
							morphNormals: r.morphNormals,
							maxMorphTargets: t.maxMorphTargets,
							maxMorphNormals: t.maxMorphNormals,
							numDirLights: a.directional.length,
							numPointLights: a.point.length,
							numSpotLights: a.spot.length,
							numRectAreaLights: a.rectArea.length,
							numHemiLights: a.hemi.length,
							numClippingPlanes: l,
							numClipIntersection: c,
							dithering: r.dithering,
							shadowMapEnabled: t.shadowMap.enabled && u.receiveShadow && a.shadows.length > 0,
							shadowMapType: t.shadowMap.type,
							toneMapping: t.toneMapping,
							physicallyCorrectLights: t.physicallyCorrectLights,
							premultipliedAlpha: r.premultipliedAlpha,
							alphaTest: r.alphaTest,
							doubleSided: r.side === go,
							flipSided: r.side === vo,
							depthPacking: void 0 !== r.depthPacking && r.depthPacking
						};
					return m
				},
				this.getProgramCode = function(t, e) {
					var n = [];
					if(e.shaderID ? n.push(e.shaderID) : (n.push(t.fragmentShader),
							n.push(t.vertexShader)),
						void 0 !== t.defines)
						for(var i in t.defines)
							n.push(i),
							n.push(t.defines[i]);
					for(var r = 0; r < a.length; r++)
						n.push(e[a[r]]);
					return n.join()
				},
				this.acquireProgram = function(e, n, i) {
					for(var o, a = 0, s = r.length; a < s; a++) {
						var l = r[a];
						if(l.code === i) {
							o = l,
								++o.usedTimes;
							break
						}
					}
					return void 0 === o && (o = new oe(t, i, e, n),
							r.push(o)),
						o
				},
				this.releaseProgram = function(t) {
					if(0 === --t.usedTimes) {
						var e = r.indexOf(t);
						r[e] = r[r.length - 1],
							r.pop(),
							t.destroy()
					}
				},
				this.programs = r
		}

		function se(t, e, n, i, r, o, a) {
			function s(t, e) {
				if(t.width > e || t.height > e) {
					var n = e / Math.max(t.width, t.height),
						i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
					i.width = Math.floor(t.width * n),
						i.height = Math.floor(t.height * n);
					var r = i.getContext("2d");
					return r.drawImage(t, 0, 0, t.width, t.height, 0, 0, i.width, i.height),
						console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + i.width + "x" + i.height, t),
						i
				}
				return t
			}

			function l(t) {
				return xs.isPowerOfTwo(t.width) && xs.isPowerOfTwo(t.height)
			}

			function c(t) {
				if(t instanceof HTMLImageElement || t instanceof HTMLCanvasElement) {
					var e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
					e.width = xs.nearestPowerOfTwo(t.width),
						e.height = xs.nearestPowerOfTwo(t.height);
					var n = e.getContext("2d");
					return n.drawImage(t, 0, 0, e.width, e.height),
						console.warn("THREE.WebGLRenderer: image is not power of two (" + t.width + "x" + t.height + "). Resized to " + e.width + "x" + e.height, t),
						e
				}
				return t
			}

			function u(t) {
				return t.wrapS !== va || t.wrapT !== va || t.minFilter !== _a && t.minFilter !== xa
			}

			function h(e) {
				return e === _a || e === ya || e === ba ? t.NEAREST : t.LINEAR
			}

			function d(t) {
				var e = t.target;
				e.removeEventListener("dispose", d),
					p(e),
					a.textures--
			}

			function f(t) {
				var e = t.target;
				e.removeEventListener("dispose", f),
					m(e),
					a.textures--
			}

			function p(e) {
				var n = i.get(e);
				if(e.image && n.__image__webglTextureCube)
					t.deleteTexture(n.__image__webglTextureCube);
				else {
					if(void 0 === n.__webglInit)
						return;
					t.deleteTexture(n.__webglTexture)
				}
				i.remove(e)
			}

			function m(e) {
				var n = i.get(e),
					r = i.get(e.texture);
				if(e) {
					if(void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture),
						e.depthTexture && e.depthTexture.dispose(),
						e.isWebGLRenderTargetCube)
						for(var o = 0; o < 6; o++)
							t.deleteFramebuffer(n.__webglFramebuffer[o]),
							n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[o]);
					else
						t.deleteFramebuffer(n.__webglFramebuffer),
						n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer);
					i.remove(e.texture),
						i.remove(e)
				}
			}

			function v(e, r) {
				var o = i.get(e);
				if(e.version > 0 && o.__version !== e.version) {
					var a = e.image;
					if(void 0 === a)
						console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", e);
					else {
						if(a.complete !== !1)
							return void b(o, e, r);
						console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", e)
					}
				}
				n.activeTexture(t.TEXTURE0 + r),
					n.bindTexture(t.TEXTURE_2D, o.__webglTexture)
			}

			function g(e, c) {
				var u = i.get(e);
				if(6 === e.image.length)
					if(e.version > 0 && u.__version !== e.version) {
						u.__image__webglTextureCube || (e.addEventListener("dispose", d),
								u.__image__webglTextureCube = t.createTexture(),
								a.textures++),
							n.activeTexture(t.TEXTURE0 + c),
							n.bindTexture(t.TEXTURE_CUBE_MAP, u.__image__webglTextureCube),
							t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
						for(var h = e && e.isCompressedTexture, f = e.image[0] && e.image[0].isDataTexture, p = [], m = 0; m < 6; m++)
							h || f ? p[m] = f ? e.image[m].image : e.image[m] : p[m] = s(e.image[m], r.maxCubemapSize);
						var v = p[0],
							g = l(v),
							_ = o(e.format),
							b = o(e.type);
						y(t.TEXTURE_CUBE_MAP, e, g);
						for(var m = 0; m < 6; m++)
							if(h)
								for(var x, w = p[m].mipmaps, T = 0, M = w.length; T < M; T++)
									x = w[T],
									e.format !== za && e.format !== Fa ? n.getCompressedTextureFormats().indexOf(_) > -1 ? n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + m, T, _, x.width, x.height, 0, x.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + m, T, _, x.width, x.height, 0, _, b, x.data);
							else
								f ? n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + m, 0, _, p[m].width, p[m].height, 0, _, b, p[m].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + m, 0, _, _, b, p[m]);
						e.generateMipmaps && g && t.generateMipmap(t.TEXTURE_CUBE_MAP),
							u.__version = e.version,
							e.onUpdate && e.onUpdate(e)
					} else
						n.activeTexture(t.TEXTURE0 + c),
						n.bindTexture(t.TEXTURE_CUBE_MAP, u.__image__webglTextureCube)
			}

			function _(e, r) {
				n.activeTexture(t.TEXTURE0 + r),
					n.bindTexture(t.TEXTURE_CUBE_MAP, i.get(e).__webglTexture)
			}

			function y(n, a, s) {
				var l;
				if(s ? (t.texParameteri(n, t.TEXTURE_WRAP_S, o(a.wrapS)),
						t.texParameteri(n, t.TEXTURE_WRAP_T, o(a.wrapT)),
						t.texParameteri(n, t.TEXTURE_MAG_FILTER, o(a.magFilter)),
						t.texParameteri(n, t.TEXTURE_MIN_FILTER, o(a.minFilter))) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
						t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
						a.wrapS === va && a.wrapT === va || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", a),
						t.texParameteri(n, t.TEXTURE_MAG_FILTER, h(a.magFilter)),
						t.texParameteri(n, t.TEXTURE_MIN_FILTER, h(a.minFilter)),
						a.minFilter !== _a && a.minFilter !== xa && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", a)),
					l = e.get("EXT_texture_filter_anisotropic")) {
					if(a.type === Ra && null === e.get("OES_texture_float_linear"))
						return;
					if(a.type === Oa && null === e.get("OES_texture_half_float_linear"))
						return;
					(a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (t.texParameterf(n, l.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())),
						i.get(a).__currentAnisotropy = a.anisotropy)
				}
			}

			function b(e, i, h) {
				void 0 === e.__webglInit && (e.__webglInit = !0,
						i.addEventListener("dispose", d),
						e.__webglTexture = t.createTexture(),
						a.textures++),
					n.activeTexture(t.TEXTURE0 + h),
					n.bindTexture(t.TEXTURE_2D, e.__webglTexture),
					t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY),
					t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha),
					t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment);
				var f = s(i.image, r.maxTextureSize);
				u(i) && l(f) === !1 && (f = c(f));
				var p = l(f),
					m = o(i.format),
					v = o(i.type);
				y(t.TEXTURE_2D, i, p);
				var g, _ = i.mipmaps;
				if(i.isDepthTexture) {
					var b = t.DEPTH_COMPONENT;
					if(i.type === Ra) {
						if(!X)
							throw new Error("Float Depth Texture only supported in WebGL2.0");
						b = t.DEPTH_COMPONENT32F
					} else
						X && (b = t.DEPTH_COMPONENT16);
					i.format === ja && b === t.DEPTH_COMPONENT && i.type !== Xa && i.type !== Pa && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
							i.type = Xa,
							v = o(i.type)),
						i.format === Va && (b = t.DEPTH_STENCIL,
							i.type !== Da && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
								i.type = Da,
								v = o(i.type))),
						n.texImage2D(t.TEXTURE_2D, 0, b, f.width, f.height, 0, m, v, null)
				} else if(i.isDataTexture)
					if(_.length > 0 && p) {
						for(var x = 0, w = _.length; x < w; x++)
							g = _[x],
							n.texImage2D(t.TEXTURE_2D, x, m, g.width, g.height, 0, m, v, g.data);
						i.generateMipmaps = !1
					} else
						n.texImage2D(t.TEXTURE_2D, 0, m, f.width, f.height, 0, m, v, f.data);
				else if(i.isCompressedTexture)
					for(var x = 0, w = _.length; x < w; x++)
						g = _[x],
						i.format !== za && i.format !== Fa ? n.getCompressedTextureFormats().indexOf(m) > -1 ? n.compressedTexImage2D(t.TEXTURE_2D, x, m, g.width, g.height, 0, g.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(t.TEXTURE_2D, x, m, g.width, g.height, 0, m, v, g.data);
				else if(_.length > 0 && p) {
					for(var x = 0, w = _.length; x < w; x++)
						g = _[x],
						n.texImage2D(t.TEXTURE_2D, x, m, m, v, g);
					i.generateMipmaps = !1
				} else
					n.texImage2D(t.TEXTURE_2D, 0, m, m, v, f);
				i.generateMipmaps && p && t.generateMipmap(t.TEXTURE_2D),
					e.__version = i.version,
					i.onUpdate && i.onUpdate(i)
			}

			function x(e, r, a, s) {
				var l = o(r.texture.format),
					c = o(r.texture.type);
				n.texImage2D(s, 0, l, r.width, r.height, 0, l, c, null),
					t.bindFramebuffer(t.FRAMEBUFFER, e),
					t.framebufferTexture2D(t.FRAMEBUFFER, a, s, i.get(r.texture).__webglTexture, 0),
					t.bindFramebuffer(t.FRAMEBUFFER, null)
			}

			function w(e, n) {
				t.bindRenderbuffer(t.RENDERBUFFER, e),
					n.depthBuffer && !n.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, n.width, n.height),
						t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)) : n.depthBuffer && n.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height),
						t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)) : t.renderbufferStorage(t.RENDERBUFFER, t.RGBA4, n.width, n.height),
					t.bindRenderbuffer(t.RENDERBUFFER, null)
			}

			function T(e, n) {
				var r = n && n.isWebGLRenderTargetCube;
				if(r)
					throw new Error("Depth Texture with cube render targets is not supported!");
				if(t.bindFramebuffer(t.FRAMEBUFFER, e), !n.depthTexture || !n.depthTexture.isDepthTexture)
					throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
				i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width,
						n.depthTexture.image.height = n.height,
						n.depthTexture.needsUpdate = !0),
					v(n.depthTexture, 0);
				var o = i.get(n.depthTexture).__webglTexture;
				if(n.depthTexture.format === ja)
					t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, o, 0);
				else {
					if(n.depthTexture.format !== Va)
						throw new Error("Unknown depthTexture format");
					t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, o, 0)
				}
			}

			function M(e) {
				var n = i.get(e),
					r = e.isWebGLRenderTargetCube === !0;
				if(e.depthTexture) {
					if(r)
						throw new Error("target.depthTexture not supported in Cube render targets");
					T(n.__webglFramebuffer, e)
				} else if(r) {
					n.__webglDepthbuffer = [];
					for(var o = 0; o < 6; o++)
						t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer[o]),
						n.__webglDepthbuffer[o] = t.createRenderbuffer(),
						w(n.__webglDepthbuffer[o], e)
				} else
					t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer),
					n.__webglDepthbuffer = t.createRenderbuffer(),
					w(n.__webglDepthbuffer, e);
				t.bindFramebuffer(t.FRAMEBUFFER, null)
			}

			function E(e) {
				var r = i.get(e),
					o = i.get(e.texture);
				e.addEventListener("dispose", f),
					o.__webglTexture = t.createTexture(),
					a.textures++;
				var s = e.isWebGLRenderTargetCube === !0,
					c = l(e);
				if(s) {
					r.__webglFramebuffer = [];
					for(var u = 0; u < 6; u++)
						r.__webglFramebuffer[u] = t.createFramebuffer()
				} else
					r.__webglFramebuffer = t.createFramebuffer();
				if(s) {
					n.bindTexture(t.TEXTURE_CUBE_MAP, o.__webglTexture),
						y(t.TEXTURE_CUBE_MAP, e.texture, c);
					for(var u = 0; u < 6; u++)
						x(r.__webglFramebuffer[u], e, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + u);
					e.texture.generateMipmaps && c && t.generateMipmap(t.TEXTURE_CUBE_MAP),
						n.bindTexture(t.TEXTURE_CUBE_MAP, null)
				} else
					n.bindTexture(t.TEXTURE_2D, o.__webglTexture),
					y(t.TEXTURE_2D, e.texture, c),
					x(r.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D),
					e.texture.generateMipmaps && c && t.generateMipmap(t.TEXTURE_2D),
					n.bindTexture(t.TEXTURE_2D, null);
				e.depthBuffer && M(e)
			}

			function S(e) {
				var r = e.texture;
				if(r.generateMipmaps && l(e) && r.minFilter !== _a && r.minFilter !== xa) {
					var o = e && e.isWebGLRenderTargetCube ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
						a = i.get(r).__webglTexture;
					n.bindTexture(o, a),
						t.generateMipmap(o),
						n.bindTexture(o, null)
				}
			}
			var X = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext;
			this.setTexture2D = v,
				this.setTextureCube = g,
				this.setTextureCubeDynamic = _,
				this.setupRenderTarget = E,
				this.updateRenderTargetMipmap = S
		}

		function le() {
			function t(t) {
				var e = t.uuid,
					n = i[e];
				return void 0 === n && (n = {},
						i[e] = n),
					n
			}

			function e(t) {
				delete i[t.uuid]
			}

			function n() {
				i = {}
			}
			var i = {};
			return {
				get: t,
				remove: e,
				clear: n
			}
		}

		function ce(t, e, n) {
			function i() {
				var e = !1,
					n = new r,
					i = null,
					o = new r;
				return {
					setMask: function(n) {
						i === n || e || (t.colorMask(n, n, n, n),
							i = n)
					},
					setLocked: function(t) {
						e = t
					},
					setClear: function(e, i, r, a, s) {
						s === !0 && (e *= a,
								i *= a,
								r *= a),
							n.set(e, i, r, a),
							o.equals(n) === !1 && (t.clearColor(e, i, r, a),
								o.copy(n))
					},
					reset: function() {
						e = !1,
							i = null,
							o.set(0, 0, 0, 1)
					}
				}
			}

			function o() {
				var e = !1,
					n = null,
					i = null,
					r = null;
				return {
					setTest: function(e) {
						e ? f(t.DEPTH_TEST) : p(t.DEPTH_TEST)
					},
					setMask: function(i) {
						n === i || e || (t.depthMask(i),
							n = i)
					},
					setFunc: function(e) {
						if(i !== e) {
							if(e)
								switch(e) {
									case Ho:
										t.depthFunc(t.NEVER);
										break;
									case Wo:
										t.depthFunc(t.ALWAYS);
										break;
									case Yo:
										t.depthFunc(t.LESS);
										break;
									case qo:
										t.depthFunc(t.LEQUAL);
										break;
									case Zo:
										t.depthFunc(t.EQUAL);
										break;
									case Qo:
										t.depthFunc(t.GEQUAL);
										break;
									case Jo:
										t.depthFunc(t.GREATER);
										break;
									case Ko:
										t.depthFunc(t.NOTEQUAL);
										break;
									default:
										t.depthFunc(t.LEQUAL)
								}
							else
								t.depthFunc(t.LEQUAL);
							i = e
						}
					},
					setLocked: function(t) {
						e = t
					},
					setClear: function(e) {
						r !== e && (t.clearDepth(e),
							r = e)
					},
					reset: function() {
						e = !1,
							n = null,
							i = null,
							r = null
					}
				}
			}

			function a() {
				var e = !1,
					n = null,
					i = null,
					r = null,
					o = null,
					a = null,
					s = null,
					l = null,
					c = null;
				return {
					setTest: function(e) {
						e ? f(t.STENCIL_TEST) : p(t.STENCIL_TEST)
					},
					setMask: function(i) {
						n === i || e || (t.stencilMask(i),
							n = i)
					},
					setFunc: function(e, n, a) {
						i === e && r === n && o === a || (t.stencilFunc(e, n, a),
							i = e,
							r = n,
							o = a)
					},
					setOp: function(e, n, i) {
						a === e && s === n && l === i || (t.stencilOp(e, n, i),
							a = e,
							s = n,
							l = i)
					},
					setLocked: function(t) {
						e = t
					},
					setClear: function(e) {
						c !== e && (t.clearStencil(e),
							c = e)
					},
					reset: function() {
						e = !1,
							n = null,
							i = null,
							r = null,
							o = null,
							a = null,
							s = null,
							l = null,
							c = null
					}
				}
			}

			function s(e, n, i) {
				var r = new Uint8Array(4),
					o = t.createTexture();
				t.bindTexture(e, o),
					t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
					t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
				for(var a = 0; a < i; a++)
					t.texImage2D(n + a, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
				return o
			}

			function l() {
				O.setClear(0, 0, 0, 1),
					C.setClear(1),
					L.setClear(0),
					f(t.DEPTH_TEST),
					C.setFunc(qo),
					_(!1),
					y(ao),
					f(t.CULL_FACE),
					f(t.BLEND),
					v(Mo)
			}

			function c() {
				for(var t = 0, e = D.length; t < e; t++)
					D[t] = 0
			}

			function u(n) {
				if(D[n] = 1,
					0 === B[n] && (t.enableVertexAttribArray(n),
						B[n] = 1),
					0 !== F[n]) {
					var i = e.get("ANGLE_instanced_arrays");
					i.vertexAttribDivisorANGLE(n, 0),
						F[n] = 0
				}
			}

			function h(n, i) {
				if(D[n] = 1,
					0 === B[n] && (t.enableVertexAttribArray(n),
						B[n] = 1),
					F[n] !== i) {
					var r = e.get("ANGLE_instanced_arrays");
					r.vertexAttribDivisorANGLE(n, i),
						F[n] = i
				}
			}

			function d() {
				for(var e = 0, n = B.length; e !== n; ++e)
					B[e] !== D[e] && (t.disableVertexAttribArray(e),
						B[e] = 0)
			}

			function f(e) {
				z[e] !== !0 && (t.enable(e),
					z[e] = !0)
			}

			function p(e) {
				z[e] !== !1 && (t.disable(e),
					z[e] = !1)
			}

			function m() {
				if(null === N && (N = [],
						e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1")))
					for(var n = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), i = 0; i < n.length; i++)
						N.push(n[i]);
				return N
			}

			function v(e, i, r, o, a, s, l, c) {
				e !== To ? f(t.BLEND) : p(t.BLEND),
					e === k && c === Y || (e === Eo ? c ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
							t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE)) : (t.blendEquation(t.FUNC_ADD),
							t.blendFunc(t.SRC_ALPHA, t.ONE)) : e === So ? c ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
							t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD),
							t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR)) : e === Xo ? c ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
							t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD),
							t.blendFunc(t.ZERO, t.SRC_COLOR)) : c ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
							t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
							t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)),
						k = e,
						Y = c),
					e === Ao ? (a = a || i,
						s = s || r,
						l = l || o,
						i === U && a === G || (t.blendEquationSeparate(n(i), n(a)),
							U = i,
							G = a),
						r === j && o === V && s === H && l === W || (t.blendFuncSeparate(n(r), n(o), n(s), n(l)),
							j = r,
							V = o,
							H = s,
							W = l)) : (U = null,
						j = null,
						V = null,
						G = null,
						H = null,
						W = null)
			}

			function g(e) {
				e.side === go ? p(t.CULL_FACE) : f(t.CULL_FACE),
					_(e.side === vo),
					e.transparent === !0 ? v(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha) : v(To),
					C.setFunc(e.depthFunc),
					C.setTest(e.depthTest),
					C.setMask(e.depthWrite),
					O.setMask(e.colorWrite),
					x(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
			}

			function _(e) {
				q !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW),
					q = e)
			}

			function y(e) {
				e !== oo ? (f(t.CULL_FACE),
						e !== Z && (e === ao ? t.cullFace(t.BACK) : e === so ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : p(t.CULL_FACE),
					Z = e
			}

			function b(e) {
				e !== Q && (nt && t.lineWidth(e),
					Q = e)
			}

			function x(e, n, i) {
				e ? (f(t.POLYGON_OFFSET_FILL),
					J === n && K === i || (t.polygonOffset(n, i),
						J = n,
						K = i)) : p(t.POLYGON_OFFSET_FILL)
			}

			function w() {
				return $
			}

			function T(e) {
				$ = e,
					e ? f(t.SCISSOR_TEST) : p(t.SCISSOR_TEST)
			}

			function M(e) {
				void 0 === e && (e = t.TEXTURE0 + tt - 1),
					it !== e && (t.activeTexture(e),
						it = e)
			}

			function E(e, n) {
				null === it && M();
				var i = rt[it];
				void 0 === i && (i = {
							type: void 0,
							texture: void 0
						},
						rt[it] = i),
					i.type === e && i.texture === n || (t.bindTexture(e, n || st[e]),
						i.type = e,
						i.texture = n)
			}

			function S() {
				try {
					t.compressedTexImage2D.apply(t, arguments)
				} catch(t) {
					console.error(t)
				}
			}

			function X() {
				try {
					t.texImage2D.apply(t, arguments)
				} catch(t) {
					console.error(t)
				}
			}

			function A(e) {
				ot.equals(e) === !1 && (t.scissor(e.x, e.y, e.z, e.w),
					ot.copy(e))
			}

			function P(e) {
				at.equals(e) === !1 && (t.viewport(e.x, e.y, e.z, e.w),
					at.copy(e))
			}

			function R() {
				for(var e = 0; e < B.length; e++)
					1 === B[e] && (t.disableVertexAttribArray(e),
						B[e] = 0);
				z = {},
					N = null,
					it = null,
					rt = {},
					k = null,
					q = null,
					Z = null,
					O.reset(),
					C.reset(),
					L.reset()
			}
			var O = new i,
				C = new o,
				L = new a,
				I = t.getParameter(t.MAX_VERTEX_ATTRIBS),
				D = new Uint8Array(I),
				B = new Uint8Array(I),
				F = new Uint8Array(I),
				z = {},
				N = null,
				k = null,
				U = null,
				j = null,
				V = null,
				G = null,
				H = null,
				W = null,
				Y = !1,
				q = null,
				Z = null,
				Q = null,
				J = null,
				K = null,
				$ = null,
				tt = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
				et = parseFloat(/^WebGL\ ([0-9])/.exec(t.getParameter(t.VERSION))[1]),
				nt = parseFloat(et) >= 1,
				it = null,
				rt = {},
				ot = new r,
				at = new r,
				st = {};
			return st[t.TEXTURE_2D] = s(t.TEXTURE_2D, t.TEXTURE_2D, 1),
				st[t.TEXTURE_CUBE_MAP] = s(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), {
					buffers: {
						color: O,
						depth: C,
						stencil: L
					},
					init: l,
					initAttributes: c,
					enableAttribute: u,
					enableAttributeAndDivisor: h,
					disableUnusedAttributes: d,
					enable: f,
					disable: p,
					getCompressedTextureFormats: m,
					setBlending: v,
					setMaterial: g,
					setFlipSided: _,
					setCullFace: y,
					setLineWidth: b,
					setPolygonOffset: x,
					getScissorTest: w,
					setScissorTest: T,
					activeTexture: M,
					bindTexture: E,
					compressedTexImage2D: S,
					texImage2D: X,
					scissor: A,
					viewport: P,
					reset: R
				}
		}

		function ue(t, e, n) {
			function i() {
				if(void 0 !== o)
					return o;
				var n = e.get("EXT_texture_filter_anisotropic");
				return o = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
			}

			function r(e) {
				if("highp" === e) {
					if(t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0)
						return "highp";
					e = "mediump"
				}
				return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
			}
			var o, a = void 0 !== n.precision ? n.precision : "highp",
				s = r(a);
			s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."),
				a = s);
			var l = n.logarithmicDepthBuffer === !0 && !!e.get("EXT_frag_depth"),
				c = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
				u = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
				h = t.getParameter(t.MAX_TEXTURE_SIZE),
				d = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
				f = t.getParameter(t.MAX_VERTEX_ATTRIBS),
				p = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
				m = t.getParameter(t.MAX_VARYING_VECTORS),
				v = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
				g = u > 0,
				_ = !!e.get("OES_texture_float"),
				y = g && _;
			return {
				getMaxAnisotropy: i,
				getMaxPrecision: r,
				precision: a,
				logarithmicDepthBuffer: l,
				maxTextures: c,
				maxVertexTextures: u,
				maxTextureSize: h,
				maxCubemapSize: d,
				maxAttributes: f,
				maxVertexUniforms: p,
				maxVaryings: m,
				maxFragmentUniforms: v,
				vertexTextures: g,
				floatFragmentTextures: _,
				floatVertexTextures: y
			}
		}

		function he(t) {
			var e = {};
			return {
				get: function(n) {
					if(void 0 !== e[n])
						return e[n];
					var i;
					switch(n) {
						case "WEBGL_depth_texture":
							i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
							break;
						case "EXT_texture_filter_anisotropic":
							i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
							break;
						case "WEBGL_compressed_texture_s3tc":
							i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
							break;
						case "WEBGL_compressed_texture_pvrtc":
							i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
							break;
						case "WEBGL_compressed_texture_etc1":
							i = t.getExtension("WEBGL_compressed_texture_etc1");
							break;
						default:
							i = t.getExtension(n)
					}
					return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."),
						e[n] = i,
						i
				}
			}
		}

		function de() {
			function t() {
				c.value !== i && (c.value = i,
						c.needsUpdate = r > 0),
					n.numPlanes = r,
					n.numIntersection = 0
			}

			function e(t, e, i, r) {
				var o = null !== t ? t.length : 0,
					a = null;
				if(0 !== o) {
					if(a = c.value,
						r !== !0 || null === a) {
						var u = i + 4 * o,
							h = e.matrixWorldInverse;
						l.getNormalMatrix(h),
							(null === a || a.length < u) && (a = new Float32Array(u));
						for(var d = 0, f = i; d !== o; ++d,
							f += 4)
							s.copy(t[d]).applyMatrix4(h, l),
							s.normal.toArray(a, f),
							a[f + 3] = s.constant
					}
					c.value = a,
						c.needsUpdate = !0
				}
				return n.numPlanes = o,
					a
			}
			var n = this,
				i = null,
				r = 0,
				o = !1,
				a = !1,
				s = new nt,
				l = new et,
				c = {
					value: null,
					needsUpdate: !1
				};
			this.uniform = c,
				this.numPlanes = 0,
				this.numIntersection = 0,
				this.init = function(t, n, a) {
					var s = 0 !== t.length || n || 0 !== r || o;
					return o = n,
						i = e(t, a, 0),
						r = t.length,
						s
				},
				this.beginShadows = function() {
					a = !0,
						e(null)
				},
				this.endShadows = function() {
					a = !1,
						t()
				},
				this.setState = function(n, s, l, u, h, d) {
					if(!o || null === n || 0 === n.length || a && !l)
						a ? e(null) : t();
					else {
						var f = a ? 0 : r,
							p = 4 * f,
							m = h.clippingState || null;
						c.value = m,
							m = e(n, u, p, d);
						for(var v = 0; v !== p; ++v)
							m[v] = i[v];
						h.clippingState = m,
							this.numIntersection = s ? this.numPlanes : 0,
							this.numPlanes += f
					}
				}
		}

		function fe(t) {
			function e() {
				return null === nt ? _t : 1
			}

			function n() {
				Qt.init(),
					Qt.scissor(ct.copy(yt).multiplyScalar(_t)),
					Qt.viewport(ht.copy(xt).multiplyScalar(_t)),
					Qt.buffers.color.setClear(pt.r, pt.g, pt.b, mt, j)
			}

			function i() {
				et = null,
					lt = null,
					st = "",
					at = -1,
					Qt.reset()
			}

			function o(t) {
				t.preventDefault(),
					i(),
					n(),
					Jt.clear(),
					ee.clear()
			}

			function a(t) {
				var e = t.target;
				e.removeEventListener("dispose", a),
					s(e)
			}

			function s(t) {
				h(t),
					Jt.remove(t)
			}

			function h(t) {
				var e = Jt.get(t).program;
				t.program = void 0,
					void 0 !== e && ne.releaseProgram(e)
			}

			function d(t, e, n) {
				t.render(function(t) {
					tt.renderBufferImmediate(t, e, n)
				})
			}

			function f(t, e) {
				return Math.abs(e[0]) - Math.abs(t[0])
			}

			function p(t, e, n, i) {
				if(n && n.isInstancedBufferGeometry && null === qt.get("ANGLE_instanced_arrays"))
					return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
				void 0 === i && (i = 0),
					Qt.initAttributes();
				var r = n.attributes,
					o = e.getAttributes(),
					a = t.defaultAttributeValues;
				for(var s in o) {
					var l = o[s];
					if(l >= 0) {
						var c = r[s];
						if(void 0 !== c) {
							var u = c.normalized,
								h = c.itemSize,
								d = $t.get(c),
								f = d.buffer,
								p = d.type,
								m = d.bytesPerElement;
							if(c.isInterleavedBufferAttribute) {
								var v = c.data,
									g = v.stride,
									_ = c.offset;
								v && v.isInstancedInterleavedBuffer ? (Qt.enableAttributeAndDivisor(l, v.meshPerAttribute),
										void 0 === n.maxInstancedCount && (n.maxInstancedCount = v.meshPerAttribute * v.count)) : Qt.enableAttribute(l),
									Wt.bindBuffer(Wt.ARRAY_BUFFER, f),
									Wt.vertexAttribPointer(l, h, p, u, g * m, (i * g + _) * m)
							} else
								c.isInstancedBufferAttribute ? (Qt.enableAttributeAndDivisor(l, c.meshPerAttribute),
									void 0 === n.maxInstancedCount && (n.maxInstancedCount = c.meshPerAttribute * c.count)) : Qt.enableAttribute(l),
								Wt.bindBuffer(Wt.ARRAY_BUFFER, f),
								Wt.vertexAttribPointer(l, h, p, u, 0, i * h * m)
						} else if(void 0 !== a) {
							var y = a[s];
							if(void 0 !== y)
								switch(y.length) {
									case 2:
										Wt.vertexAttrib2fv(l, y);
										break;
									case 3:
										Wt.vertexAttrib3fv(l, y);
										break;
									case 4:
										Wt.vertexAttrib4fv(l, y);
										break;
									default:
										Wt.vertexAttrib1fv(l, y)
								}
						}
					}
				}
				Qt.disableUnusedAttributes()
			}

			function m(t, e, n) {
				if(t.visible) {
					var i = t.layers.test(e.layers);
					if(i)
						if(t.isLight)
							G.push(t);
						else if(t.isSprite)
						t.frustumCulled && !wt.intersectsSprite(t) || K.push(t);
					else if(t.isLensFlare)
						$.push(t);
					else if(t.isImmediateRenderObject)
						n && Pt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(St),
						Y.push(t, null, t.material, Pt.z, null);
					else if((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || wt.intersectsObject(t))) {
						n && Pt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(St);
						var r = ee.update(t),
							o = t.material;
						if(Array.isArray(o))
							for(var a = r.groups, s = 0, l = a.length; s < l; s++) {
								var c = a[s],
									u = o[c.materialIndex];
								u && u.visible && Y.push(t, r, u, Pt.z, c)
							}
						else
							o.visible && Y.push(t, r, o, Pt.z, null)
					}
					for(var h = t.children, s = 0, l = h.length; s < l; s++)
						m(h[s], e, n)
				}
			}

			function v(t, e, n, i) {
				for(var r = 0, o = t.length; r < o; r++) {
					var a = t[r],
						s = a.object,
						l = a.geometry,
						c = void 0 === i ? a.material : i,
						u = a.group;
					if(s.onBeforeRender(tt, e, n, l, c, u),
						n.isArrayCamera && n.enabled)
						for(var h = n.cameras, d = 0, f = h.length; d < f; d++) {
							var p = h[d],
								m = p.bounds;
							tt.setViewport(m.x * vt * _t, m.y * gt * _t, m.z * vt * _t, m.w * gt * _t),
								tt.setScissor(m.x * vt * _t, m.y * gt * _t, m.z * vt * _t, m.w * gt * _t),
								tt.setScissorTest(!0),
								g(s, e, p, l, c, u)
						}
					else
						g(s, e, n, l, c, u);
					s.onAfterRender(tt, e, n, l, c, u)
				}
			}

			function g(t, e, n, i, r, o) {
				if(t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
					t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
					t.isImmediateRenderObject) {
					Qt.setMaterial(r);
					var a = y(n, e.fog, r, t);
					st = "",
						d(t, a, r)
				} else
					tt.renderBufferDirect(n, e.fog, i, r, t, o)
			}

			function _(t, e, n) {
				var i = Jt.get(t),
					r = ne.getParameters(t, Ft, e, Tt.numPlanes, Tt.numIntersection, n),
					o = ne.getProgramCode(t, r),
					s = i.program,
					l = !0;
				if(void 0 === s)
					t.addEventListener("dispose", a);
				else if(s.code !== o)
					h(t);
				else {
					if(void 0 !== r.shaderID)
						return;
					l = !1
				}
				if(l) {
					if(r.shaderID) {
						var c = Bc[r.shaderID];
						i.__webglShader = {
							name: t.type,
							uniforms: Cs.clone(c.uniforms),
							vertexShader: c.vertexShader,
							fragmentShader: c.fragmentShader
						}
					} else
						i.__webglShader = {
							name: t.type,
							uniforms: t.uniforms,
							vertexShader: t.vertexShader,
							fragmentShader: t.fragmentShader
						};
					t.__webglShader = i.__webglShader,
						s = ne.acquireProgram(t, r, o),
						i.program = s,
						t.program = s
				}
				var u = s.getAttributes();
				if(t.morphTargets) {
					t.numSupportedMorphTargets = 0;
					for(var d = 0; d < tt.maxMorphTargets; d++)
						u["morphTarget" + d] >= 0 && t.numSupportedMorphTargets++
				}
				if(t.morphNormals) {
					t.numSupportedMorphNormals = 0;
					for(var d = 0; d < tt.maxMorphNormals; d++)
						u["morphNormal" + d] >= 0 && t.numSupportedMorphNormals++
				}
				var f = i.__webglShader.uniforms;
				(t.isShaderMaterial || t.isRawShaderMaterial) && t.clipping !== !0 || (i.numClippingPlanes = Tt.numPlanes,
						i.numIntersection = Tt.numIntersection,
						f.clippingPlanes = Tt.uniform),
					i.fog = e,
					i.lightsHash = Ft.hash,
					t.lights && (f.ambientLightColor.value = Ft.ambient,
						f.directionalLights.value = Ft.directional,
						f.spotLights.value = Ft.spot,
						f.rectAreaLights.value = Ft.rectArea,
						f.pointLights.value = Ft.point,
						f.hemisphereLights.value = Ft.hemi,
						f.directionalShadowMap.value = Ft.directionalShadowMap,
						f.directionalShadowMatrix.value = Ft.directionalShadowMatrix,
						f.spotShadowMap.value = Ft.spotShadowMap,
						f.spotShadowMatrix.value = Ft.spotShadowMatrix,
						f.pointShadowMap.value = Ft.pointShadowMap,
						f.pointShadowMatrix.value = Ft.pointShadowMatrix);
				var p = i.program.getUniforms(),
					m = H.seqWithValue(p.seq, f);
				i.uniformsList = m
			}

			function y(t, e, n, i) {
				ft = 0;
				var r = Jt.get(n);
				if(Mt && (Et || t !== lt)) {
					var o = t === lt && n.id === at;
					Tt.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, r, o)
				}
				n.needsUpdate === !1 && (void 0 === r.program ? n.needsUpdate = !0 : n.fog && r.fog !== e ? n.needsUpdate = !0 : n.lights && r.lightsHash !== Ft.hash ? n.needsUpdate = !0 : void 0 === r.numClippingPlanes || r.numClippingPlanes === Tt.numPlanes && r.numIntersection === Tt.numIntersection || (n.needsUpdate = !0)),
					n.needsUpdate && (_(n, e, i),
						n.needsUpdate = !1);
				var a = !1,
					s = !1,
					l = !1,
					c = r.program,
					h = c.getUniforms(),
					d = r.__webglShader.uniforms;
				if(c.id !== et && (Wt.useProgram(c.program),
						et = c.id,
						a = !0,
						s = !0,
						l = !0),
					n.id !== at && (at = n.id,
						s = !0),
					a || t !== lt) {
					if(h.setValue(Wt, "projectionMatrix", t.projectionMatrix),
						Zt.logarithmicDepthBuffer && h.setValue(Wt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
						t !== lt && (lt = t,
							s = !0,
							l = !0),
						n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
						var f = h.map.cameraPosition;
						void 0 !== f && f.setValue(Wt, Pt.setFromMatrixPosition(t.matrixWorld))
					}
					(n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && h.setValue(Wt, "viewMatrix", t.matrixWorldInverse),
						h.setValue(Wt, "toneMappingExposure", tt.toneMappingExposure),
						h.setValue(Wt, "toneMappingWhitePoint", tt.toneMappingWhitePoint)
				}
				if(n.skinning) {
					h.setOptional(Wt, i, "bindMatrix"),
						h.setOptional(Wt, i, "bindMatrixInverse");
					var p = i.skeleton;
					if(p) {
						var m = p.bones;
						if(Zt.floatVertexTextures) {
							if(void 0 === p.boneTexture) {
								var v = Math.sqrt(4 * m.length);
								v = xs.nextPowerOfTwo(Math.ceil(v)),
									v = Math.max(v, 4);
								var g = new Float32Array(v * v * 4);
								g.set(p.boneMatrices);
								var y = new u(g, v, v, za, Ra);
								p.boneMatrices = g,
									p.boneTexture = y,
									p.boneTextureSize = v
							}
							h.setValue(Wt, "boneTexture", p.boneTexture),
								h.setValue(Wt, "boneTextureSize", p.boneTextureSize)
						} else
							h.setOptional(Wt, p, "boneMatrices")
					}
				}
				return s && (n.lights && O(d, l),
						e && n.fog && M(d, e),
						(n.isMeshBasicMaterial || n.isMeshLambertMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.isMeshNormalMaterial || n.isMeshDepthMaterial) && b(d, n),
						n.isLineBasicMaterial ? x(d, n) : n.isLineDashedMaterial ? (x(d, n),
							w(d, n)) : n.isPointsMaterial ? T(d, n) : n.isMeshLambertMaterial ? E(d, n) : n.isMeshToonMaterial ? X(d, n) : n.isMeshPhongMaterial ? S(d, n) : n.isMeshPhysicalMaterial ? P(d, n) : n.isMeshStandardMaterial ? A(d, n) : n.isMeshDepthMaterial ? n.displacementMap && (d.displacementMap.value = n.displacementMap,
							d.displacementScale.value = n.displacementScale,
							d.displacementBias.value = n.displacementBias) : n.isMeshNormalMaterial && R(d, n),
						void 0 !== d.ltcMat && (d.ltcMat.value = Os.LTC_MAT_TEXTURE),
						void 0 !== d.ltcMag && (d.ltcMag.value = Os.LTC_MAG_TEXTURE),
						H.upload(Wt, r.uniformsList, d, tt)),
					h.setValue(Wt, "modelViewMatrix", i.modelViewMatrix),
					h.setValue(Wt, "normalMatrix", i.normalMatrix),
					h.setValue(Wt, "modelMatrix", i.matrixWorld),
					c
			}

			function b(t, e) {
				t.opacity.value = e.opacity,
					t.diffuse.value = e.color,
					e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity),
					t.map.value = e.map,
					t.specularMap.value = e.specularMap,
					t.alphaMap.value = e.alphaMap,
					e.lightMap && (t.lightMap.value = e.lightMap,
						t.lightMapIntensity.value = e.lightMapIntensity),
					e.aoMap && (t.aoMap.value = e.aoMap,
						t.aoMapIntensity.value = e.aoMapIntensity);
				var n;
				if(e.map ? n = e.map : e.specularMap ? n = e.specularMap : e.displacementMap ? n = e.displacementMap : e.normalMap ? n = e.normalMap : e.bumpMap ? n = e.bumpMap : e.roughnessMap ? n = e.roughnessMap : e.metalnessMap ? n = e.metalnessMap : e.alphaMap ? n = e.alphaMap : e.emissiveMap && (n = e.emissiveMap),
					void 0 !== n) {
					n.isWebGLRenderTarget && (n = n.texture);
					var i = n.offset,
						r = n.repeat;
					t.offsetRepeat.value.set(i.x, i.y, r.x, r.y)
				}
				t.envMap.value = e.envMap,
					t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1,
					t.reflectivity.value = e.reflectivity,
					t.refractionRatio.value = e.refractionRatio
			}

			function x(t, e) {
				t.diffuse.value = e.color,
					t.opacity.value = e.opacity
			}

			function w(t, e) {
				t.dashSize.value = e.dashSize,
					t.totalSize.value = e.dashSize + e.gapSize,
					t.scale.value = e.scale
			}

			function T(t, e) {
				if(t.diffuse.value = e.color,
					t.opacity.value = e.opacity,
					t.size.value = e.size * _t,
					t.scale.value = .5 * gt,
					t.map.value = e.map,
					null !== e.map) {
					var n = e.map.offset,
						i = e.map.repeat;
					t.offsetRepeat.value.set(n.x, n.y, i.x, i.y)
				}
			}

			function M(t, e) {
				t.fogColor.value = e.color,
					e.isFog ? (t.fogNear.value = e.near,
						t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
			}

			function E(t, e) {
				e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
			}

			function S(t, e) {
				t.specular.value = e.specular,
					t.shininess.value = Math.max(e.shininess, 1e-4),
					e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
					e.bumpMap && (t.bumpMap.value = e.bumpMap,
						t.bumpScale.value = e.bumpScale),
					e.normalMap && (t.normalMap.value = e.normalMap,
						t.normalScale.value.copy(e.normalScale)),
					e.displacementMap && (t.displacementMap.value = e.displacementMap,
						t.displacementScale.value = e.displacementScale,
						t.displacementBias.value = e.displacementBias)
			}

			function X(t, e) {
				S(t, e),
					e.gradientMap && (t.gradientMap.value = e.gradientMap)
			}

			function A(t, e) {
				t.roughness.value = e.roughness,
					t.metalness.value = e.metalness,
					e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
					e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
					e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
					e.bumpMap && (t.bumpMap.value = e.bumpMap,
						t.bumpScale.value = e.bumpScale),
					e.normalMap && (t.normalMap.value = e.normalMap,
						t.normalScale.value.copy(e.normalScale)),
					e.displacementMap && (t.displacementMap.value = e.displacementMap,
						t.displacementScale.value = e.displacementScale,
						t.displacementBias.value = e.displacementBias),
					e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
			}

			function P(t, e) {
				t.clearCoat.value = e.clearCoat,
					t.clearCoatRoughness.value = e.clearCoatRoughness,
					A(t, e)
			}

			function R(t, e) {
				e.bumpMap && (t.bumpMap.value = e.bumpMap,
						t.bumpScale.value = e.bumpScale),
					e.normalMap && (t.normalMap.value = e.normalMap,
						t.normalScale.value.copy(e.normalScale)),
					e.displacementMap && (t.displacementMap.value = e.displacementMap,
						t.displacementScale.value = e.displacementScale,
						t.displacementBias.value = e.displacementBias)
			}

			function O(t, e) {
				t.ambientLightColor.needsUpdate = e,
					t.directionalLights.needsUpdate = e,
					t.pointLights.needsUpdate = e,
					t.spotLights.needsUpdate = e,
					t.rectAreaLights.needsUpdate = e,
					t.hemisphereLights.needsUpdate = e
			}

			function C(t) {
				for(var e = 0, n = 0, i = t.length; n < i; n++) {
					var r = t[n];
					r.castShadow && (Ft.shadows[e] = r,
						e++)
				}
				Ft.shadows.length = e
			}

			function L(t, e) {
				var n, i, r, o, a, s, l, c, u = 0,
					h = 0,
					d = 0,
					f = e.matrixWorldInverse,
					p = 0,
					m = 0,
					v = 0,
					g = 0,
					_ = 0;
				for(n = 0,
					i = t.length; n < i; n++)
					if(r = t[n],
						a = r.color,
						s = r.intensity,
						l = r.distance,
						c = r.shadow && r.shadow.map ? r.shadow.map.texture : null,
						r.isAmbientLight)
						u += a.r * s,
						h += a.g * s,
						d += a.b * s;
					else if(r.isDirectionalLight) {
					var y = ie.get(r);
					y.color.copy(r.color).multiplyScalar(r.intensity),
						y.direction.setFromMatrixPosition(r.matrixWorld),
						Pt.setFromMatrixPosition(r.target.matrixWorld),
						y.direction.sub(Pt),
						y.direction.transformDirection(f),
						y.shadow = r.castShadow,
						r.castShadow && (o = r.shadow,
							y.shadowBias = o.bias,
							y.shadowRadius = o.radius,
							y.shadowMapSize = o.mapSize),
						Ft.directionalShadowMap[p] = c,
						Ft.directionalShadowMatrix[p] = r.shadow.matrix,
						Ft.directional[p] = y,
						p++
				} else if(r.isSpotLight) {
					var y = ie.get(r);
					y.position.setFromMatrixPosition(r.matrixWorld),
						y.position.applyMatrix4(f),
						y.color.copy(a).multiplyScalar(s),
						y.distance = l,
						y.direction.setFromMatrixPosition(r.matrixWorld),
						Pt.setFromMatrixPosition(r.target.matrixWorld),
						y.direction.sub(Pt),
						y.direction.transformDirection(f),
						y.coneCos = Math.cos(r.angle),
						y.penumbraCos = Math.cos(r.angle * (1 - r.penumbra)),
						y.decay = 0 === r.distance ? 0 : r.decay,
						y.shadow = r.castShadow,
						r.castShadow && (o = r.shadow,
							y.shadowBias = o.bias,
							y.shadowRadius = o.radius,
							y.shadowMapSize = o.mapSize),
						Ft.spotShadowMap[v] = c,
						Ft.spotShadowMatrix[v] = r.shadow.matrix,
						Ft.spot[v] = y,
						v++
				} else if(r.isRectAreaLight) {
					var y = ie.get(r);
					y.color.copy(a).multiplyScalar(s / (r.width * r.height)),
						y.position.setFromMatrixPosition(r.matrixWorld),
						y.position.applyMatrix4(f),
						Lt.identity(),
						Ot.copy(r.matrixWorld),
						Ot.premultiply(f),
						Lt.extractRotation(Ot),
						y.halfWidth.set(.5 * r.width, 0, 0),
						y.halfHeight.set(0, .5 * r.height, 0),
						y.halfWidth.applyMatrix4(Lt),
						y.halfHeight.applyMatrix4(Lt),
						Ft.rectArea[g] = y,
						g++
				} else if(r.isPointLight) {
					var y = ie.get(r);
					y.position.setFromMatrixPosition(r.matrixWorld),
						y.position.applyMatrix4(f),
						y.color.copy(r.color).multiplyScalar(r.intensity),
						y.distance = r.distance,
						y.decay = 0 === r.distance ? 0 : r.decay,
						y.shadow = r.castShadow,
						r.castShadow && (o = r.shadow,
							y.shadowBias = o.bias,
							y.shadowRadius = o.radius,
							y.shadowMapSize = o.mapSize),
						Ft.pointShadowMap[m] = c,
						Ft.pointShadowMatrix[m] = r.shadow.matrix,
						Ft.point[m] = y,
						m++
				} else if(r.isHemisphereLight) {
					var y = ie.get(r);
					y.direction.setFromMatrixPosition(r.matrixWorld),
						y.direction.transformDirection(f),
						y.direction.normalize(),
						y.skyColor.copy(r.color).multiplyScalar(s),
						y.groundColor.copy(r.groundColor).multiplyScalar(s),
						Ft.hemi[_] = y,
						_++
				}
				Ft.ambient[0] = u,
					Ft.ambient[1] = h,
					Ft.ambient[2] = d,
					Ft.directional.length = p,
					Ft.spot.length = v,
					Ft.rectArea.length = g,
					Ft.point.length = m,
					Ft.hemi.length = _,
					Ft.hash = p + "," + m + "," + v + "," + g + "," + _ + "," + Ft.shadows.length
			}

			function I() {
				var t = ft;
				return t >= Zt.maxTextures && console.warn("WebGLRenderer: trying to use " + t + " texture units while this GPU supports only " + Zt.maxTextures),
					ft += 1,
					t
			}

			function D(t) {
				var e;
				if(t === ma)
					return Wt.REPEAT;
				if(t === va)
					return Wt.CLAMP_TO_EDGE;
				if(t === ga)
					return Wt.MIRRORED_REPEAT;
				if(t === _a)
					return Wt.NEAREST;
				if(t === ya)
					return Wt.NEAREST_MIPMAP_NEAREST;
				if(t === ba)
					return Wt.NEAREST_MIPMAP_LINEAR;
				if(t === xa)
					return Wt.LINEAR;
				if(t === wa)
					return Wt.LINEAR_MIPMAP_NEAREST;
				if(t === Ta)
					return Wt.LINEAR_MIPMAP_LINEAR;
				if(t === Ma)
					return Wt.UNSIGNED_BYTE;
				if(t === Ca)
					return Wt.UNSIGNED_SHORT_4_4_4_4;
				if(t === La)
					return Wt.UNSIGNED_SHORT_5_5_5_1;
				if(t === Ia)
					return Wt.UNSIGNED_SHORT_5_6_5;
				if(t === Ea)
					return Wt.BYTE;
				if(t === Sa)
					return Wt.SHORT;
				if(t === Xa)
					return Wt.UNSIGNED_SHORT;
				if(t === Aa)
					return Wt.INT;
				if(t === Pa)
					return Wt.UNSIGNED_INT;
				if(t === Ra)
					return Wt.FLOAT;
				if(t === Oa && (e = qt.get("OES_texture_half_float"),
						null !== e))
					return e.HALF_FLOAT_OES;
				if(t === Ba)
					return Wt.ALPHA;
				if(t === Fa)
					return Wt.RGB;
				if(t === za)
					return Wt.RGBA;
				if(t === Na)
					return Wt.LUMINANCE;
				if(t === ka)
					return Wt.LUMINANCE_ALPHA;
				if(t === ja)
					return Wt.DEPTH_COMPONENT;
				if(t === Va)
					return Wt.DEPTH_STENCIL;
				if(t === Po)
					return Wt.FUNC_ADD;
				if(t === Ro)
					return Wt.FUNC_SUBTRACT;
				if(t === Oo)
					return Wt.FUNC_REVERSE_SUBTRACT;
				if(t === Io)
					return Wt.ZERO;
				if(t === Do)
					return Wt.ONE;
				if(t === Bo)
					return Wt.SRC_COLOR;
				if(t === Fo)
					return Wt.ONE_MINUS_SRC_COLOR;
				if(t === zo)
					return Wt.SRC_ALPHA;
				if(t === No)
					return Wt.ONE_MINUS_SRC_ALPHA;
				if(t === ko)
					return Wt.DST_ALPHA;
				if(t === Uo)
					return Wt.ONE_MINUS_DST_ALPHA;
				if(t === jo)
					return Wt.DST_COLOR;
				if(t === Vo)
					return Wt.ONE_MINUS_DST_COLOR;
				if(t === Go)
					return Wt.SRC_ALPHA_SATURATE;
				if((t === Ga || t === Ha || t === Wa || t === Ya) && (e = qt.get("WEBGL_compressed_texture_s3tc"),
						null !== e)) {
					if(t === Ga)
						return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if(t === Ha)
						return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if(t === Wa)
						return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if(t === Ya)
						return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
				}
				if((t === qa || t === Za || t === Qa || t === Ja) && (e = qt.get("WEBGL_compressed_texture_pvrtc"),
						null !== e)) {
					if(t === qa)
						return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if(t === Za)
						return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if(t === Qa)
						return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if(t === Ja)
						return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
				}
				if(t === Ka && (e = qt.get("WEBGL_compressed_texture_etc1"),
						null !== e))
					return e.COMPRESSED_RGB_ETC1_WEBGL;
				if((t === Co || t === Lo) && (e = qt.get("EXT_blend_minmax"),
						null !== e)) {
					if(t === Co)
						return e.MIN_EXT;
					if(t === Lo)
						return e.MAX_EXT
				}
				return t === Da && (e = qt.get("WEBGL_depth_texture"),
					null !== e) ? e.UNSIGNED_INT_24_8_WEBGL : 0
			}
			console.log("THREE.WebGLRenderer", io),
				t = t || {};
			var B = void 0 !== t.canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
				F = void 0 !== t.context ? t.context : null,
				z = void 0 !== t.alpha && t.alpha,
				N = void 0 === t.depth || t.depth,
				k = void 0 === t.stencil || t.stencil,
				U = void 0 !== t.antialias && t.antialias,
				j = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
				V = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
				G = [],
				Y = null,
				Q = new Float32Array(8),
				K = [],
				$ = [];
			this.domElement = B,
				this.context = null,
				this.autoClear = !0,
				this.autoClearColor = !0,
				this.autoClearDepth = !0,
				this.autoClearStencil = !0,
				this.sortObjects = !0,
				this.clippingPlanes = [],
				this.localClippingEnabled = !1,
				this.gammaFactor = 2,
				this.gammaInput = !1,
				this.gammaOutput = !1,
				this.physicallyCorrectLights = !1,
				this.toneMapping = ia,
				this.toneMappingExposure = 1,
				this.toneMappingWhitePoint = 1,
				this.maxMorphTargets = 8,
				this.maxMorphNormals = 4;
			var tt = this,
				et = null,
				nt = null,
				ot = null,
				at = -1,
				st = "",
				lt = null,
				ct = new r,
				ut = null,
				ht = new r,
				ft = 0,
				pt = new W(0),
				mt = 0,
				vt = B.width,
				gt = B.height,
				_t = 1,
				yt = new r(0, 0, vt, gt),
				bt = !1,
				xt = new r(0, 0, vt, gt),
				wt = new it,
				Tt = new de,
				Mt = !1,
				Et = !1,
				St = new c,
				Pt = new l,
				Ot = new c,
				Lt = new c,
				Ft = {
					hash: "",
					ambient: [0, 0, 0],
					directional: [],
					directionalShadowMap: [],
					directionalShadowMatrix: [],
					spot: [],
					spotShadowMap: [],
					spotShadowMatrix: [],
					rectArea: [],
					point: [],
					pointShadowMap: [],
					pointShadowMatrix: [],
					hemi: [],
					shadows: []
				},
				zt = {
					geometries: 0,
					textures: 0
				},
				Nt = {
					frame: 0,
					calls: 0,
					vertices: 0,
					faces: 0,
					points: 0
				};
			this.info = {
				render: Nt,
				memory: zt,
				programs: null
			};
			var Wt;
			try {
				var Yt = {
					alpha: z,
					depth: N,
					stencil: k,
					antialias: U,
					premultipliedAlpha: j,
					preserveDrawingBuffer: V
				};
				if(Wt = F || B.getContext("webgl", Yt) || B.getContext("experimental-webgl", Yt),
					null === Wt)
					throw null !== B.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context.";
				void 0 === Wt.getShaderPrecisionFormat && (Wt.getShaderPrecisionFormat = function() {
						return {
							rangeMin: 1,
							rangeMax: 1,
							precision: 1
						}
					}),
					B.addEventListener("webglcontextlost", o, !1)
			} catch(t) {
				console.error("THREE.WebGLRenderer: " + t)
			}
			var qt = new he(Wt);
			qt.get("WEBGL_depth_texture"),
				qt.get("OES_texture_float"),
				qt.get("OES_texture_float_linear"),
				qt.get("OES_texture_half_float"),
				qt.get("OES_texture_half_float_linear"),
				qt.get("OES_standard_derivatives"),
				qt.get("ANGLE_instanced_arrays"),
				qt.get("OES_element_index_uint") && (Xt.MaxIndex = 4294967296);
			var Zt = new ue(Wt, qt, t),
				Qt = new ce(Wt, qt, D),
				Jt = new le,
				Kt = new se(Wt, qt, Qt, Jt, Zt, D, zt),
				$t = new Bt(Wt),
				te = new Vt(Wt, $t, zt),
				ee = new Ht(Wt, te, Nt),
				ne = new ae(this, Zt),
				ie = new Gt,
				re = new kt;
			this.info.programs = ne.programs;
			var oe, fe, pe, me, ve = new jt(Wt, qt, Nt),
				ge = new Ut(Wt, qt, Nt);
			n(),
				this.context = Wt,
				this.capabilities = Zt,
				this.extensions = qt,
				this.properties = Jt,
				this.state = Qt;
			var _e = new rt(this, Ft, ee, Zt);
			this.shadowMap = _e;
			var ye = new Z(this, K),
				be = new q(this, $);
			this.getContext = function() {
					return Wt
				},
				this.getContextAttributes = function() {
					return Wt.getContextAttributes()
				},
				this.forceContextLoss = function() {
					var t = qt.get("WEBGL_lose_context");
					t && t.loseContext()
				},
				this.getMaxAnisotropy = function() {
					return Zt.getMaxAnisotropy()
				},
				this.getPrecision = function() {
					return Zt.precision
				},
				this.getPixelRatio = function() {
					return _t
				},
				this.setPixelRatio = function(t) {
					void 0 !== t && (_t = t,
						this.setSize(xt.z, xt.w, !1))
				},
				this.getSize = function() {
					return {
						width: vt,
						height: gt
					}
				},
				this.setSize = function(t, e, n) {
					vt = t,
						gt = e,
						B.width = t * _t,
						B.height = e * _t,
						n !== !1 && (B.style.width = t + "px",
							B.style.height = e + "px"),
						this.setViewport(0, 0, t, e)
				},
				this.setViewport = function(t, e, n, i) {
					Qt.viewport(xt.set(t, e, n, i))
				},
				this.setScissor = function(t, e, n, i) {
					Qt.scissor(yt.set(t, e, n, i))
				},
				this.setScissorTest = function(t) {
					Qt.setScissorTest(bt = t)
				},
				this.getClearColor = function() {
					return pt
				},
				this.setClearColor = function(t, e) {
					pt.set(t),
						mt = void 0 !== e ? e : 1,
						Qt.buffers.color.setClear(pt.r, pt.g, pt.b, mt, j)
				},
				this.getClearAlpha = function() {
					return mt
				},
				this.setClearAlpha = function(t) {
					mt = t,
						Qt.buffers.color.setClear(pt.r, pt.g, pt.b, mt, j)
				},
				this.clear = function(t, e, n) {
					var i = 0;
					(void 0 === t || t) && (i |= Wt.COLOR_BUFFER_BIT),
					(void 0 === e || e) && (i |= Wt.DEPTH_BUFFER_BIT),
					(void 0 === n || n) && (i |= Wt.STENCIL_BUFFER_BIT),
					Wt.clear(i)
				},
				this.clearColor = function() {
					this.clear(!0, !1, !1)
				},
				this.clearDepth = function() {
					this.clear(!1, !0, !1)
				},
				this.clearStencil = function() {
					this.clear(!1, !1, !0)
				},
				this.clearTarget = function(t, e, n, i) {
					this.setRenderTarget(t),
						this.clear(e, n, i)
				},
				this.resetGLState = i,
				this.dispose = function() {
					B.removeEventListener("webglcontextlost", o, !1),
						re.dispose()
				},
				this.renderBufferImmediate = function(t, e, n) {
					Qt.initAttributes();
					var i = Jt.get(t);
					t.hasPositions && !i.position && (i.position = Wt.createBuffer()),
						t.hasNormals && !i.normal && (i.normal = Wt.createBuffer()),
						t.hasUvs && !i.uv && (i.uv = Wt.createBuffer()),
						t.hasColors && !i.color && (i.color = Wt.createBuffer());
					var r = e.getAttributes();
					if(t.hasPositions && (Wt.bindBuffer(Wt.ARRAY_BUFFER, i.position),
							Wt.bufferData(Wt.ARRAY_BUFFER, t.positionArray, Wt.DYNAMIC_DRAW),
							Qt.enableAttribute(r.position),
							Wt.vertexAttribPointer(r.position, 3, Wt.FLOAT, !1, 0, 0)),
						t.hasNormals) {
						if(Wt.bindBuffer(Wt.ARRAY_BUFFER, i.normal), !n.isMeshPhongMaterial && !n.isMeshStandardMaterial && !n.isMeshNormalMaterial && n.shading === _o)
							for(var o = 0, a = 3 * t.count; o < a; o += 9) {
								var s = t.normalArray,
									l = (s[o + 0] + s[o + 3] + s[o + 6]) / 3,
									c = (s[o + 1] + s[o + 4] + s[o + 7]) / 3,
									u = (s[o + 2] + s[o + 5] + s[o + 8]) / 3;
								s[o + 0] = l,
									s[o + 1] = c,
									s[o + 2] = u,
									s[o + 3] = l,
									s[o + 4] = c,
									s[o + 5] = u,
									s[o + 6] = l,
									s[o + 7] = c,
									s[o + 8] = u
							}
						Wt.bufferData(Wt.ARRAY_BUFFER, t.normalArray, Wt.DYNAMIC_DRAW),
							Qt.enableAttribute(r.normal),
							Wt.vertexAttribPointer(r.normal, 3, Wt.FLOAT, !1, 0, 0)
					}
					t.hasUvs && n.map && (Wt.bindBuffer(Wt.ARRAY_BUFFER, i.uv),
							Wt.bufferData(Wt.ARRAY_BUFFER, t.uvArray, Wt.DYNAMIC_DRAW),
							Qt.enableAttribute(r.uv),
							Wt.vertexAttribPointer($t.uv, 2, Wt.FLOAT, !1, 0, 0)),
						t.hasColors && n.vertexColors !== bo && (Wt.bindBuffer(Wt.ARRAY_BUFFER, i.color),
							Wt.bufferData(Wt.ARRAY_BUFFER, t.colorArray, Wt.DYNAMIC_DRAW),
							Qt.enableAttribute(r.color),
							Wt.vertexAttribPointer(r.color, 3, Wt.FLOAT, !1, 0, 0)),
						Qt.disableUnusedAttributes(),
						Wt.drawArrays(Wt.TRIANGLES, 0, t.count),
						t.count = 0
				},
				this.renderBufferDirect = function(t, n, i, r, o, a) {
					Qt.setMaterial(r);
					var s = y(t, n, r, o),
						l = i.id + "_" + s.id + "_" + (r.wireframe === !0),
						c = !1;
					l !== st && (st = l,
						c = !0);
					var u = o.morphTargetInfluences;
					if(void 0 !== u) {
						for(var h = [], d = 0, m = u.length; d < m; d++) {
							var v = u[d];
							h.push([v, d])
						}
						h.sort(f),
							h.length > 8 && (h.length = 8);
						for(var g = i.morphAttributes, d = 0, m = h.length; d < m; d++) {
							var v = h[d];
							if(Q[d] = v[0],
								0 !== v[0]) {
								var _ = v[1];
								r.morphTargets === !0 && g.position && i.addAttribute("morphTarget" + d, g.position[_]),
									r.morphNormals === !0 && g.normal && i.addAttribute("morphNormal" + d, g.normal[_])
							} else
								r.morphTargets === !0 && i.removeAttribute("morphTarget" + d),
								r.morphNormals === !0 && i.removeAttribute("morphNormal" + d)
						}
						for(var d = h.length, b = Q.length; d < b; d++)
							Q[d] = 0;
						s.getUniforms().setValue(Wt, "morphTargetInfluences", Q),
							c = !0
					}
					var _ = i.index,
						x = i.attributes.position,
						w = 1;
					r.wireframe === !0 && (_ = te.getWireframeAttribute(i),
						w = 2);
					var T = ve;
					null !== _ && (T = ge,
							T.setIndex(_)),
						c && (p(r, s, i),
							null !== _ && Wt.bindBuffer(Wt.ELEMENT_ARRAY_BUFFER, $t.get(_).buffer));
					var M = 0;
					null !== _ ? M = _.count : void 0 !== x && (M = x.count);
					var E = i.drawRange.start * w,
						S = i.drawRange.count * w,
						X = null !== a ? a.start * w : 0,
						A = null !== a ? a.count * w : 1 / 0,
						P = Math.max(E, X),
						R = Math.min(M, E + S, X + A) - 1,
						O = Math.max(0, R - P + 1);
					if(0 !== O) {
						if(o.isMesh)
							if(r.wireframe === !0)
								Qt.setLineWidth(r.wireframeLinewidth * e()),
								T.setMode(Wt.LINES);
							else
								switch(o.drawMode) {
									case ls:
										T.setMode(Wt.TRIANGLES);
										break;
									case cs:
										T.setMode(Wt.TRIANGLE_STRIP);
										break;
									case us:
										T.setMode(Wt.TRIANGLE_FAN)
								}
						else if(o.isLine) {
							var C = r.linewidth;
							void 0 === C && (C = 1),
								Qt.setLineWidth(C * e()),
								o.isLineSegments ? T.setMode(Wt.LINES) : o.isLineLoop ? T.setMode(Wt.LINE_LOOP) : T.setMode(Wt.LINE_STRIP)
						} else
							o.isPoints && T.setMode(Wt.POINTS);
						i && i.isInstancedBufferGeometry ? i.maxInstancedCount > 0 && T.renderInstances(i, P, O) : T.render(P, O)
					}
				},
				this.compile = function(t, e) {
					G = [],
						t.traverse(function(t) {
							t.isLight && G.push(t)
						}),
						L(G, e),
						t.traverse(function(e) {
							if(e.material)
								if(Array.isArray(e.material))
									for(var n = 0; n < e.material.length; n++)
										_(e.material[n], t.fog, e);
								else
									_(e.material, t.fog, e)
						})
				},
				this.render = function(t, e, n, i) {
					if(void 0 !== e && e.isCamera !== !0)
						return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
					st = "",
						at = -1,
						lt = null,
						t.autoUpdate === !0 && t.updateMatrixWorld(),
						e.onBeforeRender(tt),
						null === e.parent && e.updateMatrixWorld(),
						e.matrixWorldInverse.getInverse(e.matrixWorld),
						St.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
						wt.setFromMatrix(St),
						G.length = 0,
						K.length = 0,
						$.length = 0,
						Et = this.localClippingEnabled,
						Mt = Tt.init(this.clippingPlanes, Et, e),
						Y = re.get(t, e),
						Y.init(),
						m(t, e, tt.sortObjects),
						Y.finish(),
						tt.sortObjects === !0 && Y.sort(),
						Mt && Tt.beginShadows(),
						C(G),
						_e.render(t, e),
						L(G, e),
						Mt && Tt.endShadows(),
						Nt.frame++,
						Nt.calls = 0,
						Nt.vertices = 0,
						Nt.faces = 0,
						Nt.points = 0,
						void 0 === n && (n = null),
						this.setRenderTarget(n);
					var r = t.background;
					null === r ? Qt.buffers.color.setClear(pt.r, pt.g, pt.b, mt, j) : r && r.isColor && (Qt.buffers.color.setClear(r.r, r.g, r.b, 1, j),
							i = !0),
						(this.autoClear || i) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil),
						r && r.isCubeTexture ? (void 0 === pe && (pe = new It,
								me = new At(new Rt(5, 5, 5), new J({
									uniforms: Bc.cube.uniforms,
									vertexShader: Bc.cube.vertexShader,
									fragmentShader: Bc.cube.fragmentShader,
									side: vo,
									depthTest: !1,
									depthWrite: !1,
									fog: !1
								}))),
							pe.projectionMatrix.copy(e.projectionMatrix),
							pe.matrixWorld.extractRotation(e.matrixWorld),
							pe.matrixWorldInverse.getInverse(pe.matrixWorld),
							me.material.uniforms.tCube.value = r,
							me.modelViewMatrix.multiplyMatrices(pe.matrixWorldInverse, me.matrixWorld),
							ee.update(me),
							tt.renderBufferDirect(pe, null, me.geometry, me.material, me, null)) : r && r.isTexture && (void 0 === oe && (oe = new Dt(-1, 1, 1, -1, 0, 1),
								fe = new At(new Ct(2, 2), new dt({
									depthTest: !1,
									depthWrite: !1,
									fog: !1
								}))),
							fe.material.map = r,
							ee.update(fe),
							tt.renderBufferDirect(oe, null, fe.geometry, fe.material, fe, null));
					var o = Y.opaque,
						a = Y.transparent;
					if(t.overrideMaterial) {
						var s = t.overrideMaterial;
						o.length && v(o, t, e, s),
							a.length && v(a, t, e, s)
					} else
						o.length && v(o, t, e),
						a.length && v(a, t, e);
					ye.render(t, e),
						be.render(t, e, ht),
						n && Kt.updateRenderTargetMipmap(n),
						Qt.buffers.depth.setTest(!0),
						Qt.buffers.depth.setMask(!0),
						Qt.buffers.color.setMask(!0),
						e.isArrayCamera && e.enabled && tt.setScissorTest(!1),
						e.onAfterRender(tt)
				},
				this.setFaceCulling = function(t, e) {
					Qt.setCullFace(t),
						Qt.setFlipSided(e === co)
				},
				this.allocTextureUnit = I,
				this.setTexture2D = function() {
					var t = !1;
					return function(e, n) {
						e && e.isWebGLRenderTarget && (t || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."),
									t = !0),
								e = e.texture),
							Kt.setTexture2D(e, n)
					}
				}(),
				this.setTexture = function() {
					var t = !1;
					return function(e, n) {
						t || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."),
								t = !0),
							Kt.setTexture2D(e, n)
					}
				}(),
				this.setTextureCube = function() {
					var t = !1;
					return function(e, n) {
						e && e.isWebGLRenderTargetCube && (t || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
									t = !0),
								e = e.texture),
							e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? Kt.setTextureCube(e, n) : Kt.setTextureCubeDynamic(e, n)
					}
				}(),
				this.getRenderTarget = function() {
					return nt
				},
				this.setRenderTarget = function(t) {
					nt = t,
						t && void 0 === Jt.get(t).__webglFramebuffer && Kt.setupRenderTarget(t);
					var e, n = t && t.isWebGLRenderTargetCube;
					if(t) {
						var i = Jt.get(t);
						e = n ? i.__webglFramebuffer[t.activeCubeFace] : i.__webglFramebuffer,
							ct.copy(t.scissor),
							ut = t.scissorTest,
							ht.copy(t.viewport)
					} else
						e = null,
						ct.copy(yt).multiplyScalar(_t),
						ut = bt,
						ht.copy(xt).multiplyScalar(_t);
					if(ot !== e && (Wt.bindFramebuffer(Wt.FRAMEBUFFER, e),
							ot = e),
						Qt.scissor(ct),
						Qt.setScissorTest(ut),
						Qt.viewport(ht),
						n) {
						var r = Jt.get(t.texture);
						Wt.framebufferTexture2D(Wt.FRAMEBUFFER, Wt.COLOR_ATTACHMENT0, Wt.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, r.__webglTexture, t.activeMipMapLevel)
					}
				},
				this.readRenderTargetPixels = function(t, e, n, i, r, o) {
					if((t && t.isWebGLRenderTarget) === !1)
						return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
					var a = Jt.get(t).__webglFramebuffer;
					if(a) {
						var s = !1;
						a !== ot && (Wt.bindFramebuffer(Wt.FRAMEBUFFER, a),
							s = !0);
						try {
							var l = t.texture,
								c = l.format,
								u = l.type;
							if(c !== za && D(c) !== Wt.getParameter(Wt.IMPLEMENTATION_COLOR_READ_FORMAT))
								return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
							if(!(u === Ma || D(u) === Wt.getParameter(Wt.IMPLEMENTATION_COLOR_READ_TYPE) || u === Ra && (qt.get("OES_texture_float") || qt.get("WEBGL_color_buffer_float")) || u === Oa && qt.get("EXT_color_buffer_half_float")))
								return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
							Wt.checkFramebufferStatus(Wt.FRAMEBUFFER) === Wt.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && Wt.readPixels(e, n, i, r, D(c), D(u), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
						} finally {
							s && Wt.bindFramebuffer(Wt.FRAMEBUFFER, ot)
						}
					}
				}
		}

		function pe(t, e) {
			this.name = "",
				this.color = new W(t),
				this.density = void 0 !== e ? e : 25e-5
		}

		function me(t, e, n) {
			this.name = "",
				this.color = new W(t),
				this.near = void 0 !== e ? e : 1,
				this.far = void 0 !== n ? n : 1e3
		}

		function ve() {
			lt.call(this),
				this.type = "Scene",
				this.background = null,
				this.fog = null,
				this.overrideMaterial = null,
				this.autoUpdate = !0
		}

		function ge(t, e, n, i, r) {
			lt.call(this),
				this.lensFlares = [],
				this.positionScreen = new l,
				this.customUpdateCallback = void 0,
				void 0 !== t && this.add(t, e, n, i, r)
		}

		function _e(t) {
			Q.call(this),
				this.type = "SpriteMaterial",
				this.color = new W(16777215),
				this.map = null,
				this.rotation = 0,
				this.fog = !1,
				this.lights = !1,
				this.setValues(t)
		}

		function ye(t) {
			lt.call(this),
				this.type = "Sprite",
				this.material = void 0 !== t ? t : new _e
		}

		function be() {
			lt.call(this),
				this.type = "LOD",
				Object.defineProperties(this, {
					levels: {
						enumerable: !0,
						value: []
					}
				})
		}

		function xe(t, e) {
			if(t = t || [],
				this.bones = t.slice(0),
				this.boneMatrices = new Float32Array(16 * this.bones.length),
				void 0 === e)
				this.calculateInverses();
			else if(this.bones.length === e.length)
				this.boneInverses = e.slice(0);
			else {
				console.warn("THREE.Skeleton boneInverses is the wrong length."),
					this.boneInverses = [];
				for(var n = 0, i = this.bones.length; n < i; n++)
					this.boneInverses.push(new c)
			}
		}

		function we() {
			lt.call(this),
				this.type = "Bone"
		}

		function Te(t, e) {
			At.call(this, t, e),
				this.type = "SkinnedMesh",
				this.bindMode = "attached",
				this.bindMatrix = new c,
				this.bindMatrixInverse = new c;
			var n = this.initBones(),
				i = new xe(n);
			this.bind(i, this.matrixWorld),
				this.normalizeSkinWeights()
		}

		function Me(t) {
			Q.call(this),
				this.type = "LineBasicMaterial",
				this.color = new W(16777215),
				this.linewidth = 1,
				this.linecap = "round",
				this.linejoin = "round",
				this.lights = !1,
				this.setValues(t)
		}

		function Ee(t, e, n) {
			return 1 === n ? (console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."),
				new Se(t, e)) : (lt.call(this),
				this.type = "Line",
				this.geometry = void 0 !== t ? t : new Xt,
				void(this.material = void 0 !== e ? e : new Me({
					color: 16777215 * Math.random()
				})))
		}

		function Se(t, e) {
			Ee.call(this, t, e),
				this.type = "LineSegments"
		}

		function Xe(t, e) {
			Ee.call(this, t, e),
				this.type = "LineLoop"
		}

		function Ae(t) {
			Q.call(this),
				this.type = "PointsMaterial",
				this.color = new W(16777215),
				this.map = null,
				this.size = 1,
				this.sizeAttenuation = !0,
				this.lights = !1,
				this.setValues(t)
		}

		function Pe(t, e) {
			lt.call(this),
				this.type = "Points",
				this.geometry = void 0 !== t ? t : new Xt,
				this.material = void 0 !== e ? e : new Ae({
					color: 16777215 * Math.random()
				})
		}

		function Re() {
			lt.call(this),
				this.type = "Group"
		}

		function Oe(t, e, n, r, o, a, s, l, c) {
			function u() {
				requestAnimationFrame(u),
					t.readyState >= t.HAVE_CURRENT_DATA && (h.needsUpdate = !0)
			}
			i.call(this, t, e, n, r, o, a, s, l, c),
				this.generateMipmaps = !1;
			var h = this;
			u()
		}

		function Ce(t, e, n, r, o, a, s, l, c, u, h, d) {
			i.call(this, null, a, s, l, c, u, r, o, h, d),
				this.image = {
					width: e,
					height: n
				},
				this.mipmaps = t,
				this.flipY = !1,
				this.generateMipmaps = !1
		}

		function Le(t, e, n, r, o, a, s, l, c) {
			i.call(this, t, e, n, r, o, a, s, l, c),
				this.needsUpdate = !0
		}

		function Ie(t, e, n, r, o, a, s, l, c, u) {
			if(u = void 0 !== u ? u : ja,
				u !== ja && u !== Va)
				throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
			void 0 === n && u === ja && (n = Xa),
				void 0 === n && u === Va && (n = Da),
				i.call(this, null, r, o, a, s, l, u, n, c),
				this.image = {
					width: t,
					height: e
				},
				this.magFilter = void 0 !== s ? s : _a,
				this.minFilter = void 0 !== l ? l : _a,
				this.flipY = !1,
				this.generateMipmaps = !1
		}

		function De(t) {
			Xt.call(this),
				this.type = "WireframeGeometry";
			var e, n, i, r, o, a, s, c, u, h, d = [],
				f = [0, 0],
				p = {},
				m = ["a", "b", "c"];
			if(t && t.isGeometry) {
				var v = t.faces;
				for(e = 0,
					i = v.length; e < i; e++) {
					var g = v[e];
					for(n = 0; n < 3; n++)
						s = g[m[n]],
						c = g[m[(n + 1) % 3]],
						f[0] = Math.min(s, c),
						f[1] = Math.max(s, c),
						u = f[0] + "," + f[1],
						void 0 === p[u] && (p[u] = {
							index1: f[0],
							index2: f[1]
						})
				}
				for(u in p)
					a = p[u],
					h = t.vertices[a.index1],
					d.push(h.x, h.y, h.z),
					h = t.vertices[a.index2],
					d.push(h.x, h.y, h.z)
			} else if(t && t.isBufferGeometry) {
				var _, y, b, x, w, T, M, E;
				if(h = new l,
					null !== t.index) {
					for(_ = t.attributes.position,
						y = t.index,
						b = t.groups,
						0 === b.length && (b = [{
							start: 0,
							count: y.count,
							materialIndex: 0
						}]),
						r = 0,
						o = b.length; r < o; ++r)
						for(x = b[r],
							w = x.start,
							T = x.count,
							e = w,
							i = w + T; e < i; e += 3)
							for(n = 0; n < 3; n++)
								s = y.getX(e + n),
								c = y.getX(e + (n + 1) % 3),
								f[0] = Math.min(s, c),
								f[1] = Math.max(s, c),
								u = f[0] + "," + f[1],
								void 0 === p[u] && (p[u] = {
									index1: f[0],
									index2: f[1]
								});
					for(u in p)
						a = p[u],
						h.fromBufferAttribute(_, a.index1),
						d.push(h.x, h.y, h.z),
						h.fromBufferAttribute(_, a.index2),
						d.push(h.x, h.y, h.z)
				} else
					for(_ = t.attributes.position,
						e = 0,
						i = _.count / 3; e < i; e++)
						for(n = 0; n < 3; n++)
							M = 3 * e + n,
							h.fromBufferAttribute(_, M),
							d.push(h.x, h.y, h.z),
							E = 3 * e + (n + 1) % 3,
							h.fromBufferAttribute(_, E),
							d.push(h.x, h.y, h.z)
			}
			this.addAttribute("position", new xt(d, 3))
		}

		function Be(t, e, n) {
			St.call(this),
				this.type = "ParametricGeometry",
				this.parameters = {
					func: t,
					slices: e,
					stacks: n
				},
				this.fromBufferGeometry(new Fe(t, e, n)),
				this.mergeVertices()
		}

		function Fe(t, e, n) {
			Xt.call(this),
				this.type = "ParametricBufferGeometry",
				this.parameters = {
					func: t,
					slices: e,
					stacks: n
				};
			var i, r, o = [],
				a = [],
				s = [],
				c = [],
				u = 1e-5,
				h = new l,
				d = new l,
				f = new l,
				p = new l,
				m = new l,
				v = e + 1;
			for(i = 0; i <= n; i++) {
				var g = i / n;
				for(r = 0; r <= e; r++) {
					var _ = r / e;
					d = t(_, g, d),
						a.push(d.x, d.y, d.z),
						_ - u >= 0 ? (f = t(_ - u, g, f),
							p.subVectors(d, f)) : (f = t(_ + u, g, f),
							p.subVectors(f, d)),
						g - u >= 0 ? (f = t(_, g - u, f),
							m.subVectors(d, f)) : (f = t(_, g + u, f),
							m.subVectors(f, d)),
						h.crossVectors(p, m).normalize(),
						s.push(h.x, h.y, h.z),
						c.push(_, g)
				}
			}
			for(i = 0; i < n; i++)
				for(r = 0; r < e; r++) {
					var y = i * v + r,
						b = i * v + r + 1,
						x = (i + 1) * v + r + 1,
						w = (i + 1) * v + r;
					o.push(y, b, w),
						o.push(b, x, w)
				}
			this.setIndex(o),
				this.addAttribute("position", new xt(a, 3)),
				this.addAttribute("normal", new xt(s, 3)),
				this.addAttribute("uv", new xt(c, 2))
		}

		function ze(t, e, n, i) {
			St.call(this),
				this.type = "PolyhedronGeometry",
				this.parameters = {
					vertices: t,
					indices: e,
					radius: n,
					detail: i
				},
				this.fromBufferGeometry(new Ne(t, e, n, i)),
				this.mergeVertices()
		}

		function Ne(t, e, i, r) {
			function o(t) {
				for(var n = new l, i = new l, r = new l, o = 0; o < e.length; o += 3)
					d(e[o + 0], n),
					d(e[o + 1], i),
					d(e[o + 2], r),
					a(n, i, r, t)
			}

			function a(t, e, n, i) {
				var r, o, a = Math.pow(2, i),
					s = [];
				for(r = 0; r <= a; r++) {
					s[r] = [];
					var l = t.clone().lerp(n, r / a),
						c = e.clone().lerp(n, r / a),
						u = a - r;
					for(o = 0; o <= u; o++)
						0 === o && r === a ? s[r][o] = l : s[r][o] = l.clone().lerp(c, o / u)
				}
				for(r = 0; r < a; r++)
					for(o = 0; o < 2 * (a - r) - 1; o++) {
						var d = Math.floor(o / 2);
						o % 2 === 0 ? (h(s[r][d + 1]),
							h(s[r + 1][d]),
							h(s[r][d])) : (h(s[r][d + 1]),
							h(s[r + 1][d + 1]),
							h(s[r + 1][d]))
					}
			}

			function s(t) {
				for(var e = new l, n = 0; n < g.length; n += 3)
					e.x = g[n + 0],
					e.y = g[n + 1],
					e.z = g[n + 2],
					e.normalize().multiplyScalar(t),
					g[n + 0] = e.x,
					g[n + 1] = e.y,
					g[n + 2] = e.z
			}

			function c() {
				for(var t = new l, e = 0; e < g.length; e += 3) {
					t.x = g[e + 0],
						t.y = g[e + 1],
						t.z = g[e + 2];
					var n = m(t) / 2 / Math.PI + .5,
						i = v(t) / Math.PI + .5;
					_.push(n, 1 - i)
				}
				f(),
					u()
			}

			function u() {
				for(var t = 0; t < _.length; t += 6) {
					var e = _[t + 0],
						n = _[t + 2],
						i = _[t + 4],
						r = Math.max(e, n, i),
						o = Math.min(e, n, i);
					r > .9 && o < .1 && (e < .2 && (_[t + 0] += 1),
						n < .2 && (_[t + 2] += 1),
						i < .2 && (_[t + 4] += 1))
				}
			}

			function h(t) {
				g.push(t.x, t.y, t.z)
			}

			function d(e, n) {
				var i = 3 * e;
				n.x = t[i + 0],
					n.y = t[i + 1],
					n.z = t[i + 2]
			}

			function f() {
				for(var t = new l, e = new l, i = new l, r = new l, o = new n, a = new n, s = new n, c = 0, u = 0; c < g.length; c += 9,
					u += 6) {
					t.set(g[c + 0], g[c + 1], g[c + 2]),
						e.set(g[c + 3], g[c + 4], g[c + 5]),
						i.set(g[c + 6], g[c + 7], g[c + 8]),
						o.set(_[u + 0], _[u + 1]),
						a.set(_[u + 2], _[u + 3]),
						s.set(_[u + 4], _[u + 5]),
						r.copy(t).add(e).add(i).divideScalar(3);
					var h = m(r);
					p(o, u + 0, t, h),
						p(a, u + 2, e, h),
						p(s, u + 4, i, h)
				}
			}

			function p(t, e, n, i) {
				i < 0 && 1 === t.x && (_[e] = t.x - 1),
					0 === n.x && 0 === n.z && (_[e] = i / 2 / Math.PI + .5)
			}

			function m(t) {
				return Math.atan2(t.z, -t.x)
			}

			function v(t) {
				return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
			}
			Xt.call(this),
				this.type = "PolyhedronBufferGeometry",
				this.parameters = {
					vertices: t,
					indices: e,
					radius: i,
					detail: r
				},
				i = i || 1,
				r = r || 0;
			var g = [],
				_ = [];
			o(r),
				s(i),
				c(),
				this.addAttribute("position", new xt(g, 3)),
				this.addAttribute("normal", new xt(g.slice(), 3)),
				this.addAttribute("uv", new xt(_, 2)),
				this.normalizeNormals()
		}

		function ke(t, e) {
			St.call(this),
				this.type = "TetrahedronGeometry",
				this.parameters = {
					radius: t,
					detail: e
				},
				this.fromBufferGeometry(new Ue(t, e)),
				this.mergeVertices()
		}

		function Ue(t, e) {
			var n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
				i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
			Ne.call(this, n, i, t, e),
				this.type = "TetrahedronBufferGeometry",
				this.parameters = {
					radius: t,
					detail: e
				}
		}

		function je(t, e) {
			St.call(this),
				this.type = "OctahedronGeometry",
				this.parameters = {
					radius: t,
					detail: e
				},
				this.fromBufferGeometry(new Ve(t, e)),
				this.mergeVertices()
		}

		function Ve(t, e) {
			var n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
				i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
			Ne.call(this, n, i, t, e),
				this.type = "OctahedronBufferGeometry",
				this.parameters = {
					radius: t,
					detail: e
				}
		}

		function Ge(t, e) {
			St.call(this),
				this.type = "IcosahedronGeometry",
				this.parameters = {
					radius: t,
					detail: e
				},
				this.fromBufferGeometry(new He(t, e)),
				this.mergeVertices()
		}

		function He(t, e) {
			var n = (1 + Math.sqrt(5)) / 2,
				i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1],
				r = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
			Ne.call(this, i, r, t, e),
				this.type = "IcosahedronBufferGeometry",
				this.parameters = {
					radius: t,
					detail: e
				}
		}

		function We(t, e) {
			St.call(this),
				this.type = "DodecahedronGeometry",
				this.parameters = {
					radius: t,
					detail: e
				},
				this.fromBufferGeometry(new Ye(t, e)),
				this.mergeVertices()
		}

		function Ye(t, e) {
			var n = (1 + Math.sqrt(5)) / 2,
				i = 1 / n,
				r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i],
				o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
			Ne.call(this, r, o, t, e),
				this.type = "DodecahedronBufferGeometry",
				this.parameters = {
					radius: t,
					detail: e
				}
		}

		function qe(t, e, n, i, r, o) {
			St.call(this),
				this.type = "TubeGeometry",
				this.parameters = {
					path: t,
					tubularSegments: e,
					radius: n,
					radialSegments: i,
					closed: r
				},
				void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
			var a = new Ze(t, e, n, i, r);
			this.tangents = a.tangents,
				this.normals = a.normals,
				this.binormals = a.binormals,
				this.fromBufferGeometry(a),
				this.mergeVertices()
		}

		function Ze(t, e, i, r, o) {
			function a() {
				for(d = 0; d < e; d++)
					s(d);
				s(o === !1 ? e : 0),
					u(),
					c()
			}

			function s(n) {
				var o = t.getPointAt(n / e),
					a = h.normals[n],
					s = h.binormals[n];
				for(f = 0; f <= r; f++) {
					var l = f / r * Math.PI * 2,
						c = Math.sin(l),
						u = -Math.cos(l);
					m.x = u * a.x + c * s.x,
						m.y = u * a.y + c * s.y,
						m.z = u * a.z + c * s.z,
						m.normalize(),
						_.push(m.x, m.y, m.z),
						p.x = o.x + i * m.x,
						p.y = o.y + i * m.y,
						p.z = o.z + i * m.z,
						g.push(p.x, p.y, p.z)
				}
			}

			function c() {
				for(f = 1; f <= e; f++)
					for(d = 1; d <= r; d++) {
						var t = (r + 1) * (f - 1) + (d - 1),
							n = (r + 1) * f + (d - 1),
							i = (r + 1) * f + d,
							o = (r + 1) * (f - 1) + d;
						b.push(t, n, o),
							b.push(n, i, o)
					}
			}

			function u() {
				for(d = 0; d <= e; d++)
					for(f = 0; f <= r; f++)
						v.x = d / e,
						v.y = f / r,
						y.push(v.x, v.y)
			}
			Xt.call(this),
				this.type = "TubeBufferGeometry",
				this.parameters = {
					path: t,
					tubularSegments: e,
					radius: i,
					radialSegments: r,
					closed: o
				},
				e = e || 64,
				i = i || 1,
				r = r || 8,
				o = o || !1;
			var h = t.computeFrenetFrames(e, o);
			this.tangents = h.tangents,
				this.normals = h.normals,
				this.binormals = h.binormals;
			var d, f, p = new l,
				m = new l,
				v = new n,
				g = [],
				_ = [],
				y = [],
				b = [];
			a(),
				this.setIndex(b),
				this.addAttribute("position", new xt(g, 3)),
				this.addAttribute("normal", new xt(_, 3)),
				this.addAttribute("uv", new xt(y, 2))
		}

		function Qe(t, e, n, i, r, o, a) {
			St.call(this),
				this.type = "TorusKnotGeometry",
				this.parameters = {
					radius: t,
					tube: e,
					tubularSegments: n,
					radialSegments: i,
					p: r,
					q: o
				},
				void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),
				this.fromBufferGeometry(new Je(t, e, n, i, r, o)),
				this.mergeVertices()
		}

		function Je(t, e, n, i, r, o) {
			function a(t, e, n, i, r) {
				var o = Math.cos(t),
					a = Math.sin(t),
					s = n / e * t,
					l = Math.cos(s);
				r.x = i * (2 + l) * .5 * o,
					r.y = i * (2 + l) * a * .5,
					r.z = i * Math.sin(s) * .5
			}
			Xt.call(this),
				this.type = "TorusKnotBufferGeometry",
				this.parameters = {
					radius: t,
					tube: e,
					tubularSegments: n,
					radialSegments: i,
					p: r,
					q: o
				},
				t = t || 100,
				e = e || 40,
				n = Math.floor(n) || 64,
				i = Math.floor(i) || 8,
				r = r || 2,
				o = o || 3;
			var s, c, u = [],
				h = [],
				d = [],
				f = [],
				p = new l,
				m = new l,
				v = new l,
				g = new l,
				_ = new l,
				y = new l,
				b = new l;
			for(s = 0; s <= n; ++s) {
				var x = s / n * r * Math.PI * 2;
				for(a(x, r, o, t, v),
					a(x + .01, r, o, t, g),
					y.subVectors(g, v),
					b.addVectors(g, v),
					_.crossVectors(y, b),
					b.crossVectors(_, y),
					_.normalize(),
					b.normalize(),
					c = 0; c <= i; ++c) {
					var w = c / i * Math.PI * 2,
						T = -e * Math.cos(w),
						M = e * Math.sin(w);
					p.x = v.x + (T * b.x + M * _.x),
						p.y = v.y + (T * b.y + M * _.y),
						p.z = v.z + (T * b.z + M * _.z),
						h.push(p.x, p.y, p.z),
						m.subVectors(p, v).normalize(),
						d.push(m.x, m.y, m.z),
						f.push(s / n),
						f.push(c / i)
				}
			}
			for(c = 1; c <= n; c++)
				for(s = 1; s <= i; s++) {
					var E = (i + 1) * (c - 1) + (s - 1),
						S = (i + 1) * c + (s - 1),
						X = (i + 1) * c + s,
						A = (i + 1) * (c - 1) + s;
					u.push(E, S, A),
						u.push(S, X, A)
				}
			this.setIndex(u),
				this.addAttribute("position", new xt(h, 3)),
				this.addAttribute("normal", new xt(d, 3)),
				this.addAttribute("uv", new xt(f, 2))
		}

		function Ke(t, e, n, i, r) {
			St.call(this),
				this.type = "TorusGeometry",
				this.parameters = {
					radius: t,
					tube: e,
					radialSegments: n,
					tubularSegments: i,
					arc: r
				},
				this.fromBufferGeometry(new $e(t, e, n, i, r)),
				this.mergeVertices()
		}

		function $e(t, e, n, i, r) {
			Xt.call(this),
				this.type = "TorusBufferGeometry",
				this.parameters = {
					radius: t,
					tube: e,
					radialSegments: n,
					tubularSegments: i,
					arc: r
				},
				t = t || 100,
				e = e || 40,
				n = Math.floor(n) || 8,
				i = Math.floor(i) || 6,
				r = r || 2 * Math.PI;
			var o, a, s = [],
				c = [],
				u = [],
				h = [],
				d = new l,
				f = new l,
				p = new l;
			for(o = 0; o <= n; o++)
				for(a = 0; a <= i; a++) {
					var m = a / i * r,
						v = o / n * Math.PI * 2;
					f.x = (t + e * Math.cos(v)) * Math.cos(m),
						f.y = (t + e * Math.cos(v)) * Math.sin(m),
						f.z = e * Math.sin(v),
						c.push(f.x, f.y, f.z),
						d.x = t * Math.cos(m),
						d.y = t * Math.sin(m),
						p.subVectors(f, d).normalize(),
						u.push(p.x, p.y, p.z),
						h.push(a / i),
						h.push(o / n)
				}
			for(o = 1; o <= n; o++)
				for(a = 1; a <= i; a++) {
					var g = (i + 1) * o + a - 1,
						_ = (i + 1) * (o - 1) + a - 1,
						y = (i + 1) * (o - 1) + a,
						b = (i + 1) * o + a;
					s.push(g, _, b),
						s.push(_, y, b)
				}
			this.setIndex(s),
				this.addAttribute("position", new xt(c, 3)),
				this.addAttribute("normal", new xt(u, 3)),
				this.addAttribute("uv", new xt(h, 2))
		}

		function tn(t, e) {
			St.call(this),
				this.type = "ExtrudeGeometry",
				this.parameters = {
					shapes: t,
					options: e
				},
				this.fromBufferGeometry(new en(t, e)),
				this.mergeVertices()
		}

		function en(t, e) {
			return "undefined" == typeof t ? void(t = []) : (Xt.call(this),
				this.type = "ExtrudeBufferGeometry",
				t = Array.isArray(t) ? t : [t],
				this.addShapeList(t, e),
				void this.computeVertexNormals())
		}

		function nn(t, e) {
			St.call(this),
				this.type = "TextGeometry",
				this.parameters = {
					text: t,
					parameters: e
				},
				this.fromBufferGeometry(new rn(t, e)),
				this.mergeVertices()
		}

		function rn(t, e) {
			e = e || {};
			var n = e.font;
			if((n && n.isFont) === !1)
				return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
					new St;
			var i = n.generateShapes(t, e.size, e.curveSegments);
			e.amount = void 0 !== e.height ? e.height : 50,
				void 0 === e.bevelThickness && (e.bevelThickness = 10),
				void 0 === e.bevelSize && (e.bevelSize = 8),
				void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
				en.call(this, i, e),
				this.type = "TextBufferGeometry"
		}

		function on(t, e, n, i, r, o, a) {
			St.call(this),
				this.type = "SphereGeometry",
				this.parameters = {
					radius: t,
					widthSegments: e,
					heightSegments: n,
					phiStart: i,
					phiLength: r,
					thetaStart: o,
					thetaLength: a
				},
				this.fromBufferGeometry(new an(t, e, n, i, r, o, a)),
				this.mergeVertices()
		}

		function an(t, e, n, i, r, o, a) {
			Xt.call(this),
				this.type = "SphereBufferGeometry",
				this.parameters = {
					radius: t,
					widthSegments: e,
					heightSegments: n,
					phiStart: i,
					phiLength: r,
					thetaStart: o,
					thetaLength: a
				},
				t = t || 50,
				e = Math.max(3, Math.floor(e) || 8),
				n = Math.max(2, Math.floor(n) || 6),
				i = void 0 !== i ? i : 0,
				r = void 0 !== r ? r : 2 * Math.PI,
				o = void 0 !== o ? o : 0,
				a = void 0 !== a ? a : Math.PI;
			var s, c, u = o + a,
				h = 0,
				d = [],
				f = new l,
				p = new l,
				m = [],
				v = [],
				g = [],
				_ = [];
			for(c = 0; c <= n; c++) {
				var y = [],
					b = c / n;
				for(s = 0; s <= e; s++) {
					var x = s / e;
					f.x = -t * Math.cos(i + x * r) * Math.sin(o + b * a),
						f.y = t * Math.cos(o + b * a),
						f.z = t * Math.sin(i + x * r) * Math.sin(o + b * a),
						v.push(f.x, f.y, f.z),
						p.set(f.x, f.y, f.z).normalize(),
						g.push(p.x, p.y, p.z),
						_.push(x, 1 - b),
						y.push(h++)
				}
				d.push(y)
			}
			for(c = 0; c < n; c++)
				for(s = 0; s < e; s++) {
					var w = d[c][s + 1],
						T = d[c][s],
						M = d[c + 1][s],
						E = d[c + 1][s + 1];
					(0 !== c || o > 0) && m.push(w, T, E),
						(c !== n - 1 || u < Math.PI) && m.push(T, M, E)
				}
			this.setIndex(m),
				this.addAttribute("position", new xt(v, 3)),
				this.addAttribute("normal", new xt(g, 3)),
				this.addAttribute("uv", new xt(_, 2))
		}

		function sn(t, e, n, i, r, o) {
			St.call(this),
				this.type = "RingGeometry",
				this.parameters = {
					innerRadius: t,
					outerRadius: e,
					thetaSegments: n,
					phiSegments: i,
					thetaStart: r,
					thetaLength: o
				},
				this.fromBufferGeometry(new ln(t, e, n, i, r, o)),
				this.mergeVertices()
		}

		function ln(t, e, i, r, o, a) {
			Xt.call(this),
				this.type = "RingBufferGeometry",
				this.parameters = {
					innerRadius: t,
					outerRadius: e,
					thetaSegments: i,
					phiSegments: r,
					thetaStart: o,
					thetaLength: a
				},
				t = t || 20,
				e = e || 50,
				o = void 0 !== o ? o : 0,
				a = void 0 !== a ? a : 2 * Math.PI,
				i = void 0 !== i ? Math.max(3, i) : 8,
				r = void 0 !== r ? Math.max(1, r) : 1;
			var s, c, u, h = [],
				d = [],
				f = [],
				p = [],
				m = t,
				v = (e - t) / r,
				g = new l,
				_ = new n;
			for(c = 0; c <= r; c++) {
				for(u = 0; u <= i; u++)
					s = o + u / i * a,
					g.x = m * Math.cos(s),
					g.y = m * Math.sin(s),
					d.push(g.x, g.y, g.z),
					f.push(0, 0, 1),
					_.x = (g.x / e + 1) / 2,
					_.y = (g.y / e + 1) / 2,
					p.push(_.x, _.y);
				m += v
			}
			for(c = 0; c < r; c++) {
				var y = c * (i + 1);
				for(u = 0; u < i; u++) {
					s = u + y;
					var b = s,
						x = s + i + 1,
						w = s + i + 2,
						T = s + 1;
					h.push(b, x, T),
						h.push(x, w, T)
				}
			}
			this.setIndex(h),
				this.addAttribute("position", new xt(d, 3)),
				this.addAttribute("normal", new xt(f, 3)),
				this.addAttribute("uv", new xt(p, 2))
		}

		function cn(t, e, n, i) {
			St.call(this),
				this.type = "LatheGeometry",
				this.parameters = {
					points: t,
					segments: e,
					phiStart: n,
					phiLength: i
				},
				this.fromBufferGeometry(new un(t, e, n, i)),
				this.mergeVertices()
		}

		function un(t, e, i, r) {
			Xt.call(this),
				this.type = "LatheBufferGeometry",
				this.parameters = {
					points: t,
					segments: e,
					phiStart: i,
					phiLength: r
				},
				e = Math.floor(e) || 12,
				i = i || 0,
				r = r || 2 * Math.PI,
				r = xs.clamp(r, 0, 2 * Math.PI);
			var o, a, s, c = [],
				u = [],
				h = [],
				d = 1 / e,
				f = new l,
				p = new n;
			for(a = 0; a <= e; a++) {
				var m = i + a * d * r,
					v = Math.sin(m),
					g = Math.cos(m);
				for(s = 0; s <= t.length - 1; s++)
					f.x = t[s].x * v,
					f.y = t[s].y,
					f.z = t[s].x * g,
					u.push(f.x, f.y, f.z),
					p.x = a / e,
					p.y = s / (t.length - 1),
					h.push(p.x, p.y)
			}
			for(a = 0; a < e; a++)
				for(s = 0; s < t.length - 1; s++) {
					o = s + a * t.length;
					var _ = o,
						y = o + t.length,
						b = o + t.length + 1,
						x = o + 1;
					c.push(_, y, x),
						c.push(y, b, x)
				}
			if(this.setIndex(c),
				this.addAttribute("position", new xt(u, 3)),
				this.addAttribute("uv", new xt(h, 2)),
				this.computeVertexNormals(),
				r === 2 * Math.PI) {
				var w = this.attributes.normal.array,
					T = new l,
					M = new l,
					E = new l;
				for(o = e * t.length * 3,
					a = 0,
					s = 0; a < t.length; a++,
					s += 3)
					T.x = w[s + 0],
					T.y = w[s + 1],
					T.z = w[s + 2],
					M.x = w[o + s + 0],
					M.y = w[o + s + 1],
					M.z = w[o + s + 2],
					E.addVectors(T, M).normalize(),
					w[s + 0] = w[o + s + 0] = E.x,
					w[s + 1] = w[o + s + 1] = E.y,
					w[s + 2] = w[o + s + 2] = E.z
			}
		}

		function hn(t, e) {
			St.call(this),
				this.type = "ShapeGeometry",
				"object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."),
					e = e.curveSegments),
				this.parameters = {
					shapes: t,
					curveSegments: e
				},
				this.fromBufferGeometry(new dn(t, e)),
				this.mergeVertices()
		}

		function dn(t, e) {
			function n(t) {
				var n, s, c, u = r.length / 3,
					h = t.extractPoints(e),
					d = h.shape,
					f = h.holes;
				if(Uc.isClockWise(d) === !1)
					for(d = d.reverse(),
						n = 0,
						s = f.length; n < s; n++)
						c = f[n],
						Uc.isClockWise(c) === !0 && (f[n] = c.reverse());
				var p = Uc.triangulateShape(d, f);
				for(n = 0,
					s = f.length; n < s; n++)
					c = f[n],
					d = d.concat(c);
				for(n = 0,
					s = d.length; n < s; n++) {
					var m = d[n];
					r.push(m.x, m.y, 0),
						o.push(0, 0, 1),
						a.push(m.x, m.y)
				}
				for(n = 0,
					s = p.length; n < s; n++) {
					var v = p[n],
						g = v[0] + u,
						_ = v[1] + u,
						y = v[2] + u;
					i.push(g, _, y),
						l += 3
				}
			}
			Xt.call(this),
				this.type = "ShapeBufferGeometry",
				this.parameters = {
					shapes: t,
					curveSegments: e
				},
				e = e || 12;
			var i = [],
				r = [],
				o = [],
				a = [],
				s = 0,
				l = 0;
			if(Array.isArray(t) === !1)
				n(t);
			else
				for(var c = 0; c < t.length; c++)
					n(t[c]),
					this.addGroup(s, l, c),
					s += l,
					l = 0;
			this.setIndex(i),
				this.addAttribute("position", new xt(r, 3)),
				this.addAttribute("normal", new xt(o, 3)),
				this.addAttribute("uv", new xt(a, 2))
		}

		function fn(t, e) {
			Xt.call(this),
				this.type = "EdgesGeometry",
				this.parameters = {
					thresholdAngle: e
				},
				e = void 0 !== e ? e : 1;
			var n, i, r, o, a = [],
				s = Math.cos(xs.DEG2RAD * e),
				l = [0, 0],
				c = {},
				u = ["a", "b", "c"];
			t.isBufferGeometry ? (o = new St,
					o.fromBufferGeometry(t)) : o = t.clone(),
				o.mergeVertices(),
				o.computeFaceNormals();
			for(var h = o.vertices, d = o.faces, f = 0, p = d.length; f < p; f++)
				for(var m = d[f], v = 0; v < 3; v++)
					n = m[u[v]],
					i = m[u[(v + 1) % 3]],
					l[0] = Math.min(n, i),
					l[1] = Math.max(n, i),
					r = l[0] + "," + l[1],
					void 0 === c[r] ? c[r] = {
						index1: l[0],
						index2: l[1],
						face1: f,
						face2: void 0
					} : c[r].face2 = f;
			for(r in c) {
				var g = c[r];
				if(void 0 === g.face2 || d[g.face1].normal.dot(d[g.face2].normal) <= s) {
					var _ = h[g.index1];
					a.push(_.x, _.y, _.z),
						_ = h[g.index2],
						a.push(_.x, _.y, _.z)
				}
			}
			this.addAttribute("position", new xt(a, 3))
		}

		function pn(t, e, n, i, r, o, a, s) {
			St.call(this),
				this.type = "CylinderGeometry",
				this.parameters = {
					radiusTop: t,
					radiusBottom: e,
					height: n,
					radialSegments: i,
					heightSegments: r,
					openEnded: o,
					thetaStart: a,
					thetaLength: s
				},
				this.fromBufferGeometry(new mn(t, e, n, i, r, o, a, s)),
				this.mergeVertices()
		}

		function mn(t, e, i, r, o, a, s, c) {
			function u() {
				var n, a, u = new l,
					h = new l,
					x = 0,
					w = (e - t) / i;
				for(a = 0; a <= o; a++) {
					var T = [],
						M = a / o,
						E = M * (e - t) + t;
					for(n = 0; n <= r; n++) {
						var S = n / r,
							X = S * c + s,
							A = Math.sin(X),
							P = Math.cos(X);
						h.x = E * A,
							h.y = -M * i + y,
							h.z = E * P,
							p.push(h.x, h.y, h.z),
							u.set(A, w, P).normalize(),
							m.push(u.x, u.y, u.z),
							v.push(S, 1 - M),
							T.push(g++)
					}
					_.push(T)
				}
				for(n = 0; n < r; n++)
					for(a = 0; a < o; a++) {
						var R = _[a][n],
							O = _[a + 1][n],
							C = _[a + 1][n + 1],
							L = _[a][n + 1];
						f.push(R, O, L),
							f.push(O, C, L),
							x += 6
					}
				d.addGroup(b, x, 0),
					b += x
			}

			function h(i) {
				var o, a, u, h = new n,
					_ = new l,
					x = 0,
					w = i === !0 ? t : e,
					T = i === !0 ? 1 : -1;
				for(a = g,
					o = 1; o <= r; o++)
					p.push(0, y * T, 0),
					m.push(0, T, 0),
					v.push(.5, .5),
					g++;
				for(u = g,
					o = 0; o <= r; o++) {
					var M = o / r,
						E = M * c + s,
						S = Math.cos(E),
						X = Math.sin(E);
					_.x = w * X,
						_.y = y * T,
						_.z = w * S,
						p.push(_.x, _.y, _.z),
						m.push(0, T, 0),
						h.x = .5 * S + .5,
						h.y = .5 * X * T + .5,
						v.push(h.x, h.y),
						g++
				}
				for(o = 0; o < r; o++) {
					var A = a + o,
						P = u + o;
					i === !0 ? f.push(P, P + 1, A) : f.push(P + 1, P, A),
						x += 3
				}
				d.addGroup(b, x, i === !0 ? 1 : 2),
					b += x
			}
			Xt.call(this),
				this.type = "CylinderBufferGeometry",
				this.parameters = {
					radiusTop: t,
					radiusBottom: e,
					height: i,
					radialSegments: r,
					heightSegments: o,
					openEnded: a,
					thetaStart: s,
					thetaLength: c
				};
			var d = this;
			t = void 0 !== t ? t : 20,
				e = void 0 !== e ? e : 20,
				i = void 0 !== i ? i : 100,
				r = Math.floor(r) || 8,
				o = Math.floor(o) || 1,
				a = void 0 !== a && a,
				s = void 0 !== s ? s : 0,
				c = void 0 !== c ? c : 2 * Math.PI;
			var f = [],
				p = [],
				m = [],
				v = [],
				g = 0,
				_ = [],
				y = i / 2,
				b = 0;
			u(),
				a === !1 && (t > 0 && h(!0),
					e > 0 && h(!1)),
				this.setIndex(f),
				this.addAttribute("position", new xt(p, 3)),
				this.addAttribute("normal", new xt(m, 3)),
				this.addAttribute("uv", new xt(v, 2))
		}

		function vn(t, e, n, i, r, o, a) {
			pn.call(this, 0, t, e, n, i, r, o, a),
				this.type = "ConeGeometry",
				this.parameters = {
					radius: t,
					height: e,
					radialSegments: n,
					heightSegments: i,
					openEnded: r,
					thetaStart: o,
					thetaLength: a
				}
		}

		function gn(t, e, n, i, r, o, a) {
			mn.call(this, 0, t, e, n, i, r, o, a),
				this.type = "ConeBufferGeometry",
				this.parameters = {
					radius: t,
					height: e,
					radialSegments: n,
					heightSegments: i,
					openEnded: r,
					thetaStart: o,
					thetaLength: a
				}
		}

		function _n(t, e, n, i) {
			St.call(this),
				this.type = "CircleGeometry",
				this.parameters = {
					radius: t,
					segments: e,
					thetaStart: n,
					thetaLength: i
				},
				this.fromBufferGeometry(new yn(t, e, n, i)),
				this.mergeVertices()
		}

		function yn(t, e, i, r) {
			Xt.call(this),
				this.type = "CircleBufferGeometry",
				this.parameters = {
					radius: t,
					segments: e,
					thetaStart: i,
					thetaLength: r
				},
				t = t || 50,
				e = void 0 !== e ? Math.max(3, e) : 8,
				i = void 0 !== i ? i : 0,
				r = void 0 !== r ? r : 2 * Math.PI;
			var o, a, s = [],
				c = [],
				u = [],
				h = [],
				d = new l,
				f = new n;
			for(c.push(0, 0, 0),
				u.push(0, 0, 1),
				h.push(.5, .5),
				a = 0,
				o = 3; a <= e; a++,
				o += 3) {
				var p = i + a / e * r;
				d.x = t * Math.cos(p),
					d.y = t * Math.sin(p),
					c.push(d.x, d.y, d.z),
					u.push(0, 0, 1),
					f.x = (c[o] / t + 1) / 2,
					f.y = (c[o + 1] / t + 1) / 2,
					h.push(f.x, f.y)
			}
			for(o = 1; o <= e; o++)
				s.push(o, o + 1, 0);
			this.setIndex(s),
				this.addAttribute("position", new xt(c, 3)),
				this.addAttribute("normal", new xt(u, 3)),
				this.addAttribute("uv", new xt(h, 2))
		}

		function bn(t) {
			J.call(this, {
					uniforms: Cs.merge([Os.lights, {
						opacity: {
							value: 1
						}
					}]),
					vertexShader: Dc.shadow_vert,
					fragmentShader: Dc.shadow_frag
				}),
				this.lights = !0,
				this.transparent = !0,
				Object.defineProperties(this, {
					opacity: {
						enumerable: !0,
						get: function() {
							return this.uniforms.opacity.value
						},
						set: function(t) {
							this.uniforms.opacity.value = t
						}
					}
				}),
				this.setValues(t)
		}

		function xn(t) {
			J.call(this, t),
				this.type = "RawShaderMaterial"
		}

		function wn(t) {
			Q.call(this),
				this.defines = {
					STANDARD: ""
				},
				this.type = "MeshStandardMaterial",
				this.color = new W(16777215),
				this.roughness = .5,
				this.metalness = .5,
				this.map = null,
				this.lightMap = null,
				this.lightMapIntensity = 1,
				this.aoMap = null,
				this.aoMapIntensity = 1,
				this.emissive = new W(0),
				this.emissiveIntensity = 1,
				this.emissiveMap = null,
				this.bumpMap = null,
				this.bumpScale = 1,
				this.normalMap = null,
				this.normalScale = new n(1, 1),
				this.displacementMap = null,
				this.displacementScale = 1,
				this.displacementBias = 0,
				this.roughnessMap = null,
				this.metalnessMap = null,
				this.alphaMap = null,
				this.envMap = null,
				this.envMapIntensity = 1,
				this.refractionRatio = .98,
				this.wireframe = !1,
				this.wireframeLinewidth = 1,
				this.wireframeLinecap = "round",
				this.wireframeLinejoin = "round",
				this.skinning = !1,
				this.morphTargets = !1,
				this.morphNormals = !1,
				this.setValues(t)
		}

		function Tn(t) {
			wn.call(this),
				this.defines = {
					PHYSICAL: ""
				},
				this.type = "MeshPhysicalMaterial",
				this.reflectivity = .5,
				this.clearCoat = 0,
				this.clearCoatRoughness = 0,
				this.setValues(t)
		}

		function Mn(t) {
			Q.call(this),
				this.type = "MeshPhongMaterial",
				this.color = new W(16777215),
				this.specular = new W(1118481),
				this.shininess = 30,
				this.map = null,
				this.lightMap = null,
				this.lightMapIntensity = 1,
				this.aoMap = null,
				this.aoMapIntensity = 1,
				this.emissive = new W(0),
				this.emissiveIntensity = 1,
				this.emissiveMap = null,
				this.bumpMap = null,
				this.bumpScale = 1,
				this.normalMap = null,
				this.normalScale = new n(1, 1),
				this.displacementMap = null,
				this.displacementScale = 1,
				this.displacementBias = 0,
				this.specularMap = null,
				this.alphaMap = null,
				this.envMap = null,
				this.combine = $o,
				this.reflectivity = 1,
				this.refractionRatio = .98,
				this.wireframe = !1,
				this.wireframeLinewidth = 1,
				this.wireframeLinecap = "round",
				this.wireframeLinejoin = "round",
				this.skinning = !1,
				this.morphTargets = !1,
				this.morphNormals = !1,
				this.setValues(t)
		}

		function En(t) {
			Mn.call(this),
				this.defines = {
					TOON: ""
				},
				this.type = "MeshToonMaterial",
				this.gradientMap = null,
				this.setValues(t)
		}

		function Sn(t) {
			Q.call(this, t),
				this.type = "MeshNormalMaterial",
				this.bumpMap = null,
				this.bumpScale = 1,
				this.normalMap = null,
				this.normalScale = new n(1, 1),
				this.displacementMap = null,
				this.displacementScale = 1,
				this.displacementBias = 0,
				this.wireframe = !1,
				this.wireframeLinewidth = 1,
				this.fog = !1,
				this.lights = !1,
				this.skinning = !1,
				this.morphTargets = !1,
				this.morphNormals = !1,
				this.setValues(t)
		}

		function Xn(t) {
			Q.call(this),
				this.type = "MeshLambertMaterial",
				this.color = new W(16777215),
				this.map = null,
				this.lightMap = null,
				this.lightMapIntensity = 1,
				this.aoMap = null,
				this.aoMapIntensity = 1,
				this.emissive = new W(0),
				this.emissiveIntensity = 1,
				this.emissiveMap = null,
				this.specularMap = null,
				this.alphaMap = null,
				this.envMap = null,
				this.combine = $o,
				this.reflectivity = 1,
				this.refractionRatio = .98,
				this.wireframe = !1,
				this.wireframeLinewidth = 1,
				this.wireframeLinecap = "round",
				this.wireframeLinejoin = "round",
				this.skinning = !1,
				this.morphTargets = !1,
				this.morphNormals = !1,
				this.setValues(t)
		}

		function An(t) {
			Q.call(this),
				this.type = "LineDashedMaterial",
				this.color = new W(16777215),
				this.linewidth = 1,
				this.scale = 1,
				this.dashSize = 3,
				this.gapSize = 1,
				this.lights = !1,
				this.setValues(t)
		}

		function Pn(t, e, n) {
			var i = this,
				r = !1,
				o = 0,
				a = 0;
			this.onStart = void 0,
				this.onLoad = t,
				this.onProgress = e,
				this.onError = n,
				this.itemStart = function(t) {
					a++,
					r === !1 && void 0 !== i.onStart && i.onStart(t, o, a),
						r = !0
				},
				this.itemEnd = function(t) {
					o++,
					void 0 !== i.onProgress && i.onProgress(t, o, a),
						o === a && (r = !1,
							void 0 !== i.onLoad && i.onLoad())
				},
				this.itemError = function(t) {
					void 0 !== i.onError && i.onError(t)
				}
		}

		function Rn(t) {
			this.manager = void 0 !== t ? t : Hc
		}

		function On(t) {
			this.manager = void 0 !== t ? t : Hc,
				this._parser = null
		}

		function Cn(t) {
			this.manager = void 0 !== t ? t : Hc,
				this._parser = null
		}

		function Ln(t) {
			this.manager = void 0 !== t ? t : Hc
		}

		function In(t) {
			this.manager = void 0 !== t ? t : Hc
		}

		function Dn(t) {
			this.manager = void 0 !== t ? t : Hc
		}

		function Bn(t, e) {
			lt.call(this),
				this.type = "Light",
				this.color = new W(t),
				this.intensity = void 0 !== e ? e : 1,
				this.receiveShadow = void 0
		}

		function Fn(t, e, n) {
			Bn.call(this, t, n),
				this.type = "HemisphereLight",
				this.castShadow = void 0,
				this.position.copy(lt.DefaultUp),
				this.updateMatrix(),
				this.groundColor = new W(e)
		}

		function zn(t) {
			this.camera = t,
				this.bias = 0,
				this.radius = 1,
				this.mapSize = new n(512, 512),
				this.map = null,
				this.matrix = new c
		}

		function Nn() {
			zn.call(this, new It(50, 1, .5, 500))
		}

		function kn(t, e, n, i, r, o) {
			Bn.call(this, t, e),
				this.type = "SpotLight",
				this.position.copy(lt.DefaultUp),
				this.updateMatrix(),
				this.target = new lt,
				Object.defineProperty(this, "power", {
					get: function() {
						return this.intensity * Math.PI
					},
					set: function(t) {
						this.intensity = t / Math.PI
					}
				}),
				this.distance = void 0 !== n ? n : 0,
				this.angle = void 0 !== i ? i : Math.PI / 3,
				this.penumbra = void 0 !== r ? r : 0,
				this.decay = void 0 !== o ? o : 1,
				this.shadow = new Nn
		}

		function Un(t, e, n, i) {
			Bn.call(this, t, e),
				this.type = "PointLight",
				Object.defineProperty(this, "power", {
					get: function() {
						return 4 * this.intensity * Math.PI
					},
					set: function(t) {
						this.intensity = t / (4 * Math.PI)
					}
				}),
				this.distance = void 0 !== n ? n : 0,
				this.decay = void 0 !== i ? i : 1,
				this.shadow = new zn(new It(90, 1, .5, 500))
		}

		function jn() {
			zn.call(this, new Dt(-5, 5, 5, -5, .5, 500))
		}

		function Vn(t, e) {
			Bn.call(this, t, e),
				this.type = "DirectionalLight",
				this.position.copy(lt.DefaultUp),
				this.updateMatrix(),
				this.target = new lt,
				this.shadow = new jn
		}

		function Gn(t, e) {
			Bn.call(this, t, e),
				this.type = "AmbientLight",
				this.castShadow = void 0
		}

		function Hn(t, e, n, i) {
			Bn.call(this, t, e),
				this.type = "RectAreaLight",
				this.position.set(0, 1, 0),
				this.updateMatrix(),
				this.width = void 0 !== n ? n : 10,
				this.height = void 0 !== i ? i : 10
		}

		function Wn(t, e, n, i) {
			this.parameterPositions = t,
				this._cachedIndex = 0,
				this.resultBuffer = void 0 !== i ? i : new e.constructor(n),
				this.sampleValues = e,
				this.valueSize = n
		}

		function Yn(t, e, n, i) {
			Wn.call(this, t, e, n, i),
				this._weightPrev = -0,
				this._offsetPrev = -0,
				this._weightNext = -0,
				this._offsetNext = -0
		}

		function qn(t, e, n, i) {
			Wn.call(this, t, e, n, i)
		}

		function Zn(t, e, n, i) {
			Wn.call(this, t, e, n, i)
		}

		function Qn(t, e, n, i) {
			if(void 0 === t)
				throw new Error("track name is undefined");
			if(void 0 === e || 0 === e.length)
				throw new Error("no keyframes in track named " + t);
			this.name = t,
				this.times = Wc.convertArray(e, this.TimeBufferType),
				this.values = Wc.convertArray(n, this.ValueBufferType),
				this.setInterpolation(i || this.DefaultInterpolation),
				this.validate(),
				this.optimize()
		}

		function Jn(t, e, n, i) {
			Qn.call(this, t, e, n, i)
		}

		function Kn(t, e, n, i) {
			Wn.call(this, t, e, n, i)
		}

		function $n(t, e, n, i) {
			Qn.call(this, t, e, n, i)
		}

		function ti(t, e, n, i) {
			Qn.call(this, t, e, n, i)
		}

		function ei(t, e, n, i) {
			Qn.call(this, t, e, n, i)
		}

		function ni(t, e, n) {
			Qn.call(this, t, e, n)
		}

		function ii(t, e, n, i) {
			Qn.call(this, t, e, n, i)
		}

		function ri(t, e, n, i) {
			Qn.apply(this, arguments)
		}

		function oi(t, e, n) {
			this.name = t,
				this.tracks = n,
				this.duration = void 0 !== e ? e : -1,
				this.uuid = xs.generateUUID(),
				this.duration < 0 && this.resetDuration(),
				this.optimize()
		}

		function ai(t) {
			this.manager = void 0 !== t ? t : Hc,
				this.textures = {}
		}

		function si(t) {
			this.manager = void 0 !== t ? t : Hc
		}

		function li() {
			this.onLoadStart = function() {},
				this.onLoadProgress = function() {},
				this.onLoadComplete = function() {}
		}

		function ci(t) {
			"boolean" == typeof t && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."),
					t = void 0),
				this.manager = void 0 !== t ? t : Hc,
				this.withCredentials = !1
		}

		function ui(t) {
			this.manager = void 0 !== t ? t : Hc,
				this.texturePath = ""
		}

		function hi(t, e, n, i, r) {
			var o = .5 * (i - e),
				a = .5 * (r - n),
				s = t * t,
				l = t * s;
			return(2 * n - 2 * i + o + a) * l + (-3 * n + 3 * i - 2 * o - a) * s + o * t + n
		}

		function di(t, e) {
			var n = 1 - t;
			return n * n * e
		}

		function fi(t, e) {
			return 2 * (1 - t) * t * e
		}

		function pi(t, e) {
			return t * t * e
		}

		function mi(t, e, n, i) {
			return di(t, e) + fi(t, n) + pi(t, i)
		}

		function vi(t, e) {
			var n = 1 - t;
			return n * n * n * e
		}

		function gi(t, e) {
			var n = 1 - t;
			return 3 * n * n * t * e
		}

		function _i(t, e) {
			return 3 * (1 - t) * t * t * e
		}

		function yi(t, e) {
			return t * t * t * e
		}

		function bi(t, e, n, i, r) {
			return vi(t, e) + gi(t, n) + _i(t, i) + yi(t, r)
		}

		function xi() {
			this.arcLengthDivisions = 200
		}

		function wi(t, e) {
			xi.call(this),
				this.v1 = t,
				this.v2 = e
		}

		function Ti() {
			xi.call(this),
				this.curves = [],
				this.autoClose = !1
		}

		function Mi(t, e, n, i, r, o, a, s) {
			xi.call(this),
				this.aX = t,
				this.aY = e,
				this.xRadius = n,
				this.yRadius = i,
				this.aStartAngle = r,
				this.aEndAngle = o,
				this.aClockwise = a,
				this.aRotation = s || 0
		}

		function Ei(t) {
			xi.call(this),
				this.points = void 0 === t ? [] : t
		}

		function Si(t, e, n, i) {
			xi.call(this),
				this.v0 = t,
				this.v1 = e,
				this.v2 = n,
				this.v3 = i
		}

		function Xi(t, e, n) {
			xi.call(this),
				this.v0 = t,
				this.v1 = e,
				this.v2 = n
		}

		function Ai(t) {
			Ti.call(this),
				this.currentPoint = new n,
				t && this.fromPoints(t)
		}

		function Pi() {
			Ai.apply(this, arguments),
				this.holes = []
		}

		function Ri() {
			this.subPaths = [],
				this.currentPath = null
		}

		function Oi(t) {
			this.data = t
		}

		function Ci(t) {
			this.manager = void 0 !== t ? t : Hc
		}

		function Li(t) {
			this.manager = void 0 !== t ? t : Hc
		}

		function Ii() {
			this.type = "StereoCamera",
				this.aspect = 1,
				this.eyeSep = .064,
				this.cameraL = new It,
				this.cameraL.layers.enable(1),
				this.cameraL.matrixAutoUpdate = !1,
				this.cameraR = new It,
				this.cameraR.layers.enable(2),
				this.cameraR.matrixAutoUpdate = !1
		}

		function Di(t, e, n) {
			lt.call(this),
				this.type = "CubeCamera";
			var i = 90,
				r = 1,
				o = new It(i, r, t, e);
			o.up.set(0, -1, 0),
				o.lookAt(new l(1, 0, 0)),
				this.add(o);
			var s = new It(i, r, t, e);
			s.up.set(0, -1, 0),
				s.lookAt(new l(-1, 0, 0)),
				this.add(s);
			var c = new It(i, r, t, e);
			c.up.set(0, 0, 1),
				c.lookAt(new l(0, 1, 0)),
				this.add(c);
			var u = new It(i, r, t, e);
			u.up.set(0, 0, -1),
				u.lookAt(new l(0, -1, 0)),
				this.add(u);
			var h = new It(i, r, t, e);
			h.up.set(0, -1, 0),
				h.lookAt(new l(0, 0, 1)),
				this.add(h);
			var d = new It(i, r, t, e);
			d.up.set(0, -1, 0),
				d.lookAt(new l(0, 0, -1)),
				this.add(d);
			var f = {
				format: Fa,
				magFilter: xa,
				minFilter: xa
			};
			this.renderTarget = new a(n, n, f),
				this.renderTarget.texture.name = "CubeCamera",
				this.updateCubeMap = function(t, e) {
					null === this.parent && this.updateMatrixWorld();
					var n = this.renderTarget,
						i = n.texture.generateMipmaps;
					n.texture.generateMipmaps = !1,
						n.activeCubeFace = 0,
						t.render(e, o, n),
						n.activeCubeFace = 1,
						t.render(e, s, n),
						n.activeCubeFace = 2,
						t.render(e, c, n),
						n.activeCubeFace = 3,
						t.render(e, u, n),
						n.activeCubeFace = 4,
						t.render(e, h, n),
						n.texture.generateMipmaps = i,
						n.activeCubeFace = 5,
						t.render(e, d, n),
						t.setRenderTarget(null)
				}
		}

		function Bi(t) {
			It.call(this),
				this.enabled = !1,
				this.cameras = t || []
		}

		function Fi() {
			lt.call(this),
				this.type = "AudioListener",
				this.context = tu.getContext(),
				this.gain = this.context.createGain(),
				this.gain.connect(this.context.destination),
				this.filter = null
		}

		function zi(t) {
			lt.call(this),
				this.type = "Audio",
				this.context = t.context,
				this.gain = this.context.createGain(),
				this.gain.connect(t.getInput()),
				this.autoplay = !1,
				this.buffer = null,
				this.loop = !1,
				this.startTime = 0,
				this.playbackRate = 1,
				this.isPlaying = !1,
				this.hasPlaybackControl = !0,
				this.sourceType = "empty",
				this.filters = []
		}

		function Ni(t) {
			zi.call(this, t),
				this.panner = this.context.createPanner(),
				this.panner.connect(this.gain)
		}

		function ki(t, e) {
			this.analyser = t.context.createAnalyser(),
				this.analyser.fftSize = void 0 !== e ? e : 2048,
				this.data = new Uint8Array(this.analyser.frequencyBinCount),
				t.getOutput().connect(this.analyser)
		}

		function Ui(t, e, n) {
			this.binding = t,
				this.valueSize = n;
			var i, r = Float64Array;
			switch(e) {
				case "quaternion":
					i = this._slerp;
					break;
				case "string":
				case "bool":
					r = Array,
						i = this._select;
					break;
				default:
					i = this._lerp
			}
			this.buffer = new r(4 * n),
				this._mixBufferRegion = i,
				this.cumulativeWeight = 0,
				this.useCount = 0,
				this.referenceCount = 0
		}

		function ji(t, e, n) {
			var i = n || Vi.parseTrackName(e);
			this._targetGroup = t,
				this._bindings = t.subscribe_(e, i)
		}

		function Vi(t, e, n) {
			this.path = e,
				this.parsedPath = n || Vi.parseTrackName(e),
				this.node = Vi.findNode(t, this.parsedPath.nodeName) || t,
				this.rootNode = t
		}

		function Gi(t) {
			this.uuid = xs.generateUUID(),
				this._objects = Array.prototype.slice.call(arguments),
				this.nCachedObjects_ = 0;
			var e = {};
			this._indicesByUUID = e;
			for(var n = 0, i = arguments.length; n !== i; ++n)
				e[arguments[n].uuid] = n;
			this._paths = [],
				this._parsedPaths = [],
				this._bindings = [],
				this._bindingsIndicesByPath = {};
			var r = this;
			this.stats = {
				objects: {
					get total() {
						return r._objects.length
					},
					get inUse() {
						return this.total - r.nCachedObjects_
					}
				},
				get bindingsPerObject() {
					return r._bindings.length
				}
			}
		}

		function Hi(t, e, n) {
			this._mixer = t,
				this._clip = e,
				this._localRoot = n || null;
			for(var i = e.tracks, r = i.length, o = new Array(r), a = {
					endingStart: os,
					endingEnd: os
				}, s = 0; s !== r; ++s) {
				var l = i[s].createInterpolant(null);
				o[s] = l,
					l.settings = a
			}
			this._interpolantSettings = a,
				this._interpolants = o,
				this._propertyBindings = new Array(r),
				this._cacheIndex = null,
				this._byClipCacheIndex = null,
				this._timeScaleInterpolant = null,
				this._weightInterpolant = null,
				this.loop = ts,
				this._loopCount = -1,
				this._startTime = null,
				this.time = 0,
				this.timeScale = 1,
				this._effectiveTimeScale = 1,
				this.weight = 1,
				this._effectiveWeight = 1,
				this.repetitions = 1 / 0,
				this.paused = !1,
				this.enabled = !0,
				this.clampWhenFinished = !1,
				this.zeroSlopeAtStart = !0,
				this.zeroSlopeAtEnd = !0
		}

		function Wi(t) {
			this._root = t,
				this._initMemoryManager(),
				this._accuIndex = 0,
				this.time = 0,
				this.timeScale = 1
		}

		function Yi(t) {
			"string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
					t = arguments[1]),
				this.value = t
		}

		function qi() {
			Xt.call(this),
				this.type = "InstancedBufferGeometry",
				this.maxInstancedCount = void 0
		}

		function Zi(t, e, n, i) {
			this.uuid = xs.generateUUID(),
				this.data = t,
				this.itemSize = e,
				this.offset = n,
				this.normalized = i === !0
		}

		function Qi(t, e) {
			this.uuid = xs.generateUUID(),
				this.array = t,
				this.stride = e,
				this.count = void 0 !== t ? t.length / e : 0,
				this.dynamic = !1,
				this.updateRange = {
					offset: 0,
					count: -1
				},
				this.onUploadCallback = function() {},
				this.version = 0
		}

		function Ji(t, e, n) {
			Qi.call(this, t, e),
				this.meshPerAttribute = n || 1
		}

		function Ki(t, e, n) {
			ft.call(this, t, e),
				this.meshPerAttribute = n || 1
		}

		function $i(t, e, n, i) {
			this.ray = new ot(t, e),
				this.near = n || 0,
				this.far = i || 1 / 0,
				this.params = {
					Mesh: {},
					Line: {},
					LOD: {},
					Points: {
						threshold: 1
					},
					Sprite: {}
				},
				Object.defineProperties(this.params, {
					PointCloud: {
						get: function() {
							return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
								this.Points
						}
					}
				})
		}

		function tr(t, e) {
			return t.distance - e.distance
		}

		function er(t, e, n, i) {
			if(t.visible !== !1 && (t.raycast(e, n),
					i === !0))
				for(var r = t.children, o = 0, a = r.length; o < a; o++)
					er(r[o], e, n, !0)
		}

		function nr(t) {
			this.autoStart = void 0 === t || t,
				this.startTime = 0,
				this.oldTime = 0,
				this.elapsedTime = 0,
				this.running = !1
		}

		function ir(t, e, n) {
			return this.radius = void 0 !== t ? t : 1,
				this.phi = void 0 !== e ? e : 0,
				this.theta = void 0 !== n ? n : 0,
				this
		}

		function rr(t, e, n) {
			return this.radius = void 0 !== t ? t : 1,
				this.theta = void 0 !== e ? e : 0,
				this.y = void 0 !== n ? n : 0,
				this
		}

		function or(t, e) {
			At.call(this, t, e),
				this.animationsMap = {},
				this.animationsList = [];
			var n = this.geometry.morphTargets.length,
				i = "__default",
				r = 0,
				o = n - 1,
				a = n / 1;
			this.createAnimation(i, r, o, a),
				this.setAnimationWeight(i, 1)
		}

		function ar(t) {
			lt.call(this),
				this.material = t,
				this.render = function(t) {}
		}

		function sr(t, e, n, i) {
			this.object = t,
				this.size = void 0 !== e ? e : 1;
			var r = void 0 !== n ? n : 16711680,
				o = void 0 !== i ? i : 1,
				a = 0,
				s = this.object.geometry;
			s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
			var l = new Xt,
				c = new xt(2 * a * 3, 3);
			l.addAttribute("position", c),
				Se.call(this, l, new Me({
					color: r,
					linewidth: o
				})),
				this.matrixAutoUpdate = !1,
				this.update()
		}

		function lr(t) {
			lt.call(this),
				this.light = t,
				this.light.updateMatrixWorld(),
				this.matrix = t.matrixWorld,
				this.matrixAutoUpdate = !1;
			for(var e = new Xt, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, r = 1, o = 32; i < o; i++,
				r++) {
				var a = i / o * Math.PI * 2,
					s = r / o * Math.PI * 2;
				n.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
			}
			e.addAttribute("position", new xt(n, 3));
			var l = new Me({
				fog: !1
			});
			this.cone = new Se(e, l),
				this.add(this.cone),
				this.update()
		}

		function cr(t) {
			this.bones = this.getBoneList(t);
			for(var e = new Xt, n = [], i = [], r = new W(0, 0, 1), o = new W(0, 1, 0), a = 0; a < this.bones.length; a++) {
				var s = this.bones[a];
				s.parent && s.parent.isBone && (n.push(0, 0, 0),
					n.push(0, 0, 0),
					i.push(r.r, r.g, r.b),
					i.push(o.r, o.g, o.b))
			}
			e.addAttribute("position", new xt(n, 3)),
				e.addAttribute("color", new xt(i, 3));
			var l = new Me({
				vertexColors: wo,
				depthTest: !1,
				depthWrite: !1,
				transparent: !0
			});
			Se.call(this, e, l),
				this.root = t,
				this.matrix = t.matrixWorld,
				this.matrixAutoUpdate = !1,
				this.update()
		}

		function ur(t, e) {
			this.light = t,
				this.light.updateMatrixWorld();
			var n = new an(e, 4, 2),
				i = new dt({
					wireframe: !0,
					fog: !1
				});
			i.color.copy(this.light.color),
				At.call(this, n, i),
				this.matrix = this.light.matrixWorld,
				this.matrixAutoUpdate = !1
		}

		function hr(t) {
			lt.call(this),
				this.light = t,
				this.light.updateMatrixWorld(),
				this.matrix = t.matrixWorld,
				this.matrixAutoUpdate = !1;
			var e = new Me({
					color: t.color
				}),
				n = new Xt;
			n.addAttribute("position", new ft(new Float32Array(15), 3)),
				this.add(new Ee(n, e)),
				this.update()
		}

		function dr(t, e) {
			lt.call(this),
				this.light = t,
				this.light.updateMatrixWorld(),
				this.matrix = t.matrixWorld,
				this.matrixAutoUpdate = !1;
			var n = new Ve(e);
			n.rotateY(.5 * Math.PI);
			var i = new dt({
					vertexColors: wo,
					wireframe: !0
				}),
				r = n.getAttribute("position"),
				o = new Float32Array(3 * r.count);
			n.addAttribute("color", new ft(o, 3)),
				this.add(new At(n, i)),
				this.update()
		}

		function fr(t, e, n, i) {
			t = t || 10,
				e = e || 10,
				n = new W(void 0 !== n ? n : 4473924),
				i = new W(void 0 !== i ? i : 8947848);
			for(var r = e / 2, o = t / e, a = t / 2, s = [], l = [], c = 0, u = 0, h = -a; c <= e; c++,
				h += o) {
				s.push(-a, 0, h, a, 0, h),
					s.push(h, 0, -a, h, 0, a);
				var d = c === r ? n : i;
				d.toArray(l, u),
					u += 3,
					d.toArray(l, u),
					u += 3,
					d.toArray(l, u),
					u += 3,
					d.toArray(l, u),
					u += 3
			}
			var f = new Xt;
			f.addAttribute("position", new xt(s, 3)),
				f.addAttribute("color", new xt(l, 3));
			var p = new Me({
				vertexColors: wo
			});
			Se.call(this, f, p)
		}

		function pr(t, e, n, i, r, o) {
			t = t || 10,
				e = e || 16,
				n = n || 8,
				i = i || 64,
				r = new W(void 0 !== r ? r : 4473924),
				o = new W(void 0 !== o ? o : 8947848);
			var a, s, l, c, u, h, d, f = [],
				p = [];
			for(c = 0; c <= e; c++)
				l = c / e * (2 * Math.PI),
				a = Math.sin(l) * t,
				s = Math.cos(l) * t,
				f.push(0, 0, 0),
				f.push(a, 0, s),
				d = 1 & c ? r : o,
				p.push(d.r, d.g, d.b),
				p.push(d.r, d.g, d.b);
			for(c = 0; c <= n; c++)
				for(d = 1 & c ? r : o,
					h = t - t / n * c,
					u = 0; u < i; u++)
					l = u / i * (2 * Math.PI),
					a = Math.sin(l) * h,
					s = Math.cos(l) * h,
					f.push(a, 0, s),
					p.push(d.r, d.g, d.b),
					l = (u + 1) / i * (2 * Math.PI),
					a = Math.sin(l) * h,
					s = Math.cos(l) * h,
					f.push(a, 0, s),
					p.push(d.r, d.g, d.b);
			var m = new Xt;
			m.addAttribute("position", new xt(f, 3)),
				m.addAttribute("color", new xt(p, 3));
			var v = new Me({
				vertexColors: wo
			});
			Se.call(this, m, v)
		}

		function mr(t, e, n, i) {
			this.object = t,
				this.size = void 0 !== e ? e : 1;
			var r = void 0 !== n ? n : 16776960,
				o = void 0 !== i ? i : 1,
				a = 0,
				s = this.object.geometry;
			s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
			var l = new Xt,
				c = new xt(2 * a * 3, 3);
			l.addAttribute("position", c),
				Se.call(this, l, new Me({
					color: r,
					linewidth: o
				})),
				this.matrixAutoUpdate = !1,
				this.update()
		}

		function vr(t, e) {
			lt.call(this),
				this.light = t,
				this.light.updateMatrixWorld(),
				this.matrix = t.matrixWorld,
				this.matrixAutoUpdate = !1,
				void 0 === e && (e = 1);
			var n = new Xt;
			n.addAttribute("position", new xt([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
			var i = new Me({
				fog: !1
			});
			this.add(new Ee(n, i)),
				n = new Xt,
				n.addAttribute("position", new xt([0, 0, 0, 0, 0, 1], 3)),
				this.add(new Ee(n, i)),
				this.update()
		}

		function gr(t) {
			function e(t, e, i) {
				n(t, i),
					n(e, i)
			}

			function n(t, e) {
				o.push(0, 0, 0),
					a.push(e.r, e.g, e.b),
					void 0 === s[t] && (s[t] = []),
					s[t].push(o.length / 3 - 1)
			}
			var i = new Xt,
				r = new Me({
					color: 16777215,
					vertexColors: xo
				}),
				o = [],
				a = [],
				s = {},
				l = new W(16755200),
				c = new W(16711680),
				u = new W(43775),
				h = new W(16777215),
				d = new W(3355443);
			e("n1", "n2", l),
				e("n2", "n4", l),
				e("n4", "n3", l),
				e("n3", "n1", l),
				e("f1", "f2", l),
				e("f2", "f4", l),
				e("f4", "f3", l),
				e("f3", "f1", l),
				e("n1", "f1", l),
				e("n2", "f2", l),
				e("n3", "f3", l),
				e("n4", "f4", l),
				e("p", "n1", c),
				e("p", "n2", c),
				e("p", "n3", c),
				e("p", "n4", c),
				e("u1", "u2", u),
				e("u2", "u3", u),
				e("u3", "u1", u),
				e("c", "t", h),
				e("p", "c", d),
				e("cn1", "cn2", d),
				e("cn3", "cn4", d),
				e("cf1", "cf2", d),
				e("cf3", "cf4", d),
				i.addAttribute("position", new xt(o, 3)),
				i.addAttribute("color", new xt(a, 3)),
				Se.call(this, i, r),
				this.camera = t,
				this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
				this.matrix = t.matrixWorld,
				this.matrixAutoUpdate = !1,
				this.pointMap = s,
				this.update()
		}

		function _r(t, e) {
			this.object = t,
				void 0 === e && (e = 16776960);
			var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
				i = new Float32Array(24),
				r = new Xt;
			r.setIndex(new ft(n, 1)),
				r.addAttribute("position", new ft(i, 3)),
				Se.call(this, r, new Me({
					color: e
				})),
				this.matrixAutoUpdate = !1,
				this.update()
		}

		function yr(t, e, n, i, r, o) {
			lt.call(this),
				void 0 === i && (i = 16776960),
				void 0 === n && (n = 1),
				void 0 === r && (r = .2 * n),
				void 0 === o && (o = .2 * r),
				void 0 === eu && (eu = new Xt,
					eu.addAttribute("position", new xt([0, 0, 0, 0, 1, 0], 3)),
					nu = new mn(0, .5, 1, 5, 1),
					nu.translate(0, -.5, 0)),
				this.position.copy(e),
				this.line = new Ee(eu, new Me({
					color: i
				})),
				this.line.matrixAutoUpdate = !1,
				this.add(this.line),
				this.cone = new At(nu, new dt({
					color: i
				})),
				this.cone.matrixAutoUpdate = !1,
				this.add(this.cone),
				this.setDirection(t),
				this.setLength(n, r, o)
		}

		function br(t) {
			t = t || 1;
			var e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
				n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
				i = new Xt;
			i.addAttribute("position", new xt(e, 3)),
				i.addAttribute("color", new xt(n, 3));
			var r = new Me({
				vertexColors: wo
			});
			Se.call(this, i, r)
		}

		function xr() {
			function t(t, o, a, s) {
				e = t,
					n = a,
					i = -3 * t + 3 * o - 2 * a - s,
					r = 2 * t - 2 * o + a + s
			}
			var e = 0,
				n = 0,
				i = 0,
				r = 0;
			return {
				initCatmullRom: function(e, n, i, r, o) {
					t(n, i, o * (i - e), o * (r - n))
				},
				initNonuniformCatmullRom: function(e, n, i, r, o, a, s) {
					var l = (n - e) / o - (i - e) / (o + a) + (i - n) / a,
						c = (i - n) / a - (r - n) / (a + s) + (r - i) / s;
					l *= a,
						c *= a,
						t(n, i, l, c)
				},
				calc: function(t) {
					var o = t * t,
						a = o * t;
					return e + n * t + i * o + r * a
				}
			}
		}

		function wr(t) {
			xi.call(this),
				this.points = t || [],
				this.closed = !1
		}

		function Tr(t, e, n, i) {
			xi.call(this),
				this.v0 = t,
				this.v1 = e,
				this.v2 = n,
				this.v3 = i
		}

		function Mr(t, e, n) {
			xi.call(this),
				this.v0 = t,
				this.v1 = e,
				this.v2 = n
		}

		function Er(t, e) {
			xi.call(this),
				this.v1 = t,
				this.v2 = e
		}

		function Sr(t, e, n, i, r, o) {
			Mi.call(this, t, e, n, n, i, r, o)
		}

		function Xr(t, e, n, i, r, o, a) {
			return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),
				new ht(t, e, n, r, o, a)
		}

		function Ar(t) {
			return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),
				t
		}

		function Pr(t) {
			return void 0 === t && (t = []),
				console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),
				t.isMultiMaterial = !0,
				t.materials = t,
				t.clone = function() {
					return t.slice()
				},
				t
		}

		function Rr(t, e) {
			return console.warn("THREE.PointCloud has been renamed to THREE.Points."),
				new Pe(t, e)
		}

		function Or(t) {
			return console.warn("THREE.Particle has been renamed to THREE.Sprite."),
				new ye(t)
		}

		function Cr(t, e) {
			return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),
				new Pe(t, e)
		}

		function Lr(t) {
			return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),
				new Ae(t)
		}

		function Ir(t) {
			return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),
				new Ae(t)
		}

		function Dr(t) {
			return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),
				new Ae(t)
		}

		function Br(t, e, n) {
			return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),
				new l(t, e, n)
		}

		function Fr(t, e) {
			return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."),
				new ft(t, e).setDynamic(!0)
		}

		function zr(t, e) {
			return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),
				new pt(t, e)
		}

		function Nr(t, e) {
			return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),
				new mt(t, e)
		}

		function kr(t, e) {
			return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),
				new vt(t, e)
		}

		function Ur(t, e) {
			return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),
				new gt(t, e)
		}

		function jr(t, e) {
			return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),
				new _t(t, e)
		}

		function Vr(t, e) {
			return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),
				new yt(t, e)
		}

		function Gr(t, e) {
			return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),
				new bt(t, e)
		}

		function Hr(t, e) {
			return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),
				new xt(t, e)
		}

		function Wr(t, e) {
			return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),
				new wt(t, e)
		}

		function Yr(t) {
			console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
				wr.call(this, t),
				this.type = "catmullrom",
				this.closed = !0
		}

		function qr(t) {
			console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
				wr.call(this, t),
				this.type = "catmullrom"
		}

		function Zr(t) {
			console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),
				wr.call(this, t),
				this.type = "catmullrom"
		}

		function Qr(t, e) {
			return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),
				new _r(t, e)
		}

		function Jr(t, e) {
			return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),
				new Se(new fn(t.geometry), new Me({
					color: void 0 !== e ? e : 16777215
				}))
		}

		function Kr(t, e) {
			return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),
				new Se(new De(t.geometry), new Me({
					color: void 0 !== e ? e : 16777215
				}))
		}

		function $r(t) {
			return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),
				new Rn(t)
		}

		function to(t) {
			return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),
				new Cn(t)
		}

		function eo() {
			console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."),
				this.projectVector = function(t, e) {
					console.warn("THREE.Projector: .projectVector() is now vector.project()."),
						t.project(e)
				},
				this.unprojectVector = function(t, e) {
					console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."),
						t.unproject(e)
				},
				this.pickingRay = function() {
					console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
				}
		}

		function no() {
			console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"),
				this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
				this.clear = function() {},
				this.render = function() {},
				this.setClearColor = function() {},
				this.setSize = function() {}
		}
		void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
			void 0 === Number.isInteger && (Number.isInteger = function(t) {
				return "number" == typeof t && isFinite(t) && Math.floor(t) === t
			}),
			void 0 === Math.sign && (Math.sign = function(t) {
				return t < 0 ? -1 : t > 0 ? 1 : +t
			}),
			void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
				get: function() {
					return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
				}
			}),
			void 0 === Object.assign && ! function() {
				Object.assign = function(t) {
					if(void 0 === t || null === t)
						throw new TypeError("Cannot convert undefined or null to object");
					for(var e = Object(t), n = 1; n < arguments.length; n++) {
						var i = arguments[n];
						if(void 0 !== i && null !== i)
							for(var r in i)
								Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r])
					}
					return e
				}
			}(),
			Object.assign(e.prototype, {
				addEventListener: function(t, e) {
					void 0 === this._listeners && (this._listeners = {});
					var n = this._listeners;
					void 0 === n[t] && (n[t] = []),
						n[t].indexOf(e) === -1 && n[t].push(e)
				},
				hasEventListener: function(t, e) {
					if(void 0 === this._listeners)
						return !1;
					var n = this._listeners;
					return void 0 !== n[t] && n[t].indexOf(e) !== -1
				},
				removeEventListener: function(t, e) {
					if(void 0 !== this._listeners) {
						var n = this._listeners,
							i = n[t];
						if(void 0 !== i) {
							var r = i.indexOf(e);
							r !== -1 && i.splice(r, 1)
						}
					}
				},
				dispatchEvent: function(t) {
					if(void 0 !== this._listeners) {
						var e = this._listeners,
							n = e[t.type];
						if(void 0 !== n) {
							t.target = this;
							var i = [],
								r = 0,
								o = n.length;
							for(r = 0; r < o; r++)
								i[r] = n[r];
							for(r = 0; r < o; r++)
								i[r].call(this, t)
						}
					}
				}
			});
		var io = "85",
			ro = {
				LEFT: 0,
				MIDDLE: 1,
				RIGHT: 2
			},
			oo = 0,
			ao = 1,
			so = 2,
			lo = 3,
			co = 0,
			uo = 1,
			ho = 0,
			fo = 1,
			po = 2,
			mo = 0,
			vo = 1,
			go = 2,
			_o = 1,
			yo = 2,
			bo = 0,
			xo = 1,
			wo = 2,
			To = 0,
			Mo = 1,
			Eo = 2,
			So = 3,
			Xo = 4,
			Ao = 5,
			Po = 100,
			Ro = 101,
			Oo = 102,
			Co = 103,
			Lo = 104,
			Io = 200,
			Do = 201,
			Bo = 202,
			Fo = 203,
			zo = 204,
			No = 205,
			ko = 206,
			Uo = 207,
			jo = 208,
			Vo = 209,
			Go = 210,
			Ho = 0,
			Wo = 1,
			Yo = 2,
			qo = 3,
			Zo = 4,
			Qo = 5,
			Jo = 6,
			Ko = 7,
			$o = 0,
			ta = 1,
			ea = 2,
			na = 0,
			ia = 1,
			ra = 2,
			oa = 3,
			aa = 4,
			sa = 300,
			la = 301,
			ca = 302,
			ua = 303,
			ha = 304,
			da = 305,
			fa = 306,
			pa = 307,
			ma = 1e3,
			va = 1001,
			ga = 1002,
			_a = 1003,
			ya = 1004,
			ba = 1005,
			xa = 1006,
			wa = 1007,
			Ta = 1008,
			Ma = 1009,
			Ea = 1010,
			Sa = 1011,
			Xa = 1012,
			Aa = 1013,
			Pa = 1014,
			Ra = 1015,
			Oa = 1016,
			Ca = 1017,
			La = 1018,
			Ia = 1019,
			Da = 1020,
			Ba = 1021,
			Fa = 1022,
			za = 1023,
			Na = 1024,
			ka = 1025,
			Ua = za,
			ja = 1026,
			Va = 1027,
			Ga = 2001,
			Ha = 2002,
			Wa = 2003,
			Ya = 2004,
			qa = 2100,
			Za = 2101,
			Qa = 2102,
			Ja = 2103,
			Ka = 2151,
			$a = 2200,
			ts = 2201,
			es = 2202,
			ns = 2300,
			is = 2301,
			rs = 2302,
			os = 2400,
			as = 2401,
			ss = 2402,
			ls = 0,
			cs = 1,
			us = 2,
			hs = 3e3,
			ds = 3001,
			fs = 3007,
			ps = 3002,
			ms = 3003,
			vs = 3004,
			gs = 3005,
			_s = 3006,
			ys = 3200,
			bs = 3201,
			xs = {
				DEG2RAD: Math.PI / 180,
				RAD2DEG: 180 / Math.PI,
				generateUUID: function() {
					var t, e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
						n = new Array(36),
						i = 0;
					return function() {
						for(var r = 0; r < 36; r++)
							8 === r || 13 === r || 18 === r || 23 === r ? n[r] = "-" : 14 === r ? n[r] = "4" : (i <= 2 && (i = 33554432 + 16777216 * Math.random() | 0),
								t = 15 & i,
								i >>= 4,
								n[r] = e[19 === r ? 3 & t | 8 : t]);
						return n.join("")
					}
				}(),
				clamp: function(t, e, n) {
					return Math.max(e, Math.min(n, t))
				},
				euclideanModulo: function(t, e) {
					return(t % e + e) % e
				},
				mapLinear: function(t, e, n, i, r) {
					return i + (t - e) * (r - i) / (n - e)
				},
				lerp: function(t, e, n) {
					return(1 - n) * t + n * e
				},
				smoothstep: function(t, e, n) {
					return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e),
						t * t * (3 - 2 * t))
				},
				smootherstep: function(t, e, n) {
					return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e),
						t * t * t * (t * (6 * t - 15) + 10))
				},
				randInt: function(t, e) {
					return t + Math.floor(Math.random() * (e - t + 1))
				},
				randFloat: function(t, e) {
					return t + Math.random() * (e - t)
				},
				randFloatSpread: function(t) {
					return t * (.5 - Math.random())
				},
				degToRad: function(t) {
					return t * xs.DEG2RAD
				},
				radToDeg: function(t) {
					return t * xs.RAD2DEG
				},
				isPowerOfTwo: function(t) {
					return 0 === (t & t - 1) && 0 !== t
				},
				nearestPowerOfTwo: function(t) {
					return Math.pow(2, Math.round(Math.log(t) / Math.LN2))
				},
				nextPowerOfTwo: function(t) {
					return t--,
						t |= t >> 1,
						t |= t >> 2,
						t |= t >> 4,
						t |= t >> 8,
						t |= t >> 16,
						t++,
						t
				}
			};
		Object.defineProperties(n.prototype, {
				width: {
					get: function() {
						return this.x
					},
					set: function(t) {
						this.x = t
					}
				},
				height: {
					get: function() {
						return this.y
					},
					set: function(t) {
						this.y = t
					}
				}
			}),
			Object.assign(n.prototype, {
				isVector2: !0,
				set: function(t, e) {
					return this.x = t,
						this.y = e,
						this
				},
				setScalar: function(t) {
					return this.x = t,
						this.y = t,
						this
				},
				setX: function(t) {
					return this.x = t,
						this
				},
				setY: function(t) {
					return this.y = t,
						this
				},
				setComponent: function(t, e) {
					switch(t) {
						case 0:
							this.x = e;
							break;
						case 1:
							this.y = e;
							break;
						default:
							throw new Error("index is out of range: " + t)
					}
					return this
				},
				getComponent: function(t) {
					switch(t) {
						case 0:
							return this.x;
						case 1:
							return this.y;
						default:
							throw new Error("index is out of range: " + t)
					}
				},
				clone: function() {
					return new this.constructor(this.x, this.y)
				},
				copy: function(t) {
					return this.x = t.x,
						this.y = t.y,
						this
				},
				add: function(t, e) {
					return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
						this.addVectors(t, e)) : (this.x += t.x,
						this.y += t.y,
						this)
				},
				addScalar: function(t) {
					return this.x += t,
						this.y += t,
						this
				},
				addVectors: function(t, e) {
					return this.x = t.x + e.x,
						this.y = t.y + e.y,
						this
				},
				addScaledVector: function(t, e) {
					return this.x += t.x * e,
						this.y += t.y * e,
						this
				},
				sub: function(t, e) {
					return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
						this.subVectors(t, e)) : (this.x -= t.x,
						this.y -= t.y,
						this)
				},
				subScalar: function(t) {
					return this.x -= t,
						this.y -= t,
						this
				},
				subVectors: function(t, e) {
					return this.x = t.x - e.x,
						this.y = t.y - e.y,
						this
				},
				multiply: function(t) {
					return this.x *= t.x,
						this.y *= t.y,
						this
				},
				multiplyScalar: function(t) {
					return this.x *= t,
						this.y *= t,
						this
				},
				divide: function(t) {
					return this.x /= t.x,
						this.y /= t.y,
						this
				},
				divideScalar: function(t) {
					return this.multiplyScalar(1 / t)
				},
				min: function(t) {
					return this.x = Math.min(this.x, t.x),
						this.y = Math.min(this.y, t.y),
						this
				},
				max: function(t) {
					return this.x = Math.max(this.x, t.x),
						this.y = Math.max(this.y, t.y),
						this
				},
				clamp: function(t, e) {
					return this.x = Math.max(t.x, Math.min(e.x, this.x)),
						this.y = Math.max(t.y, Math.min(e.y, this.y)),
						this
				},
				clampScalar: function() {
					var t = new n,
						e = new n;
					return function(n, i) {
						return t.set(n, n),
							e.set(i, i),
							this.clamp(t, e)
					}
				}(),
				clampLength: function(t, e) {
					var n = this.length();
					return this.multiplyScalar(Math.max(t, Math.min(e, n)) / n)
				},
				floor: function() {
					return this.x = Math.floor(this.x),
						this.y = Math.floor(this.y),
						this
				},
				ceil: function() {
					return this.x = Math.ceil(this.x),
						this.y = Math.ceil(this.y),
						this
				},
				round: function() {
					return this.x = Math.round(this.x),
						this.y = Math.round(this.y),
						this
				},
				roundToZero: function() {
					return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
						this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
						this
				},
				negate: function() {
					return this.x = -this.x,
						this.y = -this.y,
						this
				},
				dot: function(t) {
					return this.x * t.x + this.y * t.y
				},
				lengthSq: function() {
					return this.x * this.x + this.y * this.y
				},
				length: function() {
					return Math.sqrt(this.x * this.x + this.y * this.y)
				},
				lengthManhattan: function() {
					return Math.abs(this.x) + Math.abs(this.y)
				},
				normalize: function() {
					return this.divideScalar(this.length())
				},
				angle: function() {
					var t = Math.atan2(this.y, this.x);
					return t < 0 && (t += 2 * Math.PI),
						t
				},
				distanceTo: function(t) {
					return Math.sqrt(this.distanceToSquared(t))
				},
				distanceToSquared: function(t) {
					var e = this.x - t.x,
						n = this.y - t.y;
					return e * e + n * n
				},
				distanceToManhattan: function(t) {
					return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
				},
				setLength: function(t) {
					return this.multiplyScalar(t / this.length())
				},
				lerp: function(t, e) {
					return this.x += (t.x - this.x) * e,
						this.y += (t.y - this.y) * e,
						this
				},
				lerpVectors: function(t, e, n) {
					return this.subVectors(e, t).multiplyScalar(n).add(t)
				},
				equals: function(t) {
					return t.x === this.x && t.y === this.y
				},
				fromArray: function(t, e) {
					return void 0 === e && (e = 0),
						this.x = t[e],
						this.y = t[e + 1],
						this
				},
				toArray: function(t, e) {
					return void 0 === t && (t = []),
						void 0 === e && (e = 0),
						t[e] = this.x,
						t[e + 1] = this.y,
						t
				},
				fromBufferAttribute: function(t, e, n) {
					return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
						this.x = t.getX(e),
						this.y = t.getY(e),
						this
				},
				rotateAround: function(t, e) {
					var n = Math.cos(e),
						i = Math.sin(e),
						r = this.x - t.x,
						o = this.y - t.y;
					return this.x = r * n - o * i + t.x,
						this.y = r * i + o * n + t.y,
						this
				}
			});
		var ws = 0;
		i.DEFAULT_IMAGE = void 0,
			i.DEFAULT_MAPPING = sa,
			Object.defineProperty(i.prototype, "needsUpdate", {
				set: function(t) {
					t === !0 && this.version++
				}
			}),
			Object.assign(i.prototype, e.prototype, {
				constructor: i,
				isTexture: !0,
				clone: function() {
					return(new this.constructor).copy(this)
				},
				copy: function(t) {
					return this.name = t.name,
						this.image = t.image,
						this.mipmaps = t.mipmaps.slice(0),
						this.mapping = t.mapping,
						this.wrapS = t.wrapS,
						this.wrapT = t.wrapT,
						this.magFilter = t.magFilter,
						this.minFilter = t.minFilter,
						this.anisotropy = t.anisotropy,
						this.format = t.format,
						this.type = t.type,
						this.offset.copy(t.offset),
						this.repeat.copy(t.repeat),
						this.generateMipmaps = t.generateMipmaps,
						this.premultiplyAlpha = t.premultiplyAlpha,
						this.flipY = t.flipY,
						this.unpackAlignment = t.unpackAlignment,
						this.encoding = t.encoding,
						this
				},
				toJSON: function(t) {
					function e(t) {
						var e;
						return void 0 !== t.toDataURL ? e = t : (e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
								e.width = t.width,
								e.height = t.height,
								e.getContext("2d").drawImage(t, 0, 0, t.width, t.height)),
							e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
					}
					if(void 0 !== t.textures[this.uuid])
						return t.textures[this.uuid];
					var n = {
						metadata: {
							version: 4.5,
							type: "Texture",
							generator: "Texture.toJSON"
						},
						uuid: this.uuid,
						name: this.name,
						mapping: this.mapping,
						repeat: [this.repeat.x, this.repeat.y],
						offset: [this.offset.x, this.offset.y],
						wrap: [this.wrapS, this.wrapT],
						minFilter: this.minFilter,
						magFilter: this.magFilter,
						anisotropy: this.anisotropy,
						flipY: this.flipY
					};
					if(void 0 !== this.image) {
						var i = this.image;
						void 0 === i.uuid && (i.uuid = xs.generateUUID()),
							void 0 === t.images[i.uuid] && (t.images[i.uuid] = {
								uuid: i.uuid,
								url: e(i)
							}),
							n.image = i.uuid
					}
					return t.textures[this.uuid] = n,
						n
				},
				dispose: function() {
					this.dispatchEvent({
						type: "dispose"
					})
				},
				transformUv: function(t) {
					if(this.mapping === sa) {
						if(t.multiply(this.repeat),
							t.add(this.offset),
							t.x < 0 || t.x > 1)
							switch(this.wrapS) {
								case ma:
									t.x = t.x - Math.floor(t.x);
									break;
								case va:
									t.x = t.x < 0 ? 0 : 1;
									break;
								case ga:
									1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
							}
						if(t.y < 0 || t.y > 1)
							switch(this.wrapT) {
								case ma:
									t.y = t.y - Math.floor(t.y);
									break;
								case va:
									t.y = t.y < 0 ? 0 : 1;
									break;
								case ga:
									1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
							}
						this.flipY && (t.y = 1 - t.y)
					}
				}
			}),
			Object.assign(r.prototype, {
				isVector4: !0,
				set: function(t, e, n, i) {
					return this.x = t,
						this.y = e,
						this.z = n,
						this.w = i,
						this
				},
				setScalar: function(t) {
					return this.x = t,
						this.y = t,
						this.z = t,
						this.w = t,
						this
				},
				setX: function(t) {
					return this.x = t,
						this
				},
				setY: function(t) {
					return this.y = t,
						this
				},
				setZ: function(t) {
					return this.z = t,
						this
				},
				setW: function(t) {
					return this.w = t,
						this
				},
				setComponent: function(t, e) {
					switch(t) {
						case 0:
							this.x = e;
							break;
						case 1:
							this.y = e;
							break;
						case 2:
							this.z = e;
							break;
						case 3:
							this.w = e;
							break;
						default:
							throw new Error("index is out of range: " + t)
					}
					return this
				},
				getComponent: function(t) {
					switch(t) {
						case 0:
							return this.x;
						case 1:
							return this.y;
						case 2:
							return this.z;
						case 3:
							return this.w;
						default:
							throw new Error("index is out of range: " + t)
					}
				},
				clone: function() {
					return new this.constructor(this.x, this.y, this.z, this.w)
				},
				copy: function(t) {
					return this.x = t.x,
						this.y = t.y,
						this.z = t.z,
						this.w = void 0 !== t.w ? t.w : 1,
						this
				},
				add: function(t, e) {
					return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
						this.addVectors(t, e)) : (this.x += t.x,
						this.y += t.y,
						this.z += t.z,
						this.w += t.w,
						this)
				},
				addScalar: function(t) {
					return this.x += t,
						this.y += t,
						this.z += t,
						this.w += t,
						this
				},
				addVectors: function(t, e) {
					return this.x = t.x + e.x,
						this.y = t.y + e.y,
						this.z = t.z + e.z,
						this.w = t.w + e.w,
						this
				},
				addScaledVector: function(t, e) {
					return this.x += t.x * e,
						this.y += t.y * e,
						this.z += t.z * e,
						this.w += t.w * e,
						this
				},
				sub: function(t, e) {
					return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
						this.subVectors(t, e)) : (this.x -= t.x,
						this.y -= t.y,
						this.z -= t.z,
						this.w -= t.w,
						this)
				},
				subScalar: function(t) {
					return this.x -= t,
						this.y -= t,
						this.z -= t,
						this.w -= t,
						this
				},
				subVectors: function(t, e) {
					return this.x = t.x - e.x,
						this.y = t.y - e.y,
						this.z = t.z - e.z,
						this.w = t.w - e.w,
						this
				},
				multiplyScalar: function(t) {
					return this.x *= t,
						this.y *= t,
						this.z *= t,
						this.w *= t,
						this
				},
				applyMatrix4: function(t) {
					var e = this.x,
						n = this.y,
						i = this.z,
						r = this.w,
						o = t.elements;
					return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r,
						this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r,
						this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r,
						this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r,
						this
				},
				divideScalar: function(t) {
					return this.multiplyScalar(1 / t)
				},
				setAxisAngleFromQuaternion: function(t) {
					this.w = 2 * Math.acos(t.w);
					var e = Math.sqrt(1 - t.w * t.w);
					return e < 1e-4 ? (this.x = 1,
							this.y = 0,
							this.z = 0) : (this.x = t.x / e,
							this.y = t.y / e,
							this.z = t.z / e),
						this
				},
				setAxisAngleFromRotationMatrix: function(t) {
					var e, n, i, r, o = .01,
						a = .1,
						s = t.elements,
						l = s[0],
						c = s[4],
						u = s[8],
						h = s[1],
						d = s[5],
						f = s[9],
						p = s[2],
						m = s[6],
						v = s[10];
					if(Math.abs(c - h) < o && Math.abs(u - p) < o && Math.abs(f - m) < o) {
						if(Math.abs(c + h) < a && Math.abs(u + p) < a && Math.abs(f + m) < a && Math.abs(l + d + v - 3) < a)
							return this.set(1, 0, 0, 0),
								this;
						e = Math.PI;
						var g = (l + 1) / 2,
							_ = (d + 1) / 2,
							y = (v + 1) / 2,
							b = (c + h) / 4,
							x = (u + p) / 4,
							w = (f + m) / 4;
						return g > _ && g > y ? g < o ? (n = 0,
								i = .707106781,
								r = .707106781) : (n = Math.sqrt(g),
								i = b / n,
								r = x / n) : _ > y ? _ < o ? (n = .707106781,
								i = 0,
								r = .707106781) : (i = Math.sqrt(_),
								n = b / i,
								r = w / i) : y < o ? (n = .707106781,
								i = .707106781,
								r = 0) : (r = Math.sqrt(y),
								n = x / r,
								i = w / r),
							this.set(n, i, r, e),
							this
					}
					var T = Math.sqrt((m - f) * (m - f) + (u - p) * (u - p) + (h - c) * (h - c));
					return Math.abs(T) < .001 && (T = 1),
						this.x = (m - f) / T,
						this.y = (u - p) / T,
						this.z = (h - c) / T,
						this.w = Math.acos((l + d + v - 1) / 2),
						this
				},
				min: function(t) {
					return this.x = Math.min(this.x, t.x),
						this.y = Math.min(this.y, t.y),
						this.z = Math.min(this.z, t.z),
						this.w = Math.min(this.w, t.w),
						this
				},
				max: function(t) {
					return this.x = Math.max(this.x, t.x),
						this.y = Math.max(this.y, t.y),
						this.z = Math.max(this.z, t.z),
						this.w = Math.max(this.w, t.w),
						this
				},
				clamp: function(t, e) {
					return this.x = Math.max(t.x, Math.min(e.x, this.x)),
						this.y = Math.max(t.y, Math.min(e.y, this.y)),
						this.z = Math.max(t.z, Math.min(e.z, this.z)),
						this.w = Math.max(t.w, Math.min(e.w, this.w)),
						this
				},
				clampScalar: function() {
					var t = new r,
						e = new r;
					return function(n, i) {
						return t.set(n, n, n, n),
							e.set(i, i, i, i),
							this.clamp(t, e)
					}
				}(),
				floor: function() {
					return this.x = Math.floor(this.x),
						this.y = Math.floor(this.y),
						this.z = Math.floor(this.z),
						this.w = Math.floor(this.w),
						this
				},
				ceil: function() {
					return this.x = Math.ceil(this.x),
						this.y = Math.ceil(this.y),
						this.z = Math.ceil(this.z),
						this.w = Math.ceil(this.w),
						this
				},
				round: function() {
					return this.x = Math.round(this.x),
						this.y = Math.round(this.y),
						this.z = Math.round(this.z),
						this.w = Math.round(this.w),
						this
				},
				roundToZero: function() {
					return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
						this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
						this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
						this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
						this
				},
				negate: function() {
					return this.x = -this.x,
						this.y = -this.y,
						this.z = -this.z,
						this.w = -this.w,
						this
				},
				dot: function(t) {
					return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
				},
				lengthSq: function() {
					return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
				},
				length: function() {
					return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
				},
				lengthManhattan: function() {
					return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
				},
				normalize: function() {
					return this.divideScalar(this.length())
				},
				setLength: function(t) {
					return this.multiplyScalar(t / this.length())
				},
				lerp: function(t, e) {
					return this.x += (t.x - this.x) * e,
						this.y += (t.y - this.y) * e,
						this.z += (t.z - this.z) * e,
						this.w += (t.w - this.w) * e,
						this
				},
				lerpVectors: function(t, e, n) {
					return this.subVectors(e, t).multiplyScalar(n).add(t)
				},
				equals: function(t) {
					return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
				},
				fromArray: function(t, e) {
					return void 0 === e && (e = 0),
						this.x = t[e],
						this.y = t[e + 1],
						this.z = t[e + 2],
						this.w = t[e + 3],
						this
				},
				toArray: function(t, e) {
					return void 0 === t && (t = []),
						void 0 === e && (e = 0),
						t[e] = this.x,
						t[e + 1] = this.y,
						t[e + 2] = this.z,
						t[e + 3] = this.w,
						t
				},
				fromBufferAttribute: function(t, e, n) {
					return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
						this.x = t.getX(e),
						this.y = t.getY(e),
						this.z = t.getZ(e),
						this.w = t.getW(e),
						this
				}
			}),
			Object.assign(o.prototype, e.prototype, {
				isWebGLRenderTarget: !0,
				setSize: function(t, e) {
					this.width === t && this.height === e || (this.width = t,
							this.height = e,
							this.dispose()),
						this.viewport.set(0, 0, t, e),
						this.scissor.set(0, 0, t, e)
				},
				clone: function() {
					return(new this.constructor).copy(this)
				},
				copy: function(t) {
					return this.width = t.width,
						this.height = t.height,
						this.viewport.copy(t.viewport),
						this.texture = t.texture.clone(),
						this.depthBuffer = t.depthBuffer,
						this.stencilBuffer = t.stencilBuffer,
						this.depthTexture = t.depthTexture,
						this
				},
				dispose: function() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
			}),
			a.prototype = Object.create(o.prototype),
			a.prototype.constructor = a,
			a.prototype.isWebGLRenderTargetCube = !0,
			Object.assign(s, {
				slerp: function(t, e, n, i) {
					return n.copy(t).slerp(e, i)
				},
				slerpFlat: function(t, e, n, i, r, o, a) {
					var s = n[i + 0],
						l = n[i + 1],
						c = n[i + 2],
						u = n[i + 3],
						h = r[o + 0],
						d = r[o + 1],
						f = r[o + 2],
						p = r[o + 3];
					if(u !== p || s !== h || l !== d || c !== f) {
						var m = 1 - a,
							v = s * h + l * d + c * f + u * p,
							g = v >= 0 ? 1 : -1,
							_ = 1 - v * v;
						if(_ > Number.EPSILON) {
							var y = Math.sqrt(_),
								b = Math.atan2(y, v * g);
							m = Math.sin(m * b) / y,
								a = Math.sin(a * b) / y
						}
						var x = a * g;
						if(s = s * m + h * x,
							l = l * m + d * x,
							c = c * m + f * x,
							u = u * m + p * x,
							m === 1 - a) {
							var w = 1 / Math.sqrt(s * s + l * l + c * c + u * u);
							s *= w,
								l *= w,
								c *= w,
								u *= w
						}
					}
					t[e] = s,
						t[e + 1] = l,
						t[e + 2] = c,
						t[e + 3] = u
				}
			}),
			Object.defineProperties(s.prototype, {
				x: {
					get: function() {
						return this._x
					},
					set: function(t) {
						this._x = t,
							this.onChangeCallback()
					}
				},
				y: {
					get: function() {
						return this._y
					},
					set: function(t) {
						this._y = t,
							this.onChangeCallback()
					}
				},
				z: {
					get: function() {
						return this._z
					},
					set: function(t) {
						this._z = t,
							this.onChangeCallback()
					}
				},
				w: {
					get: function() {
						return this._w
					},
					set: function(t) {
						this._w = t,
							this.onChangeCallback()
					}
				}
			}),
			Object.assign(s.prototype, {
				set: function(t, e, n, i) {
					return this._x = t,
						this._y = e,
						this._z = n,
						this._w = i,
						this.onChangeCallback(),
						this
				},
				clone: function() {
					return new this.constructor(this._x, this._y, this._z, this._w)
				},
				copy: function(t) {
					return this._x = t.x,
						this._y = t.y,
						this._z = t.z,
						this._w = t.w,
						this.onChangeCallback(),
						this
				},
				setFromEuler: function(t, e) {
					if((t && t.isEuler) === !1)
						throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
					var n = t._x,
						i = t._y,
						r = t._z,
						o = t.order,
						a = Math.cos,
						s = Math.sin,
						l = a(n / 2),
						c = a(i / 2),
						u = a(r / 2),
						h = s(n / 2),
						d = s(i / 2),
						f = s(r / 2);
					return "XYZ" === o ? (this._x = h * c * u + l * d * f,
							this._y = l * d * u - h * c * f,
							this._z = l * c * f + h * d * u,
							this._w = l * c * u - h * d * f) : "YXZ" === o ? (this._x = h * c * u + l * d * f,
							this._y = l * d * u - h * c * f,
							this._z = l * c * f - h * d * u,
							this._w = l * c * u + h * d * f) : "ZXY" === o ? (this._x = h * c * u - l * d * f,
							this._y = l * d * u + h * c * f,
							this._z = l * c * f + h * d * u,
							this._w = l * c * u - h * d * f) : "ZYX" === o ? (this._x = h * c * u - l * d * f,
							this._y = l * d * u + h * c * f,
							this._z = l * c * f - h * d * u,
							this._w = l * c * u + h * d * f) : "YZX" === o ? (this._x = h * c * u + l * d * f,
							this._y = l * d * u + h * c * f,
							this._z = l * c * f - h * d * u,
							this._w = l * c * u - h * d * f) : "XZY" === o && (this._x = h * c * u - l * d * f,
							this._y = l * d * u - h * c * f,
							this._z = l * c * f + h * d * u,
							this._w = l * c * u + h * d * f),
						e !== !1 && this.onChangeCallback(),
						this
				},
				setFromAxisAngle: function(t, e) {
					var n = e / 2,
						i = Math.sin(n);
					return this._x = t.x * i,
						this._y = t.y * i,
						this._z = t.z * i,
						this._w = Math.cos(n),
						this.onChangeCallback(),
						this
				},
				setFromRotationMatrix: function(t) {
					var e, n = t.elements,
						i = n[0],
						r = n[4],
						o = n[8],
						a = n[1],
						s = n[5],
						l = n[9],
						c = n[2],
						u = n[6],
						h = n[10],
						d = i + s + h;
					return d > 0 ? (e = .5 / Math.sqrt(d + 1),
							this._w = .25 / e,
							this._x = (u - l) * e,
							this._y = (o - c) * e,
							this._z = (a - r) * e) : i > s && i > h ? (e = 2 * Math.sqrt(1 + i - s - h),
							this._w = (u - l) / e,
							this._x = .25 * e,
							this._y = (r + a) / e,
							this._z = (o + c) / e) : s > h ? (e = 2 * Math.sqrt(1 + s - i - h),
							this._w = (o - c) / e,
							this._x = (r + a) / e,
							this._y = .25 * e,
							this._z = (l + u) / e) : (e = 2 * Math.sqrt(1 + h - i - s),
							this._w = (a - r) / e,
							this._x = (o + c) / e,
							this._y = (l + u) / e,
							this._z = .25 * e),
						this.onChangeCallback(),
						this
				},
				setFromUnitVectors: function() {
					var t, e = new l,
						n = 1e-6;
					return function(i, r) {
						return void 0 === e && (e = new l),
							t = i.dot(r) + 1,
							t < n ? (t = 0,
								Math.abs(i.x) > Math.abs(i.z) ? e.set(-i.y, i.x, 0) : e.set(0, -i.z, i.y)) : e.crossVectors(i, r),
							this._x = e.x,
							this._y = e.y,
							this._z = e.z,
							this._w = t,
							this.normalize()
					}
				}(),
				inverse: function() {
					return this.conjugate().normalize()
				},
				conjugate: function() {
					return this._x *= -1,
						this._y *= -1,
						this._z *= -1,
						this.onChangeCallback(),
						this
				},
				dot: function(t) {
					return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
				},
				lengthSq: function() {
					return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
				},
				length: function() {
					return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
				},
				normalize: function() {
					var t = this.length();
					return 0 === t ? (this._x = 0,
							this._y = 0,
							this._z = 0,
							this._w = 1) : (t = 1 / t,
							this._x = this._x * t,
							this._y = this._y * t,
							this._z = this._z * t,
							this._w = this._w * t),
						this.onChangeCallback(),
						this
				},
				multiply: function(t, e) {
					return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
						this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
				},
				premultiply: function(t) {
					return this.multiplyQuaternions(t, this)
				},
				multiplyQuaternions: function(t, e) {
					var n = t._x,
						i = t._y,
						r = t._z,
						o = t._w,
						a = e._x,
						s = e._y,
						l = e._z,
						c = e._w;
					return this._x = n * c + o * a + i * l - r * s,
						this._y = i * c + o * s + r * a - n * l,
						this._z = r * c + o * l + n * s - i * a,
						this._w = o * c - n * a - i * s - r * l,
						this.onChangeCallback(),
						this
				},
				slerp: function(t, e) {
					if(0 === e)
						return this;
					if(1 === e)
						return this.copy(t);
					var n = this._x,
						i = this._y,
						r = this._z,
						o = this._w,
						a = o * t._w + n * t._x + i * t._y + r * t._z;
					if(a < 0 ? (this._w = -t._w,
							this._x = -t._x,
							this._y = -t._y,
							this._z = -t._z,
							a = -a) : this.copy(t),
						a >= 1)
						return this._w = o,
							this._x = n,
							this._y = i,
							this._z = r,
							this;
					var s = Math.sqrt(1 - a * a);
					if(Math.abs(s) < .001)
						return this._w = .5 * (o + this._w),
							this._x = .5 * (n + this._x),
							this._y = .5 * (i + this._y),
							this._z = .5 * (r + this._z),
							this;
					var l = Math.atan2(s, a),
						c = Math.sin((1 - e) * l) / s,
						u = Math.sin(e * l) / s;
					return this._w = o * c + this._w * u,
						this._x = n * c + this._x * u,
						this._y = i * c + this._y * u,
						this._z = r * c + this._z * u,
						this.onChangeCallback(),
						this
				},
				equals: function(t) {
					return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
				},
				fromArray: function(t, e) {
					return void 0 === e && (e = 0),
						this._x = t[e],
						this._y = t[e + 1],
						this._z = t[e + 2],
						this._w = t[e + 3],
						this.onChangeCallback(),
						this
				},
				toArray: function(t, e) {
					return void 0 === t && (t = []),
						void 0 === e && (e = 0),
						t[e] = this._x,
						t[e + 1] = this._y,
						t[e + 2] = this._z,
						t[e + 3] = this._w,
						t
				},
				onChange: function(t) {
					return this.onChangeCallback = t,
						this
				},
				onChangeCallback: function() {}
			}),
			Object.assign(l.prototype, {
				isVector3: !0,
				set: function(t, e, n) {
					return this.x = t,
						this.y = e,
						this.z = n,
						this
				},
				setScalar: function(t) {
					return this.x = t,
						this.y = t,
						this.z = t,
						this
				},
				setX: function(t) {
					return this.x = t,
						this
				},
				setY: function(t) {
					return this.y = t,
						this
				},
				setZ: function(t) {
					return this.z = t,
						this
				},
				setComponent: function(t, e) {
					switch(t) {
						case 0:
							this.x = e;
							break;
						case 1:
							this.y = e;
							break;
						case 2:
							this.z = e;
							break;
						default:
							throw new Error("index is out of range: " + t)
					}
					return this
				},
				getComponent: function(t) {
					switch(t) {
						case 0:
							return this.x;
						case 1:
							return this.y;
						case 2:
							return this.z;
						default:
							throw new Error("index is out of range: " + t)
					}
				},
				clone: function() {
					return new this.constructor(this.x, this.y, this.z)
				},
				copy: function(t) {
					return this.x = t.x,
						this.y = t.y,
						this.z = t.z,
						this
				},
				add: function(t, e) {
					return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
						this.addVectors(t, e)) : (this.x += t.x,
						this.y += t.y,
						this.z += t.z,
						this)
				},
				addScalar: function(t) {
					return this.x += t,
						this.y += t,
						this.z += t,
						this
				},
				addVectors: function(t, e) {
					return this.x = t.x + e.x,
						this.y = t.y + e.y,
						this.z = t.z + e.z,
						this
				},
				addScaledVector: function(t, e) {
					return this.x += t.x * e,
						this.y += t.y * e,
						this.z += t.z * e,
						this
				},
				sub: function(t, e) {
					return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
						this.subVectors(t, e)) : (this.x -= t.x,
						this.y -= t.y,
						this.z -= t.z,
						this)
				},
				subScalar: function(t) {
					return this.x -= t,
						this.y -= t,
						this.z -= t,
						this
				},
				subVectors: function(t, e) {
					return this.x = t.x - e.x,
						this.y = t.y - e.y,
						this.z = t.z - e.z,
						this
				},
				multiply: function(t, e) {
					return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
						this.multiplyVectors(t, e)) : (this.x *= t.x,
						this.y *= t.y,
						this.z *= t.z,
						this)
				},
				multiplyScalar: function(t) {
					return this.x *= t,
						this.y *= t,
						this.z *= t,
						this
				},
				multiplyVectors: function(t, e) {
					return this.x = t.x * e.x,
						this.y = t.y * e.y,
						this.z = t.z * e.z,
						this
				},
				applyEuler: function() {
					var t = new s;
					return function(e) {
						return(e && e.isEuler) === !1 && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
							this.applyQuaternion(t.setFromEuler(e))
					}
				}(),
				applyAxisAngle: function() {
					var t = new s;
					return function(e, n) {
						return this.applyQuaternion(t.setFromAxisAngle(e, n))
					}
				}(),
				applyMatrix3: function(t) {
					var e = this.x,
						n = this.y,
						i = this.z,
						r = t.elements;
					return this.x = r[0] * e + r[3] * n + r[6] * i,
						this.y = r[1] * e + r[4] * n + r[7] * i,
						this.z = r[2] * e + r[5] * n + r[8] * i,
						this
				},
				applyMatrix4: function(t) {
					var e = this.x,
						n = this.y,
						i = this.z,
						r = t.elements;
					this.x = r[0] * e + r[4] * n + r[8] * i + r[12],
						this.y = r[1] * e + r[5] * n + r[9] * i + r[13],
						this.z = r[2] * e + r[6] * n + r[10] * i + r[14];
					var o = r[3] * e + r[7] * n + r[11] * i + r[15];
					return this.divideScalar(o)
				},
				applyQuaternion: function(t) {
					var e = this.x,
						n = this.y,
						i = this.z,
						r = t.x,
						o = t.y,
						a = t.z,
						s = t.w,
						l = s * e + o * i - a * n,
						c = s * n + a * e - r * i,
						u = s * i + r * n - o * e,
						h = -r * e - o * n - a * i;
					return this.x = l * s + h * -r + c * -a - u * -o,
						this.y = c * s + h * -o + u * -r - l * -a,
						this.z = u * s + h * -a + l * -o - c * -r,
						this
				},
				project: function() {
					var t = new c;
					return function(e) {
						return t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)),
							this.applyMatrix4(t)
					}
				}(),
				unproject: function() {
					var t = new c;
					return function(e) {
						return t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)),
							this.applyMatrix4(t)
					}
				}(),
				transformDirection: function(t) {
					var e = this.x,
						n = this.y,
						i = this.z,
						r = t.elements;
					return this.x = r[0] * e + r[4] * n + r[8] * i,
						this.y = r[1] * e + r[5] * n + r[9] * i,
						this.z = r[2] * e + r[6] * n + r[10] * i,
						this.normalize()
				},
				divide: function(t) {
					return this.x /= t.x,
						this.y /= t.y,
						this.z /= t.z,
						this
				},
				divideScalar: function(t) {
					return this.multiplyScalar(1 / t)
				},
				min: function(t) {
					return this.x = Math.min(this.x, t.x),
						this.y = Math.min(this.y, t.y),
						this.z = Math.min(this.z, t.z),
						this
				},
				max: function(t) {
					return this.x = Math.max(this.x, t.x),
						this.y = Math.max(this.y, t.y),
						this.z = Math.max(this.z, t.z),
						this
				},
				clamp: function(t, e) {
					return this.x = Math.max(t.x, Math.min(e.x, this.x)),
						this.y = Math.max(t.y, Math.min(e.y, this.y)),
						this.z = Math.max(t.z, Math.min(e.z, this.z)),
						this
				},
				clampScalar: function() {
					var t = new l,
						e = new l;
					return function(n, i) {
						return t.set(n, n, n),
							e.set(i, i, i),
							this.clamp(t, e)
					}
				}(),
				clampLength: function(t, e) {
					var n = this.length();
					return this.multiplyScalar(Math.max(t, Math.min(e, n)) / n)
				},
				floor: function() {
					return this.x = Math.floor(this.x),
						this.y = Math.floor(this.y),
						this.z = Math.floor(this.z),
						this
				},
				ceil: function() {
					return this.x = Math.ceil(this.x),
						this.y = Math.ceil(this.y),
						this.z = Math.ceil(this.z),
						this
				},
				round: function() {
					return this.x = Math.round(this.x),
						this.y = Math.round(this.y),
						this.z = Math.round(this.z),
						this
				},
				roundToZero: function() {
					return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
						this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
						this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
						this
				},
				negate: function() {
					return this.x = -this.x,
						this.y = -this.y,
						this.z = -this.z,
						this
				},
				dot: function(t) {
					return this.x * t.x + this.y * t.y + this.z * t.z
				},
				lengthSq: function() {
					return this.x * this.x + this.y * this.y + this.z * this.z
				},
				length: function() {
					return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
				},
				lengthManhattan: function() {
					return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
				},
				normalize: function() {
					return this.divideScalar(this.length())
				},
				setLength: function(t) {
					return this.multiplyScalar(t / this.length());
				},
				lerp: function(t, e) {
					return this.x += (t.x - this.x) * e,
						this.y += (t.y - this.y) * e,
						this.z += (t.z - this.z) * e,
						this
				},
				lerpVectors: function(t, e, n) {
					return this.subVectors(e, t).multiplyScalar(n).add(t)
				},
				cross: function(t, e) {
					if(void 0 !== e)
						return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
							this.crossVectors(t, e);
					var n = this.x,
						i = this.y,
						r = this.z;
					return this.x = i * t.z - r * t.y,
						this.y = r * t.x - n * t.z,
						this.z = n * t.y - i * t.x,
						this
				},
				crossVectors: function(t, e) {
					var n = t.x,
						i = t.y,
						r = t.z,
						o = e.x,
						a = e.y,
						s = e.z;
					return this.x = i * s - r * a,
						this.y = r * o - n * s,
						this.z = n * a - i * o,
						this
				},
				projectOnVector: function(t) {
					var e = t.dot(this) / t.lengthSq();
					return this.copy(t).multiplyScalar(e)
				},
				projectOnPlane: function() {
					var t = new l;
					return function(e) {
						return t.copy(this).projectOnVector(e),
							this.sub(t)
					}
				}(),
				reflect: function() {
					var t = new l;
					return function(e) {
						return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
					}
				}(),
				angleTo: function(t) {
					var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
					return Math.acos(xs.clamp(e, -1, 1))
				},
				distanceTo: function(t) {
					return Math.sqrt(this.distanceToSquared(t))
				},
				distanceToSquared: function(t) {
					var e = this.x - t.x,
						n = this.y - t.y,
						i = this.z - t.z;
					return e * e + n * n + i * i
				},
				distanceToManhattan: function(t) {
					return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
				},
				setFromSpherical: function(t) {
					var e = Math.sin(t.phi) * t.radius;
					return this.x = e * Math.sin(t.theta),
						this.y = Math.cos(t.phi) * t.radius,
						this.z = e * Math.cos(t.theta),
						this
				},
				setFromCylindrical: function(t) {
					return this.x = t.radius * Math.sin(t.theta),
						this.y = t.y,
						this.z = t.radius * Math.cos(t.theta),
						this
				},
				setFromMatrixPosition: function(t) {
					return this.setFromMatrixColumn(t, 3)
				},
				setFromMatrixScale: function(t) {
					var e = this.setFromMatrixColumn(t, 0).length(),
						n = this.setFromMatrixColumn(t, 1).length(),
						i = this.setFromMatrixColumn(t, 2).length();
					return this.x = e,
						this.y = n,
						this.z = i,
						this
				},
				setFromMatrixColumn: function(t, e) {
					return this.fromArray(t.elements, 4 * e)
				},
				equals: function(t) {
					return t.x === this.x && t.y === this.y && t.z === this.z
				},
				fromArray: function(t, e) {
					return void 0 === e && (e = 0),
						this.x = t[e],
						this.y = t[e + 1],
						this.z = t[e + 2],
						this
				},
				toArray: function(t, e) {
					return void 0 === t && (t = []),
						void 0 === e && (e = 0),
						t[e] = this.x,
						t[e + 1] = this.y,
						t[e + 2] = this.z,
						t
				},
				fromBufferAttribute: function(t, e, n) {
					return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
						this.x = t.getX(e),
						this.y = t.getY(e),
						this.z = t.getZ(e),
						this
				}
			}),
			Object.assign(c.prototype, {
				isMatrix4: !0,
				set: function(t, e, n, i, r, o, a, s, l, c, u, h, d, f, p, m) {
					var v = this.elements;
					return v[0] = t,
						v[4] = e,
						v[8] = n,
						v[12] = i,
						v[1] = r,
						v[5] = o,
						v[9] = a,
						v[13] = s,
						v[2] = l,
						v[6] = c,
						v[10] = u,
						v[14] = h,
						v[3] = d,
						v[7] = f,
						v[11] = p,
						v[15] = m,
						this
				},
				identity: function() {
					return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
						this
				},
				clone: function() {
					return(new c).fromArray(this.elements)
				},
				copy: function(t) {
					var e = this.elements,
						n = t.elements;
					return e[0] = n[0],
						e[1] = n[1],
						e[2] = n[2],
						e[3] = n[3],
						e[4] = n[4],
						e[5] = n[5],
						e[6] = n[6],
						e[7] = n[7],
						e[8] = n[8],
						e[9] = n[9],
						e[10] = n[10],
						e[11] = n[11],
						e[12] = n[12],
						e[13] = n[13],
						e[14] = n[14],
						e[15] = n[15],
						this
				},
				copyPosition: function(t) {
					var e = this.elements,
						n = t.elements;
					return e[12] = n[12],
						e[13] = n[13],
						e[14] = n[14],
						this
				},
				extractBasis: function(t, e, n) {
					return t.setFromMatrixColumn(this, 0),
						e.setFromMatrixColumn(this, 1),
						n.setFromMatrixColumn(this, 2),
						this
				},
				makeBasis: function(t, e, n) {
					return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1),
						this
				},
				extractRotation: function() {
					var t = new l;
					return function(e) {
						var n = this.elements,
							i = e.elements,
							r = 1 / t.setFromMatrixColumn(e, 0).length(),
							o = 1 / t.setFromMatrixColumn(e, 1).length(),
							a = 1 / t.setFromMatrixColumn(e, 2).length();
						return n[0] = i[0] * r,
							n[1] = i[1] * r,
							n[2] = i[2] * r,
							n[4] = i[4] * o,
							n[5] = i[5] * o,
							n[6] = i[6] * o,
							n[8] = i[8] * a,
							n[9] = i[9] * a,
							n[10] = i[10] * a,
							this
					}
				}(),
				makeRotationFromEuler: function(t) {
					(t && t.isEuler) === !1 && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
					var e = this.elements,
						n = t.x,
						i = t.y,
						r = t.z,
						o = Math.cos(n),
						a = Math.sin(n),
						s = Math.cos(i),
						l = Math.sin(i),
						c = Math.cos(r),
						u = Math.sin(r);
					if("XYZ" === t.order) {
						var h = o * c,
							d = o * u,
							f = a * c,
							p = a * u;
						e[0] = s * c,
							e[4] = -s * u,
							e[8] = l,
							e[1] = d + f * l,
							e[5] = h - p * l,
							e[9] = -a * s,
							e[2] = p - h * l,
							e[6] = f + d * l,
							e[10] = o * s
					} else if("YXZ" === t.order) {
						var m = s * c,
							v = s * u,
							g = l * c,
							_ = l * u;
						e[0] = m + _ * a,
							e[4] = g * a - v,
							e[8] = o * l,
							e[1] = o * u,
							e[5] = o * c,
							e[9] = -a,
							e[2] = v * a - g,
							e[6] = _ + m * a,
							e[10] = o * s
					} else if("ZXY" === t.order) {
						var m = s * c,
							v = s * u,
							g = l * c,
							_ = l * u;
						e[0] = m - _ * a,
							e[4] = -o * u,
							e[8] = g + v * a,
							e[1] = v + g * a,
							e[5] = o * c,
							e[9] = _ - m * a,
							e[2] = -o * l,
							e[6] = a,
							e[10] = o * s
					} else if("ZYX" === t.order) {
						var h = o * c,
							d = o * u,
							f = a * c,
							p = a * u;
						e[0] = s * c,
							e[4] = f * l - d,
							e[8] = h * l + p,
							e[1] = s * u,
							e[5] = p * l + h,
							e[9] = d * l - f,
							e[2] = -l,
							e[6] = a * s,
							e[10] = o * s
					} else if("YZX" === t.order) {
						var y = o * s,
							b = o * l,
							x = a * s,
							w = a * l;
						e[0] = s * c,
							e[4] = w - y * u,
							e[8] = x * u + b,
							e[1] = u,
							e[5] = o * c,
							e[9] = -a * c,
							e[2] = -l * c,
							e[6] = b * u + x,
							e[10] = y - w * u
					} else if("XZY" === t.order) {
						var y = o * s,
							b = o * l,
							x = a * s,
							w = a * l;
						e[0] = s * c,
							e[4] = -u,
							e[8] = l * c,
							e[1] = y * u + w,
							e[5] = o * c,
							e[9] = b * u - x,
							e[2] = x * u - b,
							e[6] = a * c,
							e[10] = w * u + y
					}
					return e[3] = 0,
						e[7] = 0,
						e[11] = 0,
						e[12] = 0,
						e[13] = 0,
						e[14] = 0,
						e[15] = 1,
						this
				},
				makeRotationFromQuaternion: function(t) {
					var e = this.elements,
						n = t._x,
						i = t._y,
						r = t._z,
						o = t._w,
						a = n + n,
						s = i + i,
						l = r + r,
						c = n * a,
						u = n * s,
						h = n * l,
						d = i * s,
						f = i * l,
						p = r * l,
						m = o * a,
						v = o * s,
						g = o * l;
					return e[0] = 1 - (d + p),
						e[4] = u - g,
						e[8] = h + v,
						e[1] = u + g,
						e[5] = 1 - (c + p),
						e[9] = f - m,
						e[2] = h - v,
						e[6] = f + m,
						e[10] = 1 - (c + d),
						e[3] = 0,
						e[7] = 0,
						e[11] = 0,
						e[12] = 0,
						e[13] = 0,
						e[14] = 0,
						e[15] = 1,
						this
				},
				lookAt: function() {
					var t = new l,
						e = new l,
						n = new l;
					return function(i, r, o) {
						var a = this.elements;
						return n.subVectors(i, r),
							0 === n.lengthSq() && (n.z = 1),
							n.normalize(),
							t.crossVectors(o, n),
							0 === t.lengthSq() && (n.z += 1e-4,
								t.crossVectors(o, n)),
							t.normalize(),
							e.crossVectors(n, t),
							a[0] = t.x,
							a[4] = e.x,
							a[8] = n.x,
							a[1] = t.y,
							a[5] = e.y,
							a[9] = n.y,
							a[2] = t.z,
							a[6] = e.z,
							a[10] = n.z,
							this
					}
				}(),
				multiply: function(t, e) {
					return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
						this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
				},
				premultiply: function(t) {
					return this.multiplyMatrices(t, this)
				},
				multiplyMatrices: function(t, e) {
					var n = t.elements,
						i = e.elements,
						r = this.elements,
						o = n[0],
						a = n[4],
						s = n[8],
						l = n[12],
						c = n[1],
						u = n[5],
						h = n[9],
						d = n[13],
						f = n[2],
						p = n[6],
						m = n[10],
						v = n[14],
						g = n[3],
						_ = n[7],
						y = n[11],
						b = n[15],
						x = i[0],
						w = i[4],
						T = i[8],
						M = i[12],
						E = i[1],
						S = i[5],
						X = i[9],
						A = i[13],
						P = i[2],
						R = i[6],
						O = i[10],
						C = i[14],
						L = i[3],
						I = i[7],
						D = i[11],
						B = i[15];
					return r[0] = o * x + a * E + s * P + l * L,
						r[4] = o * w + a * S + s * R + l * I,
						r[8] = o * T + a * X + s * O + l * D,
						r[12] = o * M + a * A + s * C + l * B,
						r[1] = c * x + u * E + h * P + d * L,
						r[5] = c * w + u * S + h * R + d * I,
						r[9] = c * T + u * X + h * O + d * D,
						r[13] = c * M + u * A + h * C + d * B,
						r[2] = f * x + p * E + m * P + v * L,
						r[6] = f * w + p * S + m * R + v * I,
						r[10] = f * T + p * X + m * O + v * D,
						r[14] = f * M + p * A + m * C + v * B,
						r[3] = g * x + _ * E + y * P + b * L,
						r[7] = g * w + _ * S + y * R + b * I,
						r[11] = g * T + _ * X + y * O + b * D,
						r[15] = g * M + _ * A + y * C + b * B,
						this
				},
				multiplyScalar: function(t) {
					var e = this.elements;
					return e[0] *= t,
						e[4] *= t,
						e[8] *= t,
						e[12] *= t,
						e[1] *= t,
						e[5] *= t,
						e[9] *= t,
						e[13] *= t,
						e[2] *= t,
						e[6] *= t,
						e[10] *= t,
						e[14] *= t,
						e[3] *= t,
						e[7] *= t,
						e[11] *= t,
						e[15] *= t,
						this
				},
				applyToBufferAttribute: function() {
					var t = new l;
					return function(e) {
						for(var n = 0, i = e.count; n < i; n++)
							t.x = e.getX(n),
							t.y = e.getY(n),
							t.z = e.getZ(n),
							t.applyMatrix4(this),
							e.setXYZ(n, t.x, t.y, t.z);
						return e
					}
				}(),
				determinant: function() {
					var t = this.elements,
						e = t[0],
						n = t[4],
						i = t[8],
						r = t[12],
						o = t[1],
						a = t[5],
						s = t[9],
						l = t[13],
						c = t[2],
						u = t[6],
						h = t[10],
						d = t[14],
						f = t[3],
						p = t[7],
						m = t[11],
						v = t[15];
					return f * (+r * s * u - i * l * u - r * a * h + n * l * h + i * a * d - n * s * d) + p * (+e * s * d - e * l * h + r * o * h - i * o * d + i * l * c - r * s * c) + m * (+e * l * u - e * a * d - r * o * u + n * o * d + r * a * c - n * l * c) + v * (-i * a * c - e * s * u + e * a * h + i * o * u - n * o * h + n * s * c)
				},
				transpose: function() {
					var t, e = this.elements;
					return t = e[1],
						e[1] = e[4],
						e[4] = t,
						t = e[2],
						e[2] = e[8],
						e[8] = t,
						t = e[6],
						e[6] = e[9],
						e[9] = t,
						t = e[3],
						e[3] = e[12],
						e[12] = t,
						t = e[7],
						e[7] = e[13],
						e[13] = t,
						t = e[11],
						e[11] = e[14],
						e[14] = t,
						this
				},
				setPosition: function(t) {
					var e = this.elements;
					return e[12] = t.x,
						e[13] = t.y,
						e[14] = t.z,
						this
				},
				getInverse: function(t, e) {
					var n = this.elements,
						i = t.elements,
						r = i[0],
						o = i[1],
						a = i[2],
						s = i[3],
						l = i[4],
						c = i[5],
						u = i[6],
						h = i[7],
						d = i[8],
						f = i[9],
						p = i[10],
						m = i[11],
						v = i[12],
						g = i[13],
						_ = i[14],
						y = i[15],
						b = f * _ * h - g * p * h + g * u * m - c * _ * m - f * u * y + c * p * y,
						x = v * p * h - d * _ * h - v * u * m + l * _ * m + d * u * y - l * p * y,
						w = d * g * h - v * f * h + v * c * m - l * g * m - d * c * y + l * f * y,
						T = v * f * u - d * g * u - v * c * p + l * g * p + d * c * _ - l * f * _,
						M = r * b + o * x + a * w + s * T;
					if(0 === M) {
						var E = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
						if(e === !0)
							throw new Error(E);
						return console.warn(E),
							this.identity()
					}
					var S = 1 / M;
					return n[0] = b * S,
						n[1] = (g * p * s - f * _ * s - g * a * m + o * _ * m + f * a * y - o * p * y) * S,
						n[2] = (c * _ * s - g * u * s + g * a * h - o * _ * h - c * a * y + o * u * y) * S,
						n[3] = (f * u * s - c * p * s - f * a * h + o * p * h + c * a * m - o * u * m) * S,
						n[4] = x * S,
						n[5] = (d * _ * s - v * p * s + v * a * m - r * _ * m - d * a * y + r * p * y) * S,
						n[6] = (v * u * s - l * _ * s - v * a * h + r * _ * h + l * a * y - r * u * y) * S,
						n[7] = (l * p * s - d * u * s + d * a * h - r * p * h - l * a * m + r * u * m) * S,
						n[8] = w * S,
						n[9] = (v * f * s - d * g * s - v * o * m + r * g * m + d * o * y - r * f * y) * S,
						n[10] = (l * g * s - v * c * s + v * o * h - r * g * h - l * o * y + r * c * y) * S,
						n[11] = (d * c * s - l * f * s - d * o * h + r * f * h + l * o * m - r * c * m) * S,
						n[12] = T * S,
						n[13] = (d * g * a - v * f * a + v * o * p - r * g * p - d * o * _ + r * f * _) * S,
						n[14] = (v * c * a - l * g * a - v * o * u + r * g * u + l * o * _ - r * c * _) * S,
						n[15] = (l * f * a - d * c * a + d * o * u - r * f * u - l * o * p + r * c * p) * S,
						this
				},
				scale: function(t) {
					var e = this.elements,
						n = t.x,
						i = t.y,
						r = t.z;
					return e[0] *= n,
						e[4] *= i,
						e[8] *= r,
						e[1] *= n,
						e[5] *= i,
						e[9] *= r,
						e[2] *= n,
						e[6] *= i,
						e[10] *= r,
						e[3] *= n,
						e[7] *= i,
						e[11] *= r,
						this
				},
				getMaxScaleOnAxis: function() {
					var t = this.elements,
						e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
						n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
						i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
					return Math.sqrt(Math.max(e, n, i))
				},
				makeTranslation: function(t, e, n) {
					return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
						this
				},
				makeRotationX: function(t) {
					var e = Math.cos(t),
						n = Math.sin(t);
					return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1),
						this
				},
				makeRotationY: function(t) {
					var e = Math.cos(t),
						n = Math.sin(t);
					return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1),
						this
				},
				makeRotationZ: function(t) {
					var e = Math.cos(t),
						n = Math.sin(t);
					return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
						this
				},
				makeRotationAxis: function(t, e) {
					var n = Math.cos(e),
						i = Math.sin(e),
						r = 1 - n,
						o = t.x,
						a = t.y,
						s = t.z,
						l = r * o,
						c = r * a;
					return this.set(l * o + n, l * a - i * s, l * s + i * a, 0, l * a + i * s, c * a + n, c * s - i * o, 0, l * s - i * a, c * s + i * o, r * s * s + n, 0, 0, 0, 0, 1),
						this
				},
				makeScale: function(t, e, n) {
					return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
						this
				},
				makeShear: function(t, e, n) {
					return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1),
						this
				},
				compose: function(t, e, n) {
					return this.makeRotationFromQuaternion(e),
						this.scale(n),
						this.setPosition(t),
						this
				},
				decompose: function() {
					var t = new l,
						e = new c;
					return function(n, i, r) {
						var o = this.elements,
							a = t.set(o[0], o[1], o[2]).length(),
							s = t.set(o[4], o[5], o[6]).length(),
							l = t.set(o[8], o[9], o[10]).length(),
							c = this.determinant();
						c < 0 && (a = -a),
							n.x = o[12],
							n.y = o[13],
							n.z = o[14],
							e.copy(this);
						var u = 1 / a,
							h = 1 / s,
							d = 1 / l;
						return e.elements[0] *= u,
							e.elements[1] *= u,
							e.elements[2] *= u,
							e.elements[4] *= h,
							e.elements[5] *= h,
							e.elements[6] *= h,
							e.elements[8] *= d,
							e.elements[9] *= d,
							e.elements[10] *= d,
							i.setFromRotationMatrix(e),
							r.x = a,
							r.y = s,
							r.z = l,
							this
					}
				}(),
				makePerspective: function(t, e, n, i, r, o) {
					void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
					var a = this.elements,
						s = 2 * r / (e - t),
						l = 2 * r / (n - i),
						c = (e + t) / (e - t),
						u = (n + i) / (n - i),
						h = -(o + r) / (o - r),
						d = -2 * o * r / (o - r);
					return a[0] = s,
						a[4] = 0,
						a[8] = c,
						a[12] = 0,
						a[1] = 0,
						a[5] = l,
						a[9] = u,
						a[13] = 0,
						a[2] = 0,
						a[6] = 0,
						a[10] = h,
						a[14] = d,
						a[3] = 0,
						a[7] = 0,
						a[11] = -1,
						a[15] = 0,
						this
				},
				makeOrthographic: function(t, e, n, i, r, o) {
					var a = this.elements,
						s = 1 / (e - t),
						l = 1 / (n - i),
						c = 1 / (o - r),
						u = (e + t) * s,
						h = (n + i) * l,
						d = (o + r) * c;
					return a[0] = 2 * s,
						a[4] = 0,
						a[8] = 0,
						a[12] = -u,
						a[1] = 0,
						a[5] = 2 * l,
						a[9] = 0,
						a[13] = -h,
						a[2] = 0,
						a[6] = 0,
						a[10] = -2 * c,
						a[14] = -d,
						a[3] = 0,
						a[7] = 0,
						a[11] = 0,
						a[15] = 1,
						this
				},
				equals: function(t) {
					for(var e = this.elements, n = t.elements, i = 0; i < 16; i++)
						if(e[i] !== n[i])
							return !1;
					return !0
				},
				fromArray: function(t, e) {
					void 0 === e && (e = 0);
					for(var n = 0; n < 16; n++)
						this.elements[n] = t[n + e];
					return this
				},
				toArray: function(t, e) {
					void 0 === t && (t = []),
						void 0 === e && (e = 0);
					var n = this.elements;
					return t[e] = n[0],
						t[e + 1] = n[1],
						t[e + 2] = n[2],
						t[e + 3] = n[3],
						t[e + 4] = n[4],
						t[e + 5] = n[5],
						t[e + 6] = n[6],
						t[e + 7] = n[7],
						t[e + 8] = n[8],
						t[e + 9] = n[9],
						t[e + 10] = n[10],
						t[e + 11] = n[11],
						t[e + 12] = n[12],
						t[e + 13] = n[13],
						t[e + 14] = n[14],
						t[e + 15] = n[15],
						t
				}
			}),
			u.prototype = Object.create(i.prototype),
			u.prototype.constructor = u,
			u.prototype.isDataTexture = !0,
			h.prototype = Object.create(i.prototype),
			h.prototype.constructor = h,
			h.prototype.isCubeTexture = !0,
			Object.defineProperty(h.prototype, "images", {
				get: function() {
					return this.image
				},
				set: function(t) {
					this.image = t
				}
			});
		var Ts = new i,
			Ms = new h,
			Es = [],
			Ss = [],
			Xs = new Float32Array(16),
			As = new Float32Array(9);
		j.prototype.setValue = function(t, e) {
			for(var n = this.seq, i = 0, r = n.length; i !== r; ++i) {
				var o = n[i];
				o.setValue(t, e[o.id])
			}
		};
		var Ps = /([\w\d_]+)(\])?(\[|\.)?/g;
		H.prototype.setValue = function(t, e, n) {
				var i = this.map[e];
				void 0 !== i && i.setValue(t, n, this.renderer)
			},
			H.prototype.setOptional = function(t, e, n) {
				var i = e[n];
				void 0 !== i && this.setValue(t, n, i)
			},
			H.upload = function(t, e, n, i) {
				for(var r = 0, o = e.length; r !== o; ++r) {
					var a = e[r],
						s = n[a.id];
					s.needsUpdate !== !1 && a.setValue(t, s.value, i)
				}
			},
			H.seqWithValue = function(t, e) {
				for(var n = [], i = 0, r = t.length; i !== r; ++i) {
					var o = t[i];
					o.id in e && n.push(o)
				}
				return n
			};
		var Rs = {
			aliceblue: 15792383,
			antiquewhite: 16444375,
			aqua: 65535,
			aquamarine: 8388564,
			azure: 15794175,
			beige: 16119260,
			bisque: 16770244,
			black: 0,
			blanchedalmond: 16772045,
			blue: 255,
			blueviolet: 9055202,
			brown: 10824234,
			burlywood: 14596231,
			cadetblue: 6266528,
			chartreuse: 8388352,
			chocolate: 13789470,
			coral: 16744272,
			cornflowerblue: 6591981,
			cornsilk: 16775388,
			crimson: 14423100,
			cyan: 65535,
			darkblue: 139,
			darkcyan: 35723,
			darkgoldenrod: 12092939,
			darkgray: 11119017,
			darkgreen: 25600,
			darkgrey: 11119017,
			darkkhaki: 12433259,
			darkmagenta: 9109643,
			darkolivegreen: 5597999,
			darkorange: 16747520,
			darkorchid: 10040012,
			darkred: 9109504,
			darksalmon: 15308410,
			darkseagreen: 9419919,
			darkslateblue: 4734347,
			darkslategray: 3100495,
			darkslategrey: 3100495,
			darkturquoise: 52945,
			darkviolet: 9699539,
			deeppink: 16716947,
			deepskyblue: 49151,
			
			dimgray: 6908265,
			dimgrey: 6908265,
			dodgerblue: 2003199,
			firebrick: 11674146,
			floralwhite: 16775920,
			forestgreen: 2263842,
			fuchsia: 16711935,
			gainsboro: 14474460,
			ghostwhite: 16316671,
			gold: 16766720,
			goldenrod: 14329120,
			gray: 8421504,
			green: 32768,
			greenyellow: 11403055,
			grey: 8421504,
			honeydew: 15794160,
			hotpink: 16738740,
			indianred: 13458524,
			indigo: 4915330,
			ivory: 16777200,
			khaki: 15787660,
			lavender: 15132410,
			lavenderblush: 16773365,
			lawngreen: 8190976,
			lemonchiffon: 16775885,
			lightblue: 11393254,
			lightcoral: 15761536,
			lightcyan: 14745599,
			lightgoldenrodyellow: 16448210,
			lightgray: 13882323,
			lightgreen: 9498256,
			lightgrey: 13882323,
			lightpink: 16758465,
			lightsalmon: 16752762,
			lightseagreen: 2142890,
			lightskyblue: 8900346,
			lightslategray: 7833753,
			lightslategrey: 7833753,
			lightsteelblue: 11584734,
			lightyellow: 16777184,
			lime: 65280,
			limegreen: 3329330,
			linen: 16445670,
			magenta: 16711935,
			maroon: 8388608,
			mediumaquamarine: 6737322,
			mediumblue: 205,
			mediumorchid: 12211667,
			mediumpurple: 9662683,
			mediumseagreen: 3978097,
			mediumslateblue: 8087790,
			mediumspringgreen: 64154,
			mediumturquoise: 4772300,
			mediumvioletred: 13047173,
			midnightblue: 1644912,
			mintcream: 16121850,
			mistyrose: 16770273,
			moccasin: 16770229,
			navajowhite: 16768685,
			navy: 128,
			oldlace: 16643558,
			olive: 8421376,
			olivedrab: 7048739,
			orange: 16753920,
			orangered: 16729344,
			orchid: 14315734,
			palegoldenrod: 15657130,
			palegreen: 10025880,
			paleturquoise: 11529966,
			palevioletred: 14381203,
			papayawhip: 16773077,
			peachpuff: 16767673,
			peru: 13468991,
			pink: 16761035,
			plum: 14524637,
			powderblue: 11591910,
			purple: 8388736,
			red: 16711680,
			rosybrown: 12357519,
			royalblue: 4286945,
			saddlebrown: 9127187,
			salmon: 16416882,
			sandybrown: 16032864,
			seagreen: 3050327,
			seashell: 16774638,
			sienna: 10506797,
			silver: 12632256,
			skyblue: 8900331,
			slateblue: 6970061,
			slategray: 7372944,
			slategrey: 7372944,
			snow: 16775930,
			springgreen: 65407,
			steelblue: 4620980,
			tan: 13808780,
			teal: 32896,
			thistle: 14204888,
			tomato: 16737095,
			turquoise: 4251856,
			violet: 15631086,
			wheat: 16113331,
			white: 16777215,
			whitesmoke: 16119285,
			yellow: 16776960,
			yellowgreen: 10145074
		};
		Object.assign(W.prototype, {
			isColor: !0,
			r: 1,
			g: 1,
			b: 1,
			set: function(t) {
				return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t),
					this
			},
			setScalar: function(t) {
				return this.r = t,
					this.g = t,
					this.b = t,
					this
			},
			setHex: function(t) {
				return t = Math.floor(t),
					this.r = (t >> 16 & 255) / 255,
					this.g = (t >> 8 & 255) / 255,
					this.b = (255 & t) / 255,
					this
			},
			setRGB: function(t, e, n) {
				return this.r = t,
					this.g = e,
					this.b = n,
					this
			},
			setHSL: function() {
				function t(t, e, n) {
					return n < 0 && (n += 1),
						n > 1 && (n -= 1),
						n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
				}
				return function(e, n, i) {
					if(e = xs.euclideanModulo(e, 1),
						n = xs.clamp(n, 0, 1),
						i = xs.clamp(i, 0, 1),
						0 === n)
						this.r = this.g = this.b = i;
					else {
						var r = i <= .5 ? i * (1 + n) : i + n - i * n,
							o = 2 * i - r;
						this.r = t(o, r, e + 1 / 3),
							this.g = t(o, r, e),
							this.b = t(o, r, e - 1 / 3)
					}
					return this
				}
			}(),
			setStyle: function(t) {
				function e(e) {
					void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
				}
				var n;
				if(n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
					var i, r = n[1],
						o = n[2];
					switch(r) {
						case "rgb":
						case "rgba":
							if(i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))
								return this.r = Math.min(255, parseInt(i[1], 10)) / 255,
									this.g = Math.min(255, parseInt(i[2], 10)) / 255,
									this.b = Math.min(255, parseInt(i[3], 10)) / 255,
									e(i[5]),
									this;
							if(i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))
								return this.r = Math.min(100, parseInt(i[1], 10)) / 100,
									this.g = Math.min(100, parseInt(i[2], 10)) / 100,
									this.b = Math.min(100, parseInt(i[3], 10)) / 100,
									e(i[5]),
									this;
							break;
						case "hsl":
						case "hsla":
							if(i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
								var a = parseFloat(i[1]) / 360,
									s = parseInt(i[2], 10) / 100,
									l = parseInt(i[3], 10) / 100;
								return e(i[5]),
									this.setHSL(a, s, l)
							}
					}
				} else if(n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
					var c = n[1],
						u = c.length;
					if(3 === u)
						return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255,
							this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255,
							this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255,
							this;
					if(6 === u)
						return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255,
							this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255,
							this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255,
							this
				}
				if(t && t.length > 0) {
					var c = Rs[t];
					void 0 !== c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + t)
				}
				return this
			},
			clone: function() {
				return new this.constructor(this.r, this.g, this.b)
			},
			copy: function(t) {
				return this.r = t.r,
					this.g = t.g,
					this.b = t.b,
					this
			},
			copyGammaToLinear: function(t, e) {
				return void 0 === e && (e = 2),
					this.r = Math.pow(t.r, e),
					this.g = Math.pow(t.g, e),
					this.b = Math.pow(t.b, e),
					this
			},
			copyLinearToGamma: function(t, e) {
				void 0 === e && (e = 2);
				var n = e > 0 ? 1 / e : 1;
				return this.r = Math.pow(t.r, n),
					this.g = Math.pow(t.g, n),
					this.b = Math.pow(t.b, n),
					this
			},
			convertGammaToLinear: function() {
				var t = this.r,
					e = this.g,
					n = this.b;
				return this.r = t * t,
					this.g = e * e,
					this.b = n * n,
					this
			},
			convertLinearToGamma: function() {
				return this.r = Math.sqrt(this.r),
					this.g = Math.sqrt(this.g),
					this.b = Math.sqrt(this.b),
					this
			},
			getHex: function() {
				return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
			},
			getHexString: function() {
				return("000000" + this.getHex().toString(16)).slice(-6)
			},
			getHSL: function(t) {
				var e, n, i = t || {
						h: 0,
						s: 0,
						l: 0
					},
					r = this.r,
					o = this.g,
					a = this.b,
					s = Math.max(r, o, a),
					l = Math.min(r, o, a),
					c = (l + s) / 2;
				if(l === s)
					e = 0,
					n = 0;
				else {
					var u = s - l;
					switch(n = c <= .5 ? u / (s + l) : u / (2 - s - l),
						s) {
						case r:
							e = (o - a) / u + (o < a ? 6 : 0);
							break;
						case o:
							e = (a - r) / u + 2;
							break;
						case a:
							e = (r - o) / u + 4
					}
					e /= 6
				}
				return i.h = e,
					i.s = n,
					i.l = c,
					i
			},
			getStyle: function() {
				return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
			},
			offsetHSL: function(t, e, n) {
				var i = this.getHSL();
				return i.h += t,
					i.s += e,
					i.l += n,
					this.setHSL(i.h, i.s, i.l),
					this
			},
			add: function(t) {
				return this.r += t.r,
					this.g += t.g,
					this.b += t.b,
					this
			},
			addColors: function(t, e) {
				return this.r = t.r + e.r,
					this.g = t.g + e.g,
					this.b = t.b + e.b,
					this
			},
			addScalar: function(t) {
				return this.r += t,
					this.g += t,
					this.b += t,
					this
			},
			sub: function(t) {
				return this.r = Math.max(0, this.r - t.r),
					this.g = Math.max(0, this.g - t.g),
					this.b = Math.max(0, this.b - t.b),
					this
			},
			multiply: function(t) {
				return this.r *= t.r,
					this.g *= t.g,
					this.b *= t.b,
					this
			},
			multiplyScalar: function(t) {
				return this.r *= t,
					this.g *= t,
					this.b *= t,
					this
			},
			lerp: function(t, e) {
				return this.r += (t.r - this.r) * e,
					this.g += (t.g - this.g) * e,
					this.b += (t.b - this.b) * e,
					this
			},
			equals: function(t) {
				return t.r === this.r && t.g === this.g && t.b === this.b
			},
			fromArray: function(t, e) {
				return void 0 === e && (e = 0),
					this.r = t[e],
					this.g = t[e + 1],
					this.b = t[e + 2],
					this
			},
			toArray: function(t, e) {
				return void 0 === t && (t = []),
					void 0 === e && (e = 0),
					t[e] = this.r,
					t[e + 1] = this.g,
					t[e + 2] = this.b,
					t
			},
			toJSON: function() {
				return this.getHex()
			}
		});
		var Os = {
				common: {
					diffuse: {
						value: new W(15658734)
					},
					opacity: {
						value: 1
					},
					map: {
						value: null
					},
					offsetRepeat: {
						value: new r(0, 0, 1, 1)
					},
					specularMap: {
						value: null
					},
					alphaMap: {
						value: null
					},
					envMap: {
						value: null
					},
					flipEnvMap: {
						value: -1
					},
					reflectivity: {
						value: 1
					},
					refractionRatio: {
						value: .98
					}
				},
				aomap: {
					aoMap: {
						value: null
					},
					aoMapIntensity: {
						value: 1
					}
				},
				lightmap: {
					lightMap: {
						value: null
					},
					lightMapIntensity: {
						value: 1
					}
				},
				emissivemap: {
					emissiveMap: {
						value: null
					}
				},
				bumpmap: {
					bumpMap: {
						value: null
					},
					bumpScale: {
						value: 1
					}
				},
				normalmap: {
					normalMap: {
						value: null
					},
					normalScale: {
						value: new n(1, 1)
					}
				},
				displacementmap: {
					displacementMap: {
						value: null
					},
					displacementScale: {
						value: 1
					},
					displacementBias: {
						value: 0
					}
				},
				roughnessmap: {
					roughnessMap: {
						value: null
					}
				},
				metalnessmap: {
					metalnessMap: {
						value: null
					}
				},
				gradientmap: {
					gradientMap: {
						value: null
					}
				},
				fog: {
					fogDensity: {
						value: 25e-5						
					},
					fogNear: {
						value: 1
					},
					fogFar: {
						value: 2e3
					},
					fogColor: {						
						value: new W(16777215)
					}
				},
				lights: {
					ambientLightColor: {
						value: []
					},
					directionalLights: {
						value: [],
						properties: {
							direction: {},
							color: {},
							shadow: {},
							shadowBias: {},
							shadowRadius: {},
							shadowMapSize: {}
						}
					},
					directionalShadowMap: {
						value: []
					},
					directionalShadowMatrix: {
						value: []
					},
					spotLights: {
						value: [],
						properties: {
							color: {},
							position: {},
							direction: {},
							distance: {},
							coneCos: {},
							penumbraCos: {},
							decay: {},
							shadow: {},
							shadowBias: {},
							shadowRadius: {},
							shadowMapSize: {}
						}
					},
					spotShadowMap: {
						value: []
					},
					spotShadowMatrix: {
						value: []
					},
					pointLights: {
						value: [],
						properties: {
							color: {},
							position: {},
							decay: {},
							distance: {},
							shadow: {},
							shadowBias: {},
							shadowRadius: {},
							shadowMapSize: {}
						}
					},
					pointShadowMap: {
						value: []
					},
					pointShadowMatrix: {
						value: []
					},
					hemisphereLights: {
						value: [],
						properties: {
							direction: {},
							skyColor: {},
							groundColor: {}
						}
					},
					rectAreaLights: {
						value: [],
						properties: {
							color: {},
							position: {},
							width: {},
							height: {}
						}
					}
				},
				points: {
					diffuse: {
						value: new W(15658734)
					},
					opacity: {
						value: 1
					},
					size: {
						value: 1
					},
					scale: {
						value: 1
					},
					map: {
						value: null
					},
					offsetRepeat: {
						value: new r(0, 0, 1, 1)
					}
				}
			},
			Cs = {
				merge: function(t) {
					for(var e = {}, n = 0; n < t.length; n++) {
						var i = this.clone(t[n]);
						for(var r in i)
							e[r] = i[r]
					}
					return e
				},
				clone: function(t) {
					var e = {};
					for(var n in t) {
						e[n] = {};
						for(var i in t[n]) {
							var r = t[n][i];
							r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
						}
					}
					return e
				}
			},
			Ls = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
			Is = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
			Ds = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
			Bs = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
			Fs = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
			zs = "\nvec3 transformed = vec3( position );\n",
			Ns = "\nvec3 objectNormal = vec3( normal );\n",
			ks = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
			Us = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
			js = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n",
			Vs = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
			Gs = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
			Hs = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
			Ws = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
			Ys = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
			qs = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
			Zs = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
			Qs = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n",
			Js = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
			Ks = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n",
			$s = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
			tl = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
			el = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
			nl = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
			il = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
			rl = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
			ol = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
			al = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
			sl = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
			ll = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
			cl = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
			ul = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
			hl = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
			dl = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
			fl = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
			pl = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
			ml = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
			vl = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
			gl = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
			_l = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
			yl = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
			bl = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
			xl = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
			wl = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
			Tl = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
			Ml = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
			El = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
			Sl = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n",
			Xl = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
			Al = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
			Pl = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
			Rl = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n",
			Ol = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
			Cl = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
			Ll = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
			Il = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
			Dl = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
			Bl = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n",
			Fl = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
			zl = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
			Nl = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
			kl = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
			Ul = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n",
			jl = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
			Vl = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
			Gl = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
			Hl = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
			Wl = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
			Yl = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
			ql = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
			Zl = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
			Ql = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
			Jl = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
			Kl = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n",
			$l = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
			tc = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
			ec = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
			nc = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
			ic = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
			rc = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
			oc = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n",
			ac = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
			sc = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
			lc = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
			cc = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
			uc = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n",
			hc = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
			dc = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
			fc = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
			pc = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
			mc = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n",
			vc = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n",
			gc = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
			_c = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
			yc = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
			bc = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
			xc = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
			wc = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
			Tc = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
			Mc = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
			Ec = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
			Sc = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
			Xc = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
			Ac = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
			Pc = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
			Rc = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
			Oc = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
			Cc = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
			Lc = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n",
			Ic = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n",
			Dc = {
				alphamap_fragment: Ls,
				alphamap_pars_fragment: Is,
				alphatest_fragment: Ds,
				aomap_fragment: Bs,
				aomap_pars_fragment: Fs,
				begin_vertex: zs,
				beginnormal_vertex: Ns,
				bsdfs: ks,
				bumpmap_pars_fragment: Us,
				clipping_planes_fragment: js,
				clipping_planes_pars_fragment: Vs,
				clipping_planes_pars_vertex: Gs,
				clipping_planes_vertex: Hs,
				color_fragment: Ws,
				color_pars_fragment: Ys,
				color_pars_vertex: qs,
				color_vertex: Zs,
				common: Qs,
				cube_uv_reflection_fragment: Js,
				defaultnormal_vertex: Ks,
				displacementmap_pars_vertex: $s,
				displacementmap_vertex: tl,
				emissivemap_fragment: el,
				emissivemap_pars_fragment: nl,
				encodings_fragment: il,
				encodings_pars_fragment: rl,
				envmap_fragment: ol,
				envmap_pars_fragment: al,
				envmap_pars_vertex: sl,
				envmap_vertex: ll,
				fog_vertex: cl,
				fog_pars_vertex: ul,
				fog_fragment: hl,
				fog_pars_fragment: dl,
				gradientmap_pars_fragment: fl,
				lightmap_fragment: pl,
				lightmap_pars_fragment: ml,
				lights_lambert_vertex: vl,
				lights_pars: gl,
				lights_phong_fragment: _l,
				lights_phong_pars_fragment: yl,
				lights_physical_fragment: bl,
				lights_physical_pars_fragment: xl,
				lights_template: wl,
				logdepthbuf_fragment: Tl,
				logdepthbuf_pars_fragment: Ml,
				logdepthbuf_pars_vertex: El,
				logdepthbuf_vertex: Sl,
				map_fragment: Xl,
				map_pars_fragment: Al,
				map_particle_fragment: Pl,
				map_particle_pars_fragment: Rl,
				metalnessmap_fragment: Ol,
				metalnessmap_pars_fragment: Cl,
				morphnormal_vertex: Ll,
				morphtarget_pars_vertex: Il,
				morphtarget_vertex: Dl,
				normal_flip: Bl,
				normal_fragment: Fl,
				normalmap_pars_fragment: zl,
				packing: Nl,
				premultiplied_alpha_fragment: kl,
				project_vertex: Ul,
				dithering_fragment: jl,
				dithering_pars_fragment: Vl,
				roughnessmap_fragment: Gl,
				roughnessmap_pars_fragment: Hl,
				shadowmap_pars_fragment: Wl,
				shadowmap_pars_vertex: Yl,
				shadowmap_vertex: ql,
				shadowmask_pars_fragment: Zl,
				skinbase_vertex: Ql,
				skinning_pars_vertex: Jl,
				skinning_vertex: Kl,
				skinnormal_vertex: $l,
				specularmap_fragment: tc,
				specularmap_pars_fragment: ec,
				tonemapping_fragment: nc,
				tonemapping_pars_fragment: ic,
				uv_pars_fragment: rc,
				uv_pars_vertex: oc,
				uv_vertex: ac,
				uv2_pars_fragment: sc,
				uv2_pars_vertex: lc,
				uv2_vertex: cc,
				worldpos_vertex: uc,
				cube_frag: hc,
				cube_vert: dc,
				depth_frag: fc,
				depth_vert: pc,
				distanceRGBA_frag: mc,
				distanceRGBA_vert: vc,
				equirect_frag: gc,
				equirect_vert: _c,
				linedashed_frag: yc,
				linedashed_vert: bc,
				meshbasic_frag: xc,
				meshbasic_vert: wc,
				meshlambert_frag: Tc,
				meshlambert_vert: Mc,
				meshphong_frag: Ec,
				meshphong_vert: Sc,
				meshphysical_frag: Xc,
				meshphysical_vert: Ac,
				normal_frag: Pc,
				normal_vert: Rc,
				points_frag: Oc,
				points_vert: Cc,
				shadow_frag: Lc,
				shadow_vert: Ic
			},
			Bc = {
				basic: {
					uniforms: Cs.merge([Os.common, Os.aomap, Os.lightmap, Os.fog]),
					vertexShader: Dc.meshbasic_vert,
					fragmentShader: Dc.meshbasic_frag
				},
				lambert: {
					uniforms: Cs.merge([Os.common, Os.aomap, Os.lightmap, Os.emissivemap, Os.fog, Os.lights, {
						emissive: {
							value: new W(0)
						}
					}]),
					vertexShader: Dc.meshlambert_vert,
					fragmentShader: Dc.meshlambert_frag
				},
				phong: {
					uniforms: Cs.merge([Os.common, Os.aomap, Os.lightmap, Os.emissivemap, Os.bumpmap, Os.normalmap, Os.displacementmap, Os.gradientmap, Os.fog, Os.lights, {
						emissive: {
							value: new W(0)
						},
						specular: {
							value: new W(1118481)
						},
						shininess: {
							value: 30
						}
					}]),
					vertexShader: Dc.meshphong_vert,
					fragmentShader: Dc.meshphong_frag
				},
				standard: {
					uniforms: Cs.merge([Os.common, Os.aomap, Os.lightmap, Os.emissivemap, Os.bumpmap, Os.normalmap, Os.displacementmap, Os.roughnessmap, Os.metalnessmap, Os.fog, Os.lights, {
						emissive: {
							value: new W(0)
						},
						roughness: {
							value: .5
						},
						metalness: {
							value: .5
						},
						envMapIntensity: {
							value: 1
						}
					}]),
					vertexShader: Dc.meshphysical_vert,
					fragmentShader: Dc.meshphysical_frag
				},
				points: {
					uniforms: Cs.merge([Os.points, Os.fog]),
					vertexShader: Dc.points_vert,
					fragmentShader: Dc.points_frag
				},
				dashed: {
					uniforms: Cs.merge([Os.common, Os.fog, {
						scale: {
							value: 1
						},
						dashSize: {
							value: 1
						},
						totalSize: {
							value: 2
						}
					}]),
					vertexShader: Dc.linedashed_vert,
					fragmentShader: Dc.linedashed_frag
				},
				depth: {
					uniforms: Cs.merge([Os.common, Os.displacementmap]),
					vertexShader: Dc.depth_vert,
					fragmentShader: Dc.depth_frag
				},
				normal: {
					uniforms: Cs.merge([Os.common, Os.bumpmap, Os.normalmap, Os.displacementmap, {
						opacity: {
							value: 1
						}
					}]),
					vertexShader: Dc.normal_vert,
					fragmentShader: Dc.normal_frag
				},
				cube: {
					uniforms: {
						tCube: {
							value: null
						},
						tFlip: {
							value: -1
						},
						opacity: {
							value: 1
						}
					},
					vertexShader: Dc.cube_vert,
					fragmentShader: Dc.cube_frag
				},
				equirect: {
					uniforms: {
						tEquirect: {
							value: null
						},
						tFlip: {
							value: -1
						}
					},
					vertexShader: Dc.equirect_vert,
					fragmentShader: Dc.equirect_frag
				},
				distanceRGBA: {
					uniforms: {
						lightPos: {
							value: new l
						}
					},
					vertexShader: Dc.distanceRGBA_vert,
					fragmentShader: Dc.distanceRGBA_frag
				}
			};
		Bc.physical = {
				uniforms: Cs.merge([Bc.standard.uniforms, {
					clearCoat: {
						value: 0
					},
					clearCoatRoughness: {
						value: 0
					}
				}]),
				vertexShader: Dc.meshphysical_vert,
				fragmentShader: Dc.meshphysical_frag
			},
			Object.assign(Y.prototype, {
				set: function(t, e) {
					return this.min.copy(t),
						this.max.copy(e),
						this
				},
				setFromPoints: function(t) {
					this.makeEmpty();
					for(var e = 0, n = t.length; e < n; e++)
						this.expandByPoint(t[e]);
					return this
				},
				setFromCenterAndSize: function() {
					var t = new n;
					return function(e, n) {
						var i = t.copy(n).multiplyScalar(.5);
						return this.min.copy(e).sub(i),
							this.max.copy(e).add(i),
							this
					}
				}(),
				clone: function() {
					return(new this.constructor).copy(this)
				},
				copy: function(t) {
					return this.min.copy(t.min),
						this.max.copy(t.max),
						this
				},
				makeEmpty: function() {
					return this.min.x = this.min.y = +(1 / 0),
						this.max.x = this.max.y = -(1 / 0),
						this
				},
				isEmpty: function() {
					return this.max.x < this.min.x || this.max.y < this.min.y
				},
				getCenter: function(t) {
					var e = t || new n;
					return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
				},
				getSize: function(t) {
					var e = t || new n;
					return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
				},
				expandByPoint: function(t) {
					return this.min.min(t),
						this.max.max(t),
						this
				},
				expandByVector: function(t) {
					return this.min.sub(t),
						this.max.add(t),
						this
				},
				expandByScalar: function(t) {
					return this.min.addScalar(-t),
						this.max.addScalar(t),
						this
				},
				containsPoint: function(t) {
					return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
				},
				containsBox: function(t) {
					return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
				},
				getParameter: function(t, e) {
					var i = e || new n;
					return i.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
				},
				intersectsBox: function(t) {
					return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
				},
				clampPoint: function(t, e) {
					var i = e || new n;
					return i.copy(t).clamp(this.min, this.max)
				},
				distanceToPoint: function() {
					var t = new n;
					return function(e) {
						var n = t.copy(e).clamp(this.min, this.max);
						return n.sub(e).length()
					}
				}(),
				intersect: function(t) {
					return this.min.max(t.min),
						this.max.min(t.max),
						this
				},
				union: function(t) {
					return this.min.min(t.min),
						this.max.max(t.max),
						this
				},
				translate: function(t) {
					return this.min.add(t),
						this.max.add(t),
						this
				},
				equals: function(t) {
					return t.min.equals(this.min) && t.max.equals(this.max)
				}
			});
		var Fc = 0;
		Object.assign(Q.prototype, e.prototype, {
				isMaterial: !0,
				setValues: function(t) {
					if(void 0 !== t)
						for(var e in t) {
							var n = t[e];
							if(void 0 !== n) {
								var i = this[e];
								void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : "overdraw" === e ? this[e] = Number(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
							} else
								console.warn("THREE.Material: '" + e + "' parameter is undefined.")
						}
				},
				toJSON: function(t) {
					function e(t) {
						var e = [];
						for(var n in t) {
							var i = t[n];
							delete i.metadata,
								e.push(i)
						}
						return e
					}
					var n = void 0 === t;
					n && (t = {
						textures: {},
						images: {}
					});
					var i = {
						metadata: {
							version: 4.5,
							type: "Material",
							generator: "Material.toJSON"
						}
					};
					if(i.uuid = this.uuid,
						i.type = this.type,
						"" !== this.name && (i.name = this.name),
						this.color && this.color.isColor && (i.color = this.color.getHex()),
						void 0 !== this.roughness && (i.roughness = this.roughness),
						void 0 !== this.metalness && (i.metalness = this.metalness),
						this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
						this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
						void 0 !== this.shininess && (i.shininess = this.shininess),
						void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat),
						void 0 !== this.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness),
						this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid),
						this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid),
						this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid),
						this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid,
							i.bumpScale = this.bumpScale),
						this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid,
							i.normalScale = this.normalScale.toArray()),
						this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid,
							i.displacementScale = this.displacementScale,
							i.displacementBias = this.displacementBias),
						this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid),
						this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid),
						this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid),
						this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid),
						this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid,
							i.reflectivity = this.reflectivity),
						this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid),
						void 0 !== this.size && (i.size = this.size),
						void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation),
						this.blending !== Mo && (i.blending = this.blending),
						this.shading !== yo && (i.shading = this.shading),
						this.side !== mo && (i.side = this.side),
						this.vertexColors !== bo && (i.vertexColors = this.vertexColors),
						this.opacity < 1 && (i.opacity = this.opacity),
						this.transparent === !0 && (i.transparent = this.transparent),
						i.depthFunc = this.depthFunc,
						i.depthTest = this.depthTest,
						i.depthWrite = this.depthWrite,
						this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
						this.premultipliedAlpha === !0 && (i.premultipliedAlpha = this.premultipliedAlpha),
						this.wireframe === !0 && (i.wireframe = this.wireframe),
						this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
						"round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap),
						"round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin),
						i.skinning = this.skinning,
						i.morphTargets = this.morphTargets,
						i.dithering = this.dithering,
						n) {
						var r = e(t.textures),
							o = e(t.images);
						r.length > 0 && (i.textures = r),
							o.length > 0 && (i.images = o)
					}
					return i
				},
				clone: function() {
					return(new this.constructor).copy(this)
				},
				copy: function(t) {
					this.name = t.name,
						this.fog = t.fog,
						this.lights = t.lights,
						this.blending = t.blending,
						this.side = t.side,
						this.shading = t.shading,
						this.vertexColors = t.vertexColors,
						this.opacity = t.opacity,
						this.transparent = t.transparent,
						this.blendSrc = t.blendSrc,
						this.blendDst = t.blendDst,
						this.blendEquation = t.blendEquation,
						this.blendSrcAlpha = t.blendSrcAlpha,
						this.blendDstAlpha = t.blendDstAlpha,
						this.blendEquationAlpha = t.blendEquationAlpha,
						this.depthFunc = t.depthFunc,
						this.depthTest = t.depthTest,
						this.depthWrite = t.depthWrite,
						this.colorWrite = t.colorWrite,
						this.precision = t.precision,
						this.polygonOffset = t.polygonOffset,
						this.polygonOffsetFactor = t.polygonOffsetFactor,
						this.polygonOffsetUnits = t.polygonOffsetUnits,
						this.dithering = t.dithering,
						this.alphaTest = t.alphaTest,
						this.premultipliedAlpha = t.premultipliedAlpha,
						this.overdraw = t.overdraw,
						this.visible = t.visible,
						this.clipShadows = t.clipShadows,
						this.clipIntersection = t.clipIntersection;
					var e = t.clippingPlanes,
						n = null;
					if(null !== e) {
						var i = e.length;
						n = new Array(i);
						for(var r = 0; r !== i; ++r)
							n[r] = e[r].clone()
					}
					return this.clippingPlanes = n,
						this
				},
				dispose: function() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
			}),
			J.prototype = Object.create(Q.prototype),
			J.prototype.constructor = J,
			J.prototype.isShaderMaterial = !0,
			J.prototype.copy = function(t) {
				return Q.prototype.copy.call(this, t),
					this.fragmentShader = t.fragmentShader,
					this.vertexShader = t.vertexShader,
					this.uniforms = Cs.clone(t.uniforms),
					this.defines = t.defines,
					this.wireframe = t.wireframe,
					this.wireframeLinewidth = t.wireframeLinewidth,
					this.lights = t.lights,
					this.clipping = t.clipping,
					this.skinning = t.skinning,
					this.morphTargets = t.morphTargets,
					this.morphNormals = t.morphNormals,
					this.extensions = t.extensions,
					this
			},
			J.prototype.toJSON = function(t) {
				var e = Q.prototype.toJSON.call(this, t);
				return e.uniforms = this.uniforms,
					e.vertexShader = this.vertexShader,
					e.fragmentShader = this.fragmentShader,
					e
			},
			K.prototype = Object.create(Q.prototype),
			K.prototype.constructor = K,
			K.prototype.isMeshDepthMaterial = !0,
			K.prototype.copy = function(t) {
				return Q.prototype.copy.call(this, t),
					this.depthPacking = t.depthPacking,
					this.skinning = t.skinning,
					this.morphTargets = t.morphTargets,
					this.map = t.map,
					this.alphaMap = t.alphaMap,
					this.displacementMap = t.displacementMap,
					this.displacementScale = t.displacementScale,
					this.displacementBias = t.displacementBias,
					this.wireframe = t.wireframe,
					this.wireframeLinewidth = t.wireframeLinewidth,
					this
			},
			Object.assign($.prototype, {
				isBox3: !0,
				set: function(t, e) {
					return this.min.copy(t),
						this.max.copy(e),
						this
				},
				setFromArray: function(t) {
					for(var e = +(1 / 0), n = +(1 / 0), i = +(1 / 0), r = -(1 / 0), o = -(1 / 0), a = -(1 / 0), s = 0, l = t.length; s < l; s += 3) {
						var c = t[s],
							u = t[s + 1],
							h = t[s + 2];
						c < e && (e = c),
							u < n && (n = u),
							h < i && (i = h),
							c > r && (r = c),
							u > o && (o = u),
							h > a && (a = h)
					}
					return this.min.set(e, n, i),
						this.max.set(r, o, a),
						this
				},
				setFromBufferAttribute: function(t) {
					for(var e = +(1 / 0), n = +(1 / 0), i = +(1 / 0), r = -(1 / 0), o = -(1 / 0), a = -(1 / 0), s = 0, l = t.count; s < l; s++) {
						var c = t.getX(s),
							u = t.getY(s),
							h = t.getZ(s);
						c < e && (e = c),
							u < n && (n = u),
							h < i && (i = h),
							c > r && (r = c),
							u > o && (o = u),
							h > a && (a = h)
					}
					return this.min.set(e, n, i),
						this.max.set(r, o, a),
						this
				},
				setFromPoints: function(t) {
					this.makeEmpty();
					for(var e = 0, n = t.length; e < n; e++)
						this.expandByPoint(t[e]);
					return this
				},
				setFromCenterAndSize: function() {
					var t = new l;
					return function(e, n) {
						var i = t.copy(n).multiplyScalar(.5);
						return this.min.copy(e).sub(i),
							this.max.copy(e).add(i),
							this
					}
				}(),
				setFromObject: function(t) {
					return this.makeEmpty(),
						this.expandByObject(t)
				},
				clone: function() {
					return(new this.constructor).copy(this)
				},
				copy: function(t) {
					return this.min.copy(t.min),
						this.max.copy(t.max),
						this
				},
				makeEmpty: function() {
					return this.min.x = this.min.y = this.min.z = +(1 / 0),
						this.max.x = this.max.y = this.max.z = -(1 / 0),
						this
				},
				isEmpty: function() {
					return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
				},
				getCenter: function(t) {
					var e = t || new l;
					return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
				},
				getSize: function(t) {
					var e = t || new l;
					return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
				},
				expandByPoint: function(t) {
					return this.min.min(t),
						this.max.max(t),
						this
				},
				expandByVector: function(t) {
					return this.min.sub(t),
						this.max.add(t),
						this
				},
				expandByScalar: function(t) {
					return this.min.addScalar(-t),
						this.max.addScalar(t),
						this
				},
				expandByObject: function() {
					var t = new l;
					return function(e) {
						var n = this;
						return e.updateMatrixWorld(!0),
							e.traverse(function(e) {
								var i, r, o = e.geometry;
								if(void 0 !== o)
									if(o.isGeometry) {
										var a = o.vertices;
										for(i = 0,
											r = a.length; i < r; i++)
											t.copy(a[i]),
											t.applyMatrix4(e.matrixWorld),
											n.expandByPoint(t)
									} else if(o.isBufferGeometry) {
									var s = o.attributes.position;
									if(void 0 !== s)
										for(i = 0,
											r = s.count; i < r; i++)
											t.fromBufferAttribute(s, i).applyMatrix4(e.matrixWorld),
											n.expandByPoint(t)
								}
							}),
							this
					}
				}(),
				containsPoint: function(t) {
					return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
				},
				containsBox: function(t) {
					return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
				},
				getParameter: function(t, e) {
					var n = e || new l;
					return n.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
				},
				intersectsBox: function(t) {
					return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
				},
				intersectsSphere: function() {
					var t = new l;
					return function(e) {
						return this.clampPoint(e.center, t),
							t.distanceToSquared(e.center) <= e.radius * e.radius
					}
				}(),
				intersectsPlane: function(t) {
					var e, n;
					return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
							n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
							n = t.normal.x * this.min.x),
						t.normal.y > 0 ? (e += t.normal.y * this.min.y,
							n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
							n += t.normal.y * this.min.y),
						t.normal.z > 0 ? (e += t.normal.z * this.min.z,
							n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
							n += t.normal.z * this.min.z),
						e <= t.constant && n >= t.constant
				},
				clampPoint: function(t, e) {
					var n = e || new l;
					return n.copy(t).clamp(this.min, this.max)
				},
				distanceToPoint: function() {
					var t = new l;
					return function(e) {
						var n = t.copy(e).clamp(this.min, this.max);
						return n.sub(e).length()
					}
				}(),
				getBoundingSphere: function() {
					var t = new l;
					return function(e) {
						var n = e || new tt;
						return this.getCenter(n.center),
							n.radius = .5 * this.getSize(t).length(),
							n
					}
				}(),
				intersect: function(t) {
					return this.min.max(t.min),
						this.max.min(t.max),
						this.isEmpty() && this.makeEmpty(),
						this
				},
				union: function(t) {
					return this.min.min(t.min),
						this.max.max(t.max),
						this
				},
				applyMatrix4: function() {
					var t = [new l, new l, new l, new l, new l, new l, new l, new l];
					return function(e) {
						return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
							t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
							t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
							t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
							t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
							t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
							t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
							t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
							this.setFromPoints(t),
							this)
					}
				}(),
				translate: function(t) {
					return this.min.add(t),
						this.max.add(t),
						this
				},
				equals: function(t) {
					return t.min.equals(this.min) && t.max.equals(this.max)
				}
			}),
			Object.assign(tt.prototype, {
				set: function(t, e) {
					return this.center.copy(t),
						this.radius = e,
						this
				},
				setFromPoints: function() {
					var t = new $;
					return function(e, n) {
						var i = this.center;
						void 0 !== n ? i.copy(n) : t.setFromPoints(e).getCenter(i);
						for(var r = 0, o = 0, a = e.length; o < a; o++)
							r = Math.max(r, i.distanceToSquared(e[o]));
						return this.radius = Math.sqrt(r),
							this
					}
				}(),
				clone: function() {
					return(new this.constructor).copy(this)
				},
				copy: function(t) {
					return this.center.copy(t.center),
						this.radius = t.radius,
						this
				},
				empty: function() {
					return this.radius <= 0
				},
				containsPoint: function(t) {
					return t.distanceToSquared(this.center) <= this.radius * this.radius
				},
				distanceToPoint: function(t) {
					return t.distanceTo(this.center) - this.radius
				},
				intersectsSphere: function(t) {
					var e = this.radius + t.radius;
					return t.center.distanceToSquared(this.center) <= e * e
				},
				intersectsBox: function(t) {
					return t.intersectsSphere(this)
				},
				intersectsPlane: function(t) {
					return Math.abs(this.center.dot(t.normal) - t.constant) <= this.radius
				},
				clampPoint: function(t, e) {
					var n = this.center.distanceToSquared(t),
						i = e || new l;
					return i.copy(t),
						n > this.radius * this.radius && (i.sub(this.center).normalize(),
							i.multiplyScalar(this.radius).add(this.center)),
						i
				},
				getBoundingBox: function(t) {
					var e = t || new $;
					return e.set(this.center, this.center),
						e.expandByScalar(this.radius),
						e
				},
				applyMatrix4: function(t) {
					return this.center.applyMatrix4(t),
						this.radius = this.radius * t.getMaxScaleOnAxis(),
						this
				},
				translate: function(t) {
					return this.center.add(t),
						this
				},
				equals: function(t) {
					return t.center.equals(this.center) && t.radius === this.radius
				}
			}),
			Object.assign(et.prototype, {
				isMatrix3: !0,
				set: function(t, e, n, i, r, o, a, s, l) {
					var c = this.elements;
					return c[0] = t,
						c[1] = i,
						c[2] = a,
						c[3] = e,
						c[4] = r,
						c[5] = s,
						c[6] = n,
						c[7] = o,
						c[8] = l,
						this
				},
				identity: function() {
					return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
						this
				},
				clone: function() {
					return(new this.constructor).fromArray(this.elements)
				},
				copy: function(t) {
					var e = this.elements,
						n = t.elements;
					return e[0] = n[0],
						e[1] = n[1],
						e[2] = n[2],
						e[3] = n[3],
						e[4] = n[4],
						e[5] = n[5],
						e[6] = n[6],
						e[7] = n[7],
						e[8] = n[8],
						this
				},
				setFromMatrix4: function(t) {
					var e = t.elements;
					return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
						this
				},
				applyToBufferAttribute: function() {
					var t = new l;
					return function(e) {
						for(var n = 0, i = e.count; n < i; n++)
							t.x = e.getX(n),
							t.y = e.getY(n),
							t.z = e.getZ(n),
							t.applyMatrix3(this),
							e.setXYZ(n, t.x, t.y, t.z);
						return e
					}
				}(),
				multiply: function(t) {
					return this.multiplyMatrices(this, t)
				},
				premultiply: function(t) {
					return this.multiplyMatrices(t, this)
				},
				multiplyMatrices: function(t, e) {
					var n = t.elements,
						i = e.elements,
						r = this.elements,
						o = n[0],
						a = n[3],
						s = n[6],
						l = n[1],
						c = n[4],
						u = n[7],
						h = n[2],
						d = n[5],
						f = n[8],
						p = i[0],
						m = i[3],
						v = i[6],
						g = i[1],
						_ = i[4],
						y = i[7],
						b = i[2],
						x = i[5],
						w = i[8];
					return r[0] = o * p + a * g + s * b,
						r[3] = o * m + a * _ + s * x,
						r[6] = o * v + a * y + s * w,
						r[1] = l * p + c * g + u * b,
						r[4] = l * m + c * _ + u * x,
						r[7] = l * v + c * y + u * w,
						r[2] = h * p + d * g + f * b,
						r[5] = h * m + d * _ + f * x,
						r[8] = h * v + d * y + f * w,
						this
				},
				multiplyScalar: function(t) {
					var e = this.elements;
					return e[0] *= t,
						e[3] *= t,
						e[6] *= t,
						e[1] *= t,
						e[4] *= t,
						e[7] *= t,
						e[2] *= t,
						e[5] *= t,
						e[8] *= t,
						this
				},
				determinant: function() {
					var t = this.elements,
						e = t[0],
						n = t[1],
						i = t[2],
						r = t[3],
						o = t[4],
						a = t[5],
						s = t[6],
						l = t[7],
						c = t[8];
					return e * o * c - e * a * l - n * r * c + n * a * s + i * r * l - i * o * s
				},
				getInverse: function(t, e) {
					t && t.isMatrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
					var n = t.elements,
						i = this.elements,
						r = n[0],
						o = n[1],
						a = n[2],
						s = n[3],
						l = n[4],
						c = n[5],
						u = n[6],
						h = n[7],
						d = n[8],
						f = d * l - c * h,
						p = c * u - d * s,
						m = h * s - l * u,
						v = r * f + o * p + a * m;
					if(0 === v) {
						var g = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
						if(e === !0)
							throw new Error(g);
						return console.warn(g),
							this.identity()
					}
					var _ = 1 / v;
					return i[0] = f * _,
						i[1] = (a * h - d * o) * _,
						i[2] = (c * o - a * l) * _,
						i[3] = p * _,
						i[4] = (d * r - a * u) * _,
						i[5] = (a * s - c * r) * _,
						i[6] = m * _,
						i[7] = (o * u - h * r) * _,
						i[8] = (l * r - o * s) * _,
						this
				},
				transpose: function() {
					var t, e = this.elements;
					return t = e[1],
						e[1] = e[3],
						e[3] = t,
						t = e[2],
						e[2] = e[6],
						e[6] = t,
						t = e[5],
						e[5] = e[7],
						e[7] = t,
						this
				},
				getNormalMatrix: function(t) {
					return this.setFromMatrix4(t).getInverse(this).transpose()
				},
				transposeIntoArray: function(t) {
					var e = this.elements;
					return t[0] = e[0],
						t[1] = e[3],
						t[2] = e[6],
						t[3] = e[1],
						t[4] = e[4],
						t[5] = e[7],
						t[6] = e[2],
						t[7] = e[5],
						t[8] = e[8],
						this
				},
				equals: function(t) {
					for(var e = this.elements, n = t.elements, i = 0; i < 9; i++)
						if(e[i] !== n[i])
							return !1;
					return !0
				},
				fromArray: function(t, e) {
					void 0 === e && (e = 0);
					for(var n = 0; n < 9; n++)
						this.elements[n] = t[n + e];
					return this
				},
				toArray: function(t, e) {
					void 0 === t && (t = []),
						void 0 === e && (e = 0);
					var n = this.elements;
					return t[e] = n[0],
						t[e + 1] = n[1],
						t[e + 2] = n[2],
						t[e + 3] = n[3],
						t[e + 4] = n[4],
						t[e + 5] = n[5],
						t[e + 6] = n[6],
						t[e + 7] = n[7],
						t[e + 8] = n[8],
						t
				}
			}),
			Object.assign(nt.prototype, {
				set: function(t, e) {
					return this.normal.copy(t),
						this.constant = e,
						this
				},
				setComponents: function(t, e, n, i) {
					return this.normal.set(t, e, n),
						this.constant = i,
						this
				},
				setFromNormalAndCoplanarPoint: function(t, e) {
					return this.normal.copy(t),
						this.constant = -e.dot(this.normal),
						this
				},
				setFromCoplanarPoints: function() {
					var t = new l,
						e = new l;
					return function(n, i, r) {
						var o = t.subVectors(r, i).cross(e.subVectors(n, i)).normalize();
						return this.setFromNormalAndCoplanarPoint(o, n),
							this
					}
				}(),
				clone: function() {
					return(new this.constructor).copy(this)
				},
				copy: function(t) {
					return this.normal.copy(t.normal),
						this.constant = t.constant,
						this
				},
				normalize: function() {
					var t = 1 / this.normal.length();
					return this.normal.multiplyScalar(t),
						this.constant *= t,
						this
				},
				negate: function() {
					return this.constant *= -1,
						this.normal.negate(),
						this
				},
				distanceToPoint: function(t) {
					return this.normal.dot(t) + this.constant
				},
				distanceToSphere: function(t) {
					return this.distanceToPoint(t.center) - t.radius
				},
				projectPoint: function(t, e) {
					return this.orthoPoint(t, e).sub(t).negate()
				},
				orthoPoint: function(t, e) {
					var n = this.distanceToPoint(t),
						i = e || new l;
					return i.copy(this.normal).multiplyScalar(n)
				},
				intersectLine: function() {
					var t = new l;
					return function(e, n) {
						var i = n || new l,
							r = e.delta(t),
							o = this.normal.dot(r);
						if(0 !== o) {
							var a = -(e.start.dot(this.normal) + this.constant) / o;
							if(!(a < 0 || a > 1))
								return i.copy(r).multiplyScalar(a).add(e.start)
						} else if(0 === this.distanceToPoint(e.start))
							return i.copy(e.start)
					}
				}(),
				intersectsLine: function(t) {
					var e = this.distanceToPoint(t.start),
						n = this.distanceToPoint(t.end);
					return e < 0 && n > 0 || n < 0 && e > 0
				},
				intersectsBox: function(t) {
					return t.intersectsPlane(this)
				},
				intersectsSphere: function(t) {
					return t.intersectsPlane(this)
				},
				coplanarPoint: function(t) {
					var e = t || new l;
					return e.copy(this.normal).multiplyScalar(-this.constant)
				},
				applyMatrix4: function() {
					var t = new l,
						e = new et;
					return function(n, i) {
						var r = this.coplanarPoint(t).applyMatrix4(n),
							o = i || e.getNormalMatrix(n),
							a = this.normal.applyMatrix3(o).normalize();
						return this.constant = -r.dot(a),
							this
					}
				}(),
				translate: function(t) {
					return this.constant = this.constant - t.dot(this.normal),
						this
				},
				equals: function(t) {
					return t.normal.equals(this.normal) && t.constant === this.constant
				}
			}),
			Object.assign(it.prototype, {
				set: function(t, e, n, i, r, o) {
					var a = this.planes;
					return a[0].copy(t),
						a[1].copy(e),
						a[2].copy(n),
						a[3].copy(i),
						a[4].copy(r),
						a[5].copy(o),
						this
				},
				clone: function() {
					return(new this.constructor).copy(this)
				},
				copy: function(t) {
					for(var e = this.planes, n = 0; n < 6; n++)
						e[n].copy(t.planes[n]);
					return this
				},
				setFromMatrix: function(t) {
					var e = this.planes,
						n = t.elements,
						i = n[0],
						r = n[1],
						o = n[2],
						a = n[3],
						s = n[4],
						l = n[5],
						c = n[6],
						u = n[7],
						h = n[8],
						d = n[9],
						f = n[10],
						p = n[11],
						m = n[12],
						v = n[13],
						g = n[14],
						_ = n[15];
					return e[0].setComponents(a - i, u - s, p - h, _ - m).normalize(),
						e[1].setComponents(a + i, u + s, p + h, _ + m).normalize(),
						e[2].setComponents(a + r, u + l, p + d, _ + v).normalize(),
						e[3].setComponents(a - r, u - l, p - d, _ - v).normalize(),
						e[4].setComponents(a - o, u - c, p - f, _ - g).normalize(),
						e[5].setComponents(a + o, u + c, p + f, _ + g).normalize(),
						this
				},
				intersectsObject: function() {
					var t = new tt;
					return function(e) {
						var n = e.geometry;
						return null === n.boundingSphere && n.computeBoundingSphere(),
							t.copy(n.boundingSphere).applyMatrix4(e.matrixWorld),
							this.intersectsSphere(t)
					}
				}(),
				intersectsSprite: function() {
					var t = new tt;
					return function(e) {
						return t.center.set(0, 0, 0),
							t.radius = .7071067811865476,
							t.applyMatrix4(e.matrixWorld),
							this.intersectsSphere(t)
					}
				}(),
				intersectsSphere: function(t) {
					for(var e = this.planes, n = t.center, i = -t.radius, r = 0; r < 6; r++) {
						var o = e[r].distanceToPoint(n);
						if(o < i)
							return !1
					}
					return !0
				},
				intersectsBox: function() {
					var t = new l,
						e = new l;
					return function(n) {
						for(var i = this.planes, r = 0; r < 6; r++) {
							var o = i[r];
							t.x = o.normal.x > 0 ? n.min.x : n.max.x,
								e.x = o.normal.x > 0 ? n.max.x : n.min.x,
								t.y = o.normal.y > 0 ? n.min.y : n.max.y,
								e.y = o.normal.y > 0 ? n.max.y : n.min.y,
								t.z = o.normal.z > 0 ? n.min.z : n.max.z,
								e.z = o.normal.z > 0 ? n.max.z : n.min.z;
							var a = o.distanceToPoint(t),
								s = o.distanceToPoint(e);
							if(a < 0 && s < 0)
								return !1
						}
						return !0
					}
				}(),
				containsPoint: function(t) {
					for(var e = this.planes, n = 0; n < 6; n++)
						if(e[n].distanceToPoint(t) < 0)
							return !1;
					return !0
				}
			}),
			Object.assign(ot.prototype, {
				set: function(t, e) {
					return this.origin.copy(t),
						this.direction.copy(e),
						this
				},
				clone: function() {
					return(new this.constructor).copy(this)
				},
				copy: function(t) {
					return this.origin.copy(t.origin),
						this.direction.copy(t.direction),
						this
				},
				at: function(t, e) {
					var n = e || new l;
					return n.copy(this.direction).multiplyScalar(t).add(this.origin)
				},
				lookAt: function(t) {
					return this.direction.copy(t).sub(this.origin).normalize(),
						this
				},
				recast: function() {
					var t = new l;
					return function(e) {
						return this.origin.copy(this.at(e, t)),
							this
					}
				}(),
				closestPointToPoint: function(t, e) {
					var n = e || new l;
					n.subVectors(t, this.origin);
					var i = n.dot(this.direction);
					return i < 0 ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(i).add(this.origin)
				},
				distanceToPoint: function(t) {
					return Math.sqrt(this.distanceSqToPoint(t))
				},
				distanceSqToPoint: function() {
					var t = new l;
					return function(e) {
						var n = t.subVectors(e, this.origin).dot(this.direction);
						return n < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(n).add(this.origin),
							t.distanceToSquared(e))
					}
				}(),
				distanceSqToSegment: function() {
					var t = new l,
						e = new l,
						n = new l;
					return function(i, r, o, a) {
						t.copy(i).add(r).multiplyScalar(.5),
							e.copy(r).sub(i).normalize(),
							n.copy(this.origin).sub(t);
						var s, l, c, u, h = .5 * i.distanceTo(r),
							d = -this.direction.dot(e),
							f = n.dot(this.direction),
							p = -n.dot(e),
							m = n.lengthSq(),
							v = Math.abs(1 - d * d);
						if(v > 0)
							if(s = d * p - f,
								l = d * f - p,
								u = h * v,
								s >= 0)
								if(l >= -u)
									if(l <= u) {
										var g = 1 / v;
										s *= g,
											l *= g,
											c = s * (s + d * l + 2 * f) + l * (d * s + l + 2 * p) + m
									} else
										l = h,
										s = Math.max(0, -(d * l + f)),
										c = -s * s + l * (l + 2 * p) + m;
						else
							l = -h,
							s = Math.max(0, -(d * l + f)),
							c = -s * s + l * (l + 2 * p) + m;
						else
							l <= -u ? (s = Math.max(0, -(-d * h + f)),
								l = s > 0 ? -h : Math.min(Math.max(-h, -p), h),
								c = -s * s + l * (l + 2 * p) + m) : l <= u ? (s = 0,
								l = Math.min(Math.max(-h, -p), h),
								c = l * (l + 2 * p) + m) : (s = Math.max(0, -(d * h + f)),
								l = s > 0 ? h : Math.min(Math.max(-h, -p), h),
								c = -s * s + l * (l + 2 * p) + m);
						else
							l = d > 0 ? -h : h,
							s = Math.max(0, -(d * l + f)),
							c = -s * s + l * (l + 2 * p) + m;
						return o && o.copy(this.direction).multiplyScalar(s).add(this.origin),
							a && a.copy(e).multiplyScalar(l).add(t),
							c
					}
				}(),
				intersectSphere: function() {
					var t = new l;
					return function(e, n) {
						t.subVectors(e.center, this.origin);
						var i = t.dot(this.direction),
							r = t.dot(t) - i * i,
							o = e.radius * e.radius;
						if(r > o)
							return null;
						var a = Math.sqrt(o - r),
							s = i - a,
							l = i + a;
						return s < 0 && l < 0 ? null : s < 0 ? this.at(l, n) : this.at(s, n)
					}
				}(),
				intersectsSphere: function(t) {
					return this.distanceToPoint(t.center) <= t.radius
				},
				distanceToPlane: function(t) {
					var e = t.normal.dot(this.direction);
					if(0 === e)
						return 0 === t.distanceToPoint(this.origin) ? 0 : null;
					var n = -(this.origin.dot(t.normal) + t.constant) / e;
					return n >= 0 ? n : null
				},
				intersectPlane: function(t, e) {
					var n = this.distanceToPlane(t);
					return null === n ? null : this.at(n, e)
				},
				intersectsPlane: function(t) {
					var e = t.distanceToPoint(this.origin);
					if(0 === e)
						return !0;
					var n = t.normal.dot(this.direction);
					return n * e < 0
				},
				intersectBox: function(t, e) {
					var n, i, r, o, a, s, l = 1 / this.direction.x,
						c = 1 / this.direction.y,
						u = 1 / this.direction.z,
						h = this.origin;
					return l >= 0 ? (n = (t.min.x - h.x) * l,
							i = (t.max.x - h.x) * l) : (n = (t.max.x - h.x) * l,
							i = (t.min.x - h.x) * l),
						c >= 0 ? (r = (t.min.y - h.y) * c,
							o = (t.max.y - h.y) * c) : (r = (t.max.y - h.y) * c,
							o = (t.min.y - h.y) * c),
						n > o || r > i ? null : ((r > n || n !== n) && (n = r),
							(o < i || i !== i) && (i = o),
							u >= 0 ? (a = (t.min.z - h.z) * u,
								s = (t.max.z - h.z) * u) : (a = (t.max.z - h.z) * u,
								s = (t.min.z - h.z) * u),
							n > s || a > i ? null : ((a > n || n !== n) && (n = a),
								(s < i || i !== i) && (i = s),
								i < 0 ? null : this.at(n >= 0 ? n : i, e)))
				},
				intersectsBox: function() {
					var t = new l;
					return function(e) {
						return null !== this.intersectBox(e, t)
					}
				}(),
				intersectTriangle: function() {
					var t = new l,
						e = new l,
						n = new l,
						i = new l;
					return function(r, o, a, s, l) {
						e.subVectors(o, r),
							n.subVectors(a, r),
							i.crossVectors(e, n);
						var c, u = this.direction.dot(i);
						if(u > 0) {
							if(s)
								return null;
							c = 1
						} else {
							if(!(u < 0))
								return null;
							c = -1,
								u = -u
						}
						t.subVectors(this.origin, r);
						var h = c * this.direction.dot(n.crossVectors(t, n));
						if(h < 0)
							return null;
						var d = c * this.direction.dot(e.cross(t));
						if(d < 0)
							return null;
						if(h + d > u)
							return null;
						var f = -c * t.dot(i);
						return f < 0 ? null : this.at(f / u, l)
					}
				}(),
				applyMatrix4: function(t) {
					return this.direction.add(this.origin).applyMatrix4(t),
						this.origin.applyMatrix4(t),
						this.direction.sub(this.origin),
						this.direction.normalize(),
						this
				},
				equals: function(t) {
					return t.origin.equals(this.origin) && t.direction.equals(this.direction)
				}
			}),
			at.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"],
			at.DefaultOrder = "XYZ",
			Object.defineProperties(at.prototype, {
				x: {
					get: function() {
						return this._x
					},
					set: function(t) {
						this._x = t,
							this.onChangeCallback()
					}
				},
				y: {
					get: function() {
						return this._y
					},
					set: function(t) {
						this._y = t,
							this.onChangeCallback()
					}
				},
				z: {
					get: function() {
						return this._z
					},
					set: function(t) {
						this._z = t,
							this.onChangeCallback()
					}
				},
				order: {
					get: function() {
						return this._order
					},
					set: function(t) {
						this._order = t,
							this.onChangeCallback()
					}
				}
			}),
			Object.assign(at.prototype, {
				isEuler: !0,
				set: function(t, e, n, i) {
					return this._x = t,
						this._y = e,
						this._z = n,
						this._order = i || this._order,
						this.onChangeCallback(),
						this
				},
				clone: function() {
					return new this.constructor(this._x, this._y, this._z, this._order)
				},
				copy: function(t) {
					return this._x = t._x,
						this._y = t._y,
						this._z = t._z,
						this._order = t._order,
						this.onChangeCallback(),
						this
				},
				setFromRotationMatrix: function(t, e, n) {
					var i = xs.clamp,
						r = t.elements,
						o = r[0],
						a = r[4],
						s = r[8],
						l = r[1],
						c = r[5],
						u = r[9],
						h = r[2],
						d = r[6],
						f = r[10];
					return e = e || this._order,
						"XYZ" === e ? (this._y = Math.asin(i(s, -1, 1)),
							Math.abs(s) < .99999 ? (this._x = Math.atan2(-u, f),
								this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(d, c),
								this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-i(u, -1, 1)),
							Math.abs(u) < .99999 ? (this._y = Math.atan2(s, f),
								this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, o),
								this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(i(d, -1, 1)),
							Math.abs(d) < .99999 ? (this._y = Math.atan2(-h, f),
								this._z = Math.atan2(-a, c)) : (this._y = 0,
								this._z = Math.atan2(l, o))) : "ZYX" === e ? (this._y = Math.asin(-i(h, -1, 1)),
							Math.abs(h) < .99999 ? (this._x = Math.atan2(d, f),
								this._z = Math.atan2(l, o)) : (this._x = 0,
								this._z = Math.atan2(-a, c))) : "YZX" === e ? (this._z = Math.asin(i(l, -1, 1)),
							Math.abs(l) < .99999 ? (this._x = Math.atan2(-u, c),
								this._y = Math.atan2(-h, o)) : (this._x = 0,
								this._y = Math.atan2(s, f))) : "XZY" === e ? (this._z = Math.asin(-i(a, -1, 1)),
							Math.abs(a) < .99999 ? (this._x = Math.atan2(d, c),
								this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-u, f),
								this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e),
						this._order = e,
						n !== !1 && this.onChangeCallback(),
						this
				},
				setFromQuaternion: function() {
					var t = new c;
					return function(e, n, i) {
						return t.makeRotationFromQuaternion(e),
							this.setFromRotationMatrix(t, n, i)
					}
				}(),
				setFromVector3: function(t, e) {
					return this.set(t.x, t.y, t.z, e || this._order)
				},
				reorder: function() {
					var t = new s;
					return function(e) {
						return t.setFromEuler(this),
							this.setFromQuaternion(t, e)
					}
				}(),
				equals: function(t) {
					return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
				},
				fromArray: function(t) {
					return this._x = t[0],
						this._y = t[1],
						this._z = t[2],
						void 0 !== t[3] && (this._order = t[3]),
						this.onChangeCallback(),
						this
				},
				toArray: function(t, e) {
					return void 0 === t && (t = []),
						void 0 === e && (e = 0),
						t[e] = this._x,
						t[e + 1] = this._y,
						t[e + 2] = this._z,
						t[e + 3] = this._order,
						t
				},
				toVector3: function(t) {
					return t ? t.set(this._x, this._y, this._z) : new l(this._x, this._y, this._z)
				},
				onChange: function(t) {
					return this.onChangeCallback = t,
						this
				},
				onChangeCallback: function() {}
			}),
			Object.assign(st.prototype, {
				set: function(t) {
					this.mask = 1 << t | 0
				},
				enable: function(t) {
					this.mask |= 1 << t | 0
				},
				toggle: function(t) {
					this.mask ^= 1 << t | 0
				},
				disable: function(t) {
					this.mask &= ~(1 << t | 0)
				},
				test: function(t) {
					return 0 !== (this.mask & t.mask)
				}
			});
		var zc = 0;
		lt.DefaultUp = new l(0, 1, 0),
			lt.DefaultMatrixAutoUpdate = !0,
			Object.assign(lt.prototype, e.prototype, {
				isObject3D: !0,
				applyMatrix: function(t) {
					this.matrix.multiplyMatrices(t, this.matrix),
						this.matrix.decompose(this.position, this.quaternion, this.scale)
				},
				setRotationFromAxisAngle: function(t, e) {
					this.quaternion.setFromAxisAngle(t, e)
				},
				setRotationFromEuler: function(t) {
					this.quaternion.setFromEuler(t, !0)
				},
				setRotationFromMatrix: function(t) {
					this.quaternion.setFromRotationMatrix(t)
				},
				setRotationFromQuaternion: function(t) {
					this.quaternion.copy(t)
				},
				rotateOnAxis: function() {
					var t = new s;
					return function(e, n) {
						return t.setFromAxisAngle(e, n),
							this.quaternion.multiply(t),
							this
					}
				}(),
				rotateX: function() {
					var t = new l(1, 0, 0);
					return function(e) {
						return this.rotateOnAxis(t, e)
					}
				}(),
				rotateY: function() {
					var t = new l(0, 1, 0);
					return function(e) {
						return this.rotateOnAxis(t, e)
					}
				}(),
				rotateZ: function() {
					var t = new l(0, 0, 1);
					return function(e) {
						return this.rotateOnAxis(t, e)
					}
				}(),
				translateOnAxis: function() {
					var t = new l;
					return function(e, n) {
						return t.copy(e).applyQuaternion(this.quaternion),
							this.position.add(t.multiplyScalar(n)),
							this
					}
				}(),
				translateX: function() {
					var t = new l(1, 0, 0);
					return function(e) {
						return this.translateOnAxis(t, e)
					}
				}(),
				translateY: function() {
					var t = new l(0, 1, 0);
					return function(e) {
						return this.translateOnAxis(t, e)
					}
				}(),
				translateZ: function() {
					var t = new l(0, 0, 1);
					return function(e) {
						return this.translateOnAxis(t, e)
					}
				}(),
				localToWorld: function(t) {
					return t.applyMatrix4(this.matrixWorld)
				},
				worldToLocal: function() {
					var t = new c;
					return function(e) {
						return e.applyMatrix4(t.getInverse(this.matrixWorld))
					}
				}(),
				lookAt: function() {
					var t = new c;
					return function(e) {
						this.isCamera ? t.lookAt(this.position, e, this.up) : t.lookAt(e, this.position, this.up),
							this.quaternion.setFromRotationMatrix(t)
					}
				}(),
				add: function(t) {
					if(arguments.length > 1) {
						for(var e = 0; e < arguments.length; e++)
							this.add(arguments[e]);
						return this
					}
					return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
						this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t),
							t.parent = this,
							t.dispatchEvent({
								type: "added"
							}),
							this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
						this)
				},
				remove: function(t) {
					if(arguments.length > 1)
						for(var e = 0; e < arguments.length; e++)
							this.remove(arguments[e]);
					var n = this.children.indexOf(t);
					n !== -1 && (t.parent = null,
						t.dispatchEvent({
							type: "removed"
						}),
						this.children.splice(n, 1))
				},
				getObjectById: function(t) {
					return this.getObjectByProperty("id", t)
				},
				getObjectByName: function(t) {
					return this.getObjectByProperty("name", t)
				},
				getObjectByProperty: function(t, e) {
					if(this[t] === e)
						return this;
					for(var n = 0, i = this.children.length; n < i; n++) {
						var r = this.children[n],
							o = r.getObjectByProperty(t, e);
						if(void 0 !== o)
							return o
					}
				},
				getWorldPosition: function(t) {
					var e = t || new l;
					return this.updateMatrixWorld(!0),
						e.setFromMatrixPosition(this.matrixWorld)
				},
				getWorldQuaternion: function() {
					var t = new l,
						e = new l;
					return function(n) {
						var i = n || new s;
						return this.updateMatrixWorld(!0),
							this.matrixWorld.decompose(t, i, e),
							i
					}
				}(),
				getWorldRotation: function() {
					var t = new s;
					return function(e) {
						var n = e || new at;
						return this.getWorldQuaternion(t),
							n.setFromQuaternion(t, this.rotation.order, !1)
					}
				}(),
				getWorldScale: function() {
					var t = new l,
						e = new s;
					return function(n) {
						var i = n || new l;
						return this.updateMatrixWorld(!0),
							this.matrixWorld.decompose(t, e, i),
							i
					}
				}(),
				getWorldDirection: function() {
					var t = new s;
					return function(e) {
						var n = e || new l;
						return this.getWorldQuaternion(t),
							n.set(0, 0, 1).applyQuaternion(t)
					}
				}(),
				raycast: function() {},
				traverse: function(t) {
					t(this);
					for(var e = this.children, n = 0, i = e.length; n < i; n++)
						e[n].traverse(t)
				},
				traverseVisible: function(t) {
					if(this.visible !== !1) {
						t(this);
						for(var e = this.children, n = 0, i = e.length; n < i; n++)
							e[n].traverseVisible(t)
					}
				},
				traverseAncestors: function(t) {
					var e = this.parent;
					null !== e && (t(e),
						e.traverseAncestors(t))
				},
				updateMatrix: function() {
					this.matrix.compose(this.position, this.quaternion, this.scale),
						this.matrixWorldNeedsUpdate = !0
				},
				updateMatrixWorld: function(t) {
					this.matrixAutoUpdate && this.updateMatrix(),
						(this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
							this.matrixWorldNeedsUpdate = !1,
							t = !0);
					for(var e = this.children, n = 0, i = e.length; n < i; n++)
						e[n].updateMatrixWorld(t)
				},
				toJSON: function(t) {
					function e(e, n) {
						return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)),
							n.uuid
					}

					function n(t) {
						var e = [];
						for(var n in t) {
							var i = t[n];
							delete i.metadata,
								e.push(i)
						}
						return e
					}
					var i = void 0 === t || "" === t,
						r = {};
					i && (t = {
							geometries: {},
							materials: {},
							textures: {},
							images: {}
						},
						r.metadata = {
							version: 4.5,
							type: "Object",
							generator: "Object3D.toJSON"
						});
					var o = {};
					if(o.uuid = this.uuid,
						o.type = this.type,
						"" !== this.name && (o.name = this.name),
						"{}" !== JSON.stringify(this.userData) && (o.userData = this.userData),
						this.castShadow === !0 && (o.castShadow = !0),
						this.receiveShadow === !0 && (o.receiveShadow = !0),
						this.visible === !1 && (o.visible = !1),
						o.matrix = this.matrix.toArray(),
						void 0 !== this.geometry && (o.geometry = e(t.geometries, this.geometry)),
						void 0 !== this.material)
						if(Array.isArray(this.material)) {
							for(var a = [], s = 0, l = this.material.length; s < l; s++)
								a.push(e(t.materials, this.material[s]));
							o.material = a
						} else
							o.material = e(t.materials, this.material);
					if(this.children.length > 0) {
						o.children = [];
						for(var s = 0; s < this.children.length; s++)
							o.children.push(this.children[s].toJSON(t).object)
					}
					if(i) {
						var c = n(t.geometries),
							u = n(t.materials),
							h = n(t.textures),
							d = n(t.images);
						c.length > 0 && (r.geometries = c),
							u.length > 0 && (r.materials = u),
							h.length > 0 && (r.textures = h),
							d.length > 0 && (r.images = d)
					}
					return r.object = o,
						r
				},
				clone: function(t) {
					return(new this.constructor).copy(this, t)
				},
				copy: function(t, e) {
					if(void 0 === e && (e = !0),
						this.name = t.name,
						this.up.copy(t.up),
						this.position.copy(t.position),
						this.quaternion.copy(t.quaternion),
						this.scale.copy(t.scale),
						this.matrix.copy(t.matrix),
						this.matrixWorld.copy(t.matrixWorld),
						this.matrixAutoUpdate = t.matrixAutoUpdate,
						this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
						this.layers.mask = t.layers.mask,
						this.visible = t.visible,
						this.castShadow = t.castShadow,
						this.receiveShadow = t.receiveShadow,
						this.frustumCulled = t.frustumCulled,
						this.renderOrder = t.renderOrder,
						this.userData = JSON.parse(JSON.stringify(t.userData)),
						e === !0)
						for(var n = 0; n < t.children.length; n++) {
							var i = t.children[n];
							this.add(i.clone())
						}
					return this
				}
			}),
			Object.assign(ct.prototype, {
				set: function(t, e) {
					return this.start.copy(t),
						this.end.copy(e),
						this
				},
				clone: function() {
					return(new this.constructor).copy(this)
				},
				copy: function(t) {
					return this.start.copy(t.start),
						this.end.copy(t.end),
						this
				},
				getCenter: function(t) {
					var e = t || new l;
					return e.addVectors(this.start, this.end).multiplyScalar(.5)
				},
				delta: function(t) {
					var e = t || new l;
					return e.subVectors(this.end, this.start)
				},
				distanceSq: function() {
					return this.start.distanceToSquared(this.end)
				},
				distance: function() {
					return this.start.distanceTo(this.end)
				},
				at: function(t, e) {
					var n = e || new l;
					return this.delta(n).multiplyScalar(t).add(this.start)
				},
				closestPointToPointParameter: function() {
					var t = new l,
						e = new l;
					return function(n, i) {
						t.subVectors(n, this.start),
							e.subVectors(this.end, this.start);
						var r = e.dot(e),
							o = e.dot(t),
							a = o / r;
						return i && (a = xs.clamp(a, 0, 1)),
							a
					}
				}(),
				closestPointToPoint: function(t, e, n) {
					var i = this.closestPointToPointParameter(t, e),
						r = n || new l;
					return this.delta(r).multiplyScalar(i).add(this.start)
				},
				applyMatrix4: function(t) {
					return this.start.applyMatrix4(t),
						this.end.applyMatrix4(t),
						this
				},
				equals: function(t) {
					return t.start.equals(this.start) && t.end.equals(this.end)
				}
			}),
			Object.assign(ut, {
				normal: function() {
					var t = new l;
					return function(e, n, i, r) {
						var o = r || new l;
						o.subVectors(i, n),
							t.subVectors(e, n),
							o.cross(t);
						var a = o.lengthSq();
						return a > 0 ? o.multiplyScalar(1 / Math.sqrt(a)) : o.set(0, 0, 0)
					}
				}(),
				barycoordFromPoint: function() {
					var t = new l,
						e = new l,
						n = new l;
					return function(i, r, o, a, s) {
						t.subVectors(a, r),
							e.subVectors(o, r),
							n.subVectors(i, r);
						var c = t.dot(t),
							u = t.dot(e),
							h = t.dot(n),
							d = e.dot(e),
							f = e.dot(n),
							p = c * d - u * u,
							m = s || new l;
						if(0 === p)
							return m.set(-2, -1, -1);
						var v = 1 / p,
							g = (d * h - u * f) * v,
							_ = (c * f - u * h) * v;
						return m.set(1 - g - _, _, g)
					}
				}(),
				containsPoint: function() {
					var t = new l;
					return function(e, n, i, r) {
						var o = ut.barycoordFromPoint(e, n, i, r, t);
						return o.x >= 0 && o.y >= 0 && o.x + o.y <= 1
					}
				}()
			}),
			Object.assign(ut.prototype, {
				set: function(t, e, n) {
					return this.a.copy(t),
						this.b.copy(e),
						this.c.copy(n),
						this
				},
				setFromPointsAndIndices: function(t, e, n, i) {
					return this.a.copy(t[e]),
						this.b.copy(t[n]),
						this.c.copy(t[i]),
						this
				},
				clone: function() {
					return(new this.constructor).copy(this)
				},
				copy: function(t) {
					return this.a.copy(t.a),
						this.b.copy(t.b),
						this.c.copy(t.c),
						this
				},
				area: function() {
					var t = new l,
						e = new l;
					return function() {
						return t.subVectors(this.c, this.b),
							e.subVectors(this.a, this.b),
							.5 * t.cross(e).length()
					}
				}(),
				midpoint: function(t) {
					var e = t || new l;
					return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
				},
				normal: function(t) {
					return ut.normal(this.a, this.b, this.c, t)
				},
				plane: function(t) {
					var e = t || new nt;
					return e.setFromCoplanarPoints(this.a, this.b, this.c)
				},
				barycoordFromPoint: function(t, e) {
					return ut.barycoordFromPoint(t, this.a, this.b, this.c, e)
				},
				containsPoint: function(t) {
					return ut.containsPoint(t, this.a, this.b, this.c)
				},
				closestPointToPoint: function() {
					var t = new nt,
						e = [new ct, new ct, new ct],
						n = new l,
						i = new l;
					return function(r, o) {
						var a = o || new l,
							s = 1 / 0;
						if(t.setFromCoplanarPoints(this.a, this.b, this.c),
							t.projectPoint(r, n),
							this.containsPoint(n) === !0)
							a.copy(n);
						else {
							e[0].set(this.a, this.b),
								e[1].set(this.b, this.c),
								e[2].set(this.c, this.a);
							for(var c = 0; c < e.length; c++) {
								e[c].closestPointToPoint(n, !0, i);
								var u = n.distanceToSquared(i);
								u < s && (s = u,
									a.copy(i))
							}
						}
						return a
					}
				}(),
				equals: function(t) {
					return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
				}
			}),
			Object.assign(ht.prototype, {
				clone: function() {
					return(new this.constructor).copy(this)
				},
				copy: function(t) {
					this.a = t.a,
						this.b = t.b,
						this.c = t.c,
						this.normal.copy(t.normal),
						this.color.copy(t.color),
						this.materialIndex = t.materialIndex;
					for(var e = 0, n = t.vertexNormals.length; e < n; e++)
						this.vertexNormals[e] = t.vertexNormals[e].clone();
					for(var e = 0, n = t.vertexColors.length; e < n; e++)
						this.vertexColors[e] = t.vertexColors[e].clone();
					return this
				}
			}),
			dt.prototype = Object.create(Q.prototype),
			dt.prototype.constructor = dt,
			dt.prototype.isMeshBasicMaterial = !0,
			dt.prototype.copy = function(t) {
				return Q.prototype.copy.call(this, t),
					this.color.copy(t.color),
					this.map = t.map,
					this.lightMap = t.lightMap,
					this.lightMapIntensity = t.lightMapIntensity,
					this.aoMap = t.aoMap,
					this.aoMapIntensity = t.aoMapIntensity,
					this.specularMap = t.specularMap,
					this.alphaMap = t.alphaMap,
					this.envMap = t.envMap,
					this.combine = t.combine,
					this.reflectivity = t.reflectivity,
					this.refractionRatio = t.refractionRatio,
					this.wireframe = t.wireframe,
					this.wireframeLinewidth = t.wireframeLinewidth,
					this.wireframeLinecap = t.wireframeLinecap,
					this.wireframeLinejoin = t.wireframeLinejoin,
					this.skinning = t.skinning,
					this.morphTargets = t.morphTargets,
					this
			},
			Object.defineProperty(ft.prototype, "needsUpdate", {
				set: function(t) {
					t === !0 && this.version++
				}
			}),
			Object.assign(ft.prototype, {
				isBufferAttribute: !0,
				setArray: function(t) {
					if(Array.isArray(t))
						throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
					this.count = void 0 !== t ? t.length / this.itemSize : 0,
						this.array = t
				},
				setDynamic: function(t) {
					return this.dynamic = t,
						this
				},
				copy: function(t) {
					return this.array = new t.array.constructor(t.array),
						this.itemSize = t.itemSize,
						this.count = t.count,
						this.normalized = t.normalized,
						this.dynamic = t.dynamic,
						this
				},
				copyAt: function(t, e, n) {
					t *= this.itemSize,
						n *= e.itemSize;
					for(var i = 0, r = this.itemSize; i < r; i++)
						this.array[t + i] = e.array[n + i];
					return this
				},
				copyArray: function(t) {
					return this.array.set(t),
						this
				},
				copyColorsArray: function(t) {
					for(var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
						var o = t[i];
						void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i),
								o = new W),
							e[n++] = o.r,
							e[n++] = o.g,
							e[n++] = o.b
					}
					return this
				},
				copyIndicesArray: function(t) {
					for(var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
						var o = t[i];
						e[n++] = o.a,
							e[n++] = o.b,
							e[n++] = o.c
					}
					return this
				},
				copyVector2sArray: function(t) {
					for(var e = this.array, i = 0, r = 0, o = t.length; r < o; r++) {
						var a = t[r];
						void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r),
								a = new n),
							e[i++] = a.x,
							e[i++] = a.y
					}
					return this
				},
				copyVector3sArray: function(t) {
					for(var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
						var o = t[i];
						void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i),
								o = new l),
							e[n++] = o.x,
							e[n++] = o.y,
							e[n++] = o.z
					}
					return this
				},
				copyVector4sArray: function(t) {
					for(var e = this.array, n = 0, i = 0, o = t.length; i < o; i++) {
						var a = t[i];
						void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i),
								a = new r),
							e[n++] = a.x,
							e[n++] = a.y,
							e[n++] = a.z,
							e[n++] = a.w
					}
					return this
				},
				set: function(t, e) {
					return void 0 === e && (e = 0),
						this.array.set(t, e),
						this
				},
				getX: function(t) {
					return this.array[t * this.itemSize]
				},
				setX: function(t, e) {
					return this.array[t * this.itemSize] = e,
						this
				},
				getY: function(t) {
					return this.array[t * this.itemSize + 1]
				},
				setY: function(t, e) {
					return this.array[t * this.itemSize + 1] = e,
						this
				},
				getZ: function(t) {
					return this.array[t * this.itemSize + 2]
				},
				setZ: function(t, e) {
					return this.array[t * this.itemSize + 2] = e,
						this
				},
				getW: function(t) {
					return this.array[t * this.itemSize + 3]
				},
				setW: function(t, e) {
					return this.array[t * this.itemSize + 3] = e,
						this
				},
				setXY: function(t, e, n) {
					return t *= this.itemSize,
						this.array[t + 0] = e,
						this.array[t + 1] = n,
						this
				},
				setXYZ: function(t, e, n, i) {
					return t *= this.itemSize,
						this.array[t + 0] = e,
						this.array[t + 1] = n,
						this.array[t + 2] = i,
						this
				},
				setXYZW: function(t, e, n, i, r) {
					return t *= this.itemSize,
						this.array[t + 0] = e,
						this.array[t + 1] = n,
						this.array[t + 2] = i,
						this.array[t + 3] = r,
						this
				},
				onUpload: function(t) {
					return this.onUploadCallback = t,
						this
				},
				clone: function() {
					return new this.constructor(this.array, this.itemSize).copy(this)
				}
			}),
			pt.prototype = Object.create(ft.prototype),
			pt.prototype.constructor = pt,
			mt.prototype = Object.create(ft.prototype),
			mt.prototype.constructor = mt,
			vt.prototype = Object.create(ft.prototype),
			vt.prototype.constructor = vt,
			gt.prototype = Object.create(ft.prototype),
			gt.prototype.constructor = gt,
			_t.prototype = Object.create(ft.prototype),
			_t.prototype.constructor = _t,
			yt.prototype = Object.create(ft.prototype),
			yt.prototype.constructor = yt,
			bt.prototype = Object.create(ft.prototype),
			bt.prototype.constructor = bt,
			xt.prototype = Object.create(ft.prototype),
			xt.prototype.constructor = xt,
			wt.prototype = Object.create(ft.prototype),
			wt.prototype.constructor = wt,
			Object.assign(Tt.prototype, {
				computeGroups: function(t) {
					for(var e, n = [], i = void 0, r = t.faces, o = 0; o < r.length; o++) {
						var a = r[o];
						a.materialIndex !== i && (i = a.materialIndex,
							void 0 !== e && (e.count = 3 * o - e.start,
								n.push(e)),
							e = {
								start: 3 * o,
								materialIndex: i
							})
					}
					void 0 !== e && (e.count = 3 * o - e.start,
							n.push(e)),
						this.groups = n
				},
				fromGeometry: function(t) {
					var e, i = t.faces,
						r = t.vertices,
						o = t.faceVertexUvs,
						a = o[0] && o[0].length > 0,
						s = o[1] && o[1].length > 0,
						l = t.morphTargets,
						c = l.length;
					if(c > 0) {
						e = [];
						for(var u = 0; u < c; u++)
							e[u] = [];
						this.morphTargets.position = e
					}
					var h, d = t.morphNormals,
						f = d.length;
					if(f > 0) {
						h = [];
						for(var u = 0; u < f; u++)
							h[u] = [];
						this.morphTargets.normal = h
					}
					for(var p = t.skinIndices, m = t.skinWeights, v = p.length === r.length, g = m.length === r.length, u = 0; u < i.length; u++) {
						var _ = i[u];
						this.vertices.push(r[_.a], r[_.b], r[_.c]);
						var y = _.vertexNormals;
						if(3 === y.length)
							this.normals.push(y[0], y[1], y[2]);
						else {
							var b = _.normal;
							this.normals.push(b, b, b)
						}
						var x = _.vertexColors;
						if(3 === x.length)
							this.colors.push(x[0], x[1], x[2]);
						else {
							var w = _.color;
							this.colors.push(w, w, w)
						}
						if(a === !0) {
							var T = o[0][u];
							void 0 !== T ? this.uvs.push(T[0], T[1], T[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", u),
								this.uvs.push(new n, new n, new n))
						}
						if(s === !0) {
							var T = o[1][u];
							void 0 !== T ? this.uvs2.push(T[0], T[1], T[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", u),
								this.uvs2.push(new n, new n, new n))
						}
						for(var M = 0; M < c; M++) {
							var E = l[M].vertices;
							e[M].push(E[_.a], E[_.b], E[_.c])
						}
						for(var M = 0; M < f; M++) {
							var S = d[M].vertexNormals[u];
							h[M].push(S.a, S.b, S.c)
						}
						v && this.skinIndices.push(p[_.a], p[_.b], p[_.c]),
							g && this.skinWeights.push(m[_.a], m[_.b], m[_.c])
					}
					return this.computeGroups(t),
						this.verticesNeedUpdate = t.verticesNeedUpdate,
						this.normalsNeedUpdate = t.normalsNeedUpdate,
						this.colorsNeedUpdate = t.colorsNeedUpdate,
						this.uvsNeedUpdate = t.uvsNeedUpdate,
						this.groupsNeedUpdate = t.groupsNeedUpdate,
						this
				}
			});
		var Nc = 0;
		Object.assign(St.prototype, e.prototype, {
				isGeometry: !0,
				applyMatrix: function(t) {
					for(var e = (new et).getNormalMatrix(t), n = 0, i = this.vertices.length; n < i; n++) {
						var r = this.vertices[n];
						r.applyMatrix4(t)
					}
					for(var n = 0, i = this.faces.length; n < i; n++) {
						var o = this.faces[n];
						o.normal.applyMatrix3(e).normalize();
						for(var a = 0, s = o.vertexNormals.length; a < s; a++)
							o.vertexNormals[a].applyMatrix3(e).normalize()
					}
					return null !== this.boundingBox && this.computeBoundingBox(),
						null !== this.boundingSphere && this.computeBoundingSphere(),
						this.verticesNeedUpdate = !0,
						this.normalsNeedUpdate = !0,
						this
				},
				rotateX: function() {
					var t = new c;
					return function(e) {
						return t.makeRotationX(e),
							this.applyMatrix(t),
							this
					}
				}(),
				rotateY: function() {
					var t = new c;
					return function(e) {
						return t.makeRotationY(e),
							this.applyMatrix(t),
							this
					}
				}(),
				rotateZ: function() {
					var t = new c;
					return function(e) {
						return t.makeRotationZ(e),
							this.applyMatrix(t),
							this
					}
				}(),
				translate: function() {
					var t = new c;
					return function(e, n, i) {
						return t.makeTranslation(e, n, i),
							this.applyMatrix(t),
							this
					}
				}(),
				scale: function() {
					var t = new c;
					return function(e, n, i) {
						return t.makeScale(e, n, i),
							this.applyMatrix(t),
							this
					}
				}(),
				lookAt: function() {
					var t = new lt;
					return function(e) {
						t.lookAt(e),
							t.updateMatrix(),
							this.applyMatrix(t.matrix)
					}
				}(),
				fromBufferGeometry: function(t) {
					function e(t, e, n, r) {
						var o = void 0 !== s ? [d[t].clone(), d[e].clone(), d[n].clone()] : [],
							a = void 0 !== c ? [i.colors[t].clone(), i.colors[e].clone(), i.colors[n].clone()] : [],
							l = new ht(t, e, n, o, a, r);
						i.faces.push(l),
							void 0 !== u && i.faceVertexUvs[0].push([f[t].clone(), f[e].clone(), f[n].clone()]),
							void 0 !== h && i.faceVertexUvs[1].push([p[t].clone(), p[e].clone(), p[n].clone()])
					}
					var i = this,
						r = null !== t.index ? t.index.array : void 0,
						o = t.attributes,
						a = o.position.array,
						s = void 0 !== o.normal ? o.normal.array : void 0,
						c = void 0 !== o.color ? o.color.array : void 0,
						u = void 0 !== o.uv ? o.uv.array : void 0,
						h = void 0 !== o.uv2 ? o.uv2.array : void 0;
					void 0 !== h && (this.faceVertexUvs[1] = []);
					for(var d = [], f = [], p = [], m = 0, v = 0; m < a.length; m += 3,
						v += 2)
						i.vertices.push(new l(a[m], a[m + 1], a[m + 2])),
						void 0 !== s && d.push(new l(s[m], s[m + 1], s[m + 2])),
						void 0 !== c && i.colors.push(new W(c[m], c[m + 1], c[m + 2])),
						void 0 !== u && f.push(new n(u[v], u[v + 1])),
						void 0 !== h && p.push(new n(h[v], h[v + 1]));
					var g = t.groups;
					if(g.length > 0)
						for(var m = 0; m < g.length; m++)
							for(var _ = g[m], y = _.start, b = _.count, v = y, x = y + b; v < x; v += 3)
								void 0 !== r ? e(r[v], r[v + 1], r[v + 2], _.materialIndex) : e(v, v + 1, v + 2, _.materialIndex);
					else if(void 0 !== r)
						for(var m = 0; m < r.length; m += 3)
							e(r[m], r[m + 1], r[m + 2]);
					else
						for(var m = 0; m < a.length / 3; m += 3)
							e(m, m + 1, m + 2);
					return this.computeFaceNormals(),
						null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
						null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
						this
				},
				center: function() {
					this.computeBoundingBox();
					var t = this.boundingBox.getCenter().negate();
					return this.translate(t.x, t.y, t.z),
						t
				},
				normalize: function() {
					this.computeBoundingSphere();
					var t = this.boundingSphere.center,
						e = this.boundingSphere.radius,
						n = 0 === e ? 1 : 1 / e,
						i = new c;
					return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1),
						this.applyMatrix(i),
						this
				},
				computeFaceNormals: function() {
					for(var t = new l, e = new l, n = 0, i = this.faces.length; n < i; n++) {
						var r = this.faces[n],
							o = this.vertices[r.a],
							a = this.vertices[r.b],
							s = this.vertices[r.c];
						t.subVectors(s, a),
							e.subVectors(o, a),
							t.cross(e),
							t.normalize(),
							r.normal.copy(t)
					}
				},
				computeVertexNormals: function(t) {
					void 0 === t && (t = !0);
					var e, n, i, r, o, a;
					for(a = new Array(this.vertices.length),
						e = 0,
						n = this.vertices.length; e < n; e++)
						a[e] = new l;
					if(t) {
						var s, c, u, h = new l,
							d = new l;
						for(i = 0,
							r = this.faces.length; i < r; i++)
							o = this.faces[i],
							s = this.vertices[o.a],
							c = this.vertices[o.b],
							u = this.vertices[o.c],
							h.subVectors(u, c),
							d.subVectors(s, c),
							h.cross(d),
							a[o.a].add(h),
							a[o.b].add(h),
							a[o.c].add(h)
					} else
						for(this.computeFaceNormals(),
							i = 0,
							r = this.faces.length; i < r; i++)
							o = this.faces[i],
							a[o.a].add(o.normal),
							a[o.b].add(o.normal),
							a[o.c].add(o.normal);
					for(e = 0,
						n = this.vertices.length; e < n; e++)
						a[e].normalize();
					for(i = 0,
						r = this.faces.length; i < r; i++) {
						o = this.faces[i];
						var f = o.vertexNormals;
						3 === f.length ? (f[0].copy(a[o.a]),
							f[1].copy(a[o.b]),
							f[2].copy(a[o.c])) : (f[0] = a[o.a].clone(),
							f[1] = a[o.b].clone(),
							f[2] = a[o.c].clone())
					}
					this.faces.length > 0 && (this.normalsNeedUpdate = !0)
				},
				computeFlatVertexNormals: function() {
					var t, e, n;
					for(this.computeFaceNormals(),
						t = 0,
						e = this.faces.length; t < e; t++) {
						n = this.faces[t];
						var i = n.vertexNormals;
						3 === i.length ? (i[0].copy(n.normal),
							i[1].copy(n.normal),
							i[2].copy(n.normal)) : (i[0] = n.normal.clone(),
							i[1] = n.normal.clone(),
							i[2] = n.normal.clone())
					}
					this.faces.length > 0 && (this.normalsNeedUpdate = !0)
				},
				computeMorphNormals: function() {
					var t, e, n, i, r;
					for(n = 0,
						i = this.faces.length; n < i; n++)
						for(r = this.faces[n],
							r.__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(),
							r.__originalVertexNormals || (r.__originalVertexNormals = []),
							t = 0,
							e = r.vertexNormals.length; t < e; t++)
							r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
					var o = new St;
					for(o.faces = this.faces,
						t = 0,
						e = this.morphTargets.length; t < e; t++) {
						if(!this.morphNormals[t]) {
							this.morphNormals[t] = {},
								this.morphNormals[t].faceNormals = [],
								this.morphNormals[t].vertexNormals = [];
							var a, s, c = this.morphNormals[t].faceNormals,
								u = this.morphNormals[t].vertexNormals;
							for(n = 0,
								i = this.faces.length; n < i; n++)
								a = new l,
								s = {
									a: new l,
									b: new l,
									c: new l
								},
								c.push(a),
								u.push(s)
						}
						var h = this.morphNormals[t];
						o.vertices = this.morphTargets[t].vertices,
							o.computeFaceNormals(),
							o.computeVertexNormals();
						var a, s;
						for(n = 0,
							i = this.faces.length; n < i; n++)
							r = this.faces[n],
							a = h.faceNormals[n],
							s = h.vertexNormals[n],
							a.copy(r.normal),
							s.a.copy(r.vertexNormals[0]),
							s.b.copy(r.vertexNormals[1]),
							s.c.copy(r.vertexNormals[2])
					}
					for(n = 0,
						i = this.faces.length; n < i; n++)
						r = this.faces[n],
						r.normal = r.__originalFaceNormal,
						r.vertexNormals = r.__originalVertexNormals
				},
				computeLineDistances: function() {
					for(var t = 0, e = this.vertices, n = 0, i = e.length; n < i; n++)
						n > 0 && (t += e[n].distanceTo(e[n - 1])),
						this.lineDistances[n] = t
				},
				computeBoundingBox: function() {
					null === this.boundingBox && (this.boundingBox = new $),
						this.boundingBox.setFromPoints(this.vertices)
				},
				computeBoundingSphere: function() {
					null === this.boundingSphere && (this.boundingSphere = new tt),
						this.boundingSphere.setFromPoints(this.vertices)
				},
				merge: function(t, e, n) {
					if((t && t.isGeometry) === !1)
						return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
					var i, r = this.vertices.length,
						o = this.vertices,
						a = t.vertices,
						s = this.faces,
						l = t.faces,
						c = this.faceVertexUvs[0],
						u = t.faceVertexUvs[0],
						h = this.colors,
						d = t.colors;
					void 0 === n && (n = 0),
						void 0 !== e && (i = (new et).getNormalMatrix(e));
					for(var f = 0, p = a.length; f < p; f++) {
						var m = a[f],
							v = m.clone();
						void 0 !== e && v.applyMatrix4(e),
							o.push(v)
					}
					for(var f = 0, p = d.length; f < p; f++)
						h.push(d[f].clone());
					for(f = 0,
						p = l.length; f < p; f++) {
						var g, _, y, b = l[f],
							x = b.vertexNormals,
							w = b.vertexColors;
						g = new ht(b.a + r, b.b + r, b.c + r),
							g.normal.copy(b.normal),
							void 0 !== i && g.normal.applyMatrix3(i).normalize();
						for(var T = 0, M = x.length; T < M; T++)
							_ = x[T].clone(),
							void 0 !== i && _.applyMatrix3(i).normalize(),
							g.vertexNormals.push(_);
						g.color.copy(b.color);
						for(var T = 0, M = w.length; T < M; T++)
							y = w[T],
							g.vertexColors.push(y.clone());
						g.materialIndex = b.materialIndex + n,
							s.push(g)
					}
					for(f = 0,
						p = u.length; f < p; f++) {
						var E = u[f],
							S = [];
						if(void 0 !== E) {
							for(var T = 0, M = E.length; T < M; T++)
								S.push(E[T].clone());
							c.push(S)
						}
					}
				},
				mergeMesh: function(t) {
					return(t && t.isMesh) === !1 ? void console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t) : (t.matrixAutoUpdate && t.updateMatrix(),
						void this.merge(t.geometry, t.matrix))
				},
				mergeVertices: function() {
					var t, e, n, i, r, o, a, s, l = {},
						c = [],
						u = [],
						h = 4,
						d = Math.pow(10, h);
					for(n = 0,
						i = this.vertices.length; n < i; n++)
						t = this.vertices[n],
						e = Math.round(t.x * d) + "_" + Math.round(t.y * d) + "_" + Math.round(t.z * d),
						void 0 === l[e] ? (l[e] = n,
							c.push(this.vertices[n]),
							u[n] = c.length - 1) : u[n] = u[l[e]];
					var f = [];
					for(n = 0,
						i = this.faces.length; n < i; n++) {
						r = this.faces[n],
							r.a = u[r.a],
							r.b = u[r.b],
							r.c = u[r.c],
							o = [r.a, r.b, r.c];
						for(var p = 0; p < 3; p++)
							if(o[p] === o[(p + 1) % 3]) {
								f.push(n);
								break
							}
					}
					for(n = f.length - 1; n >= 0; n--) {
						var m = f[n];
						for(this.faces.splice(m, 1),
							a = 0,
							s = this.faceVertexUvs.length; a < s; a++)
							this.faceVertexUvs[a].splice(m, 1)
					}
					var v = this.vertices.length - c.length;
					return this.vertices = c,
						v
				},
				sortFacesByMaterialIndex: function() {
					function t(t, e) {
						return t.materialIndex - e.materialIndex
					}
					for(var e = this.faces, n = e.length, i = 0; i < n; i++)
						e[i]._id = i;
					e.sort(t);
					var r, o, a = this.faceVertexUvs[0],
						s = this.faceVertexUvs[1];
					a && a.length === n && (r = []),
						s && s.length === n && (o = []);
					for(var i = 0; i < n; i++) {
						var l = e[i]._id;
						r && r.push(a[l]),
							o && o.push(s[l])
					}
					r && (this.faceVertexUvs[0] = r),
						o && (this.faceVertexUvs[1] = o)
				},
				toJSON: function() {
					function t(t, e, n) {
						return n ? t | 1 << e : t & ~(1 << e)
					}

					function e(t) {
						var e = t.x.toString() + t.y.toString() + t.z.toString();
						return void 0 !== d[e] ? d[e] : (d[e] = h.length / 3,
							h.push(t.x, t.y, t.z),
							d[e])
					}

					function n(t) {
						var e = t.r.toString() + t.g.toString() + t.b.toString();
						return void 0 !== p[e] ? p[e] : (p[e] = f.length,
							f.push(t.getHex()),
							p[e])
					}

					function i(t) {
						var e = t.x.toString() + t.y.toString();
						return void 0 !== v[e] ? v[e] : (v[e] = m.length / 2,
							m.push(t.x, t.y),
							v[e])
					}
					var r = {
						metadata: {
							version: 4.5,
							type: "Geometry",
							generator: "Geometry.toJSON"
						}
					};
					if(r.uuid = this.uuid,
						r.type = this.type,
						"" !== this.name && (r.name = this.name),
						void 0 !== this.parameters) {
						var o = this.parameters;
						for(var a in o)
							void 0 !== o[a] && (r[a] = o[a]);
						return r
					}
					for(var s = [], l = 0; l < this.vertices.length; l++) {
						var c = this.vertices[l];
						s.push(c.x, c.y, c.z)
					}
					for(var u = [], h = [], d = {}, f = [], p = {}, m = [], v = {}, l = 0; l < this.faces.length; l++) {
						var g = this.faces[l],
							_ = !0,
							y = !1,
							b = void 0 !== this.faceVertexUvs[0][l],
							x = g.normal.length() > 0,
							w = g.vertexNormals.length > 0,
							T = 1 !== g.color.r || 1 !== g.color.g || 1 !== g.color.b,
							M = g.vertexColors.length > 0,
							E = 0;
						if(E = t(E, 0, 0),
							E = t(E, 1, _),
							E = t(E, 2, y),
							E = t(E, 3, b),
							E = t(E, 4, x),
							E = t(E, 5, w),
							E = t(E, 6, T),
							E = t(E, 7, M),
							u.push(E),
							u.push(g.a, g.b, g.c),
							u.push(g.materialIndex),
							b) {
							var S = this.faceVertexUvs[0][l];
							u.push(i(S[0]), i(S[1]), i(S[2]))
						}
						if(x && u.push(e(g.normal)),
							w) {
							var X = g.vertexNormals;
							u.push(e(X[0]), e(X[1]), e(X[2]))
						}
						if(T && u.push(n(g.color)),
							M) {
							var A = g.vertexColors;
							u.push(n(A[0]), n(A[1]), n(A[2]))
						}
					}
					return r.data = {},
						r.data.vertices = s,
						r.data.normals = h,
						f.length > 0 && (r.data.colors = f),
						m.length > 0 && (r.data.uvs = [m]),
						r.data.faces = u,
						r
				},
				clone: function() {
					return(new St).copy(this)
				},
				copy: function(t) {
					var e, n, i, r, o, a;
					this.vertices = [],
						this.colors = [],
						this.faces = [],
						this.faceVertexUvs = [
							[]
						],
						this.morphTargets = [],
						this.morphNormals = [],
						this.skinWeights = [],
						this.skinIndices = [],
						this.lineDistances = [],
						this.boundingBox = null,
						this.boundingSphere = null,
						this.name = t.name;
					var s = t.vertices;
					for(e = 0,
						n = s.length; e < n; e++)
						this.vertices.push(s[e].clone());
					var l = t.colors;
					for(e = 0,
						n = l.length; e < n; e++)
						this.colors.push(l[e].clone());
					var c = t.faces;
					for(e = 0,
						n = c.length; e < n; e++)
						this.faces.push(c[e].clone());
					for(e = 0,
						n = t.faceVertexUvs.length; e < n; e++) {
						var u = t.faceVertexUvs[e];
						for(void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []),
							i = 0,
							r = u.length; i < r; i++) {
							var h = u[i],
								d = [];
							for(o = 0,
								a = h.length; o < a; o++) {
								var f = h[o];
								d.push(f.clone())
							}
							this.faceVertexUvs[e].push(d)
						}
					}
					var p = t.morphTargets;
					for(e = 0,
						n = p.length; e < n; e++) {
						var m = {};
						if(m.name = p[e].name,
							void 0 !== p[e].vertices)
							for(m.vertices = [],
								i = 0,
								r = p[e].vertices.length; i < r; i++)
								m.vertices.push(p[e].vertices[i].clone());
						if(void 0 !== p[e].normals)
							for(m.normals = [],
								i = 0,
								r = p[e].normals.length; i < r; i++)
								m.normals.push(p[e].normals[i].clone());
						this.morphTargets.push(m)
					}
					var v = t.morphNormals;
					for(e = 0,
						n = v.length; e < n; e++) {
						var g = {};
						if(void 0 !== v[e].vertexNormals)
							for(g.vertexNormals = [],
								i = 0,
								r = v[e].vertexNormals.length; i < r; i++) {
								var _ = v[e].vertexNormals[i],
									y = {};
								y.a = _.a.clone(),
									y.b = _.b.clone(),
									y.c = _.c.clone(),
									g.vertexNormals.push(y)
							}
						if(void 0 !== v[e].faceNormals)
							for(g.faceNormals = [],
								i = 0,
								r = v[e].faceNormals.length; i < r; i++)
								g.faceNormals.push(v[e].faceNormals[i].clone());
						this.morphNormals.push(g)
					}
					var b = t.skinWeights;
					for(e = 0,
						n = b.length; e < n; e++)
						this.skinWeights.push(b[e].clone());
					var x = t.skinIndices;
					for(e = 0,
						n = x.length; e < n; e++)
						this.skinIndices.push(x[e].clone());
					var w = t.lineDistances;
					for(e = 0,
						n = w.length; e < n; e++)
						this.lineDistances.push(w[e]);
					var T = t.boundingBox;
					null !== T && (this.boundingBox = T.clone());
					var M = t.boundingSphere;
					return null !== M && (this.boundingSphere = M.clone()),
						this.elementsNeedUpdate = t.elementsNeedUpdate,
						this.verticesNeedUpdate = t.verticesNeedUpdate,
						this.uvsNeedUpdate = t.uvsNeedUpdate,
						this.normalsNeedUpdate = t.normalsNeedUpdate,
						this.colorsNeedUpdate = t.colorsNeedUpdate,
						this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate,
						this.groupsNeedUpdate = t.groupsNeedUpdate,
						this
				},
				dispose: function() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
			}),
			Xt.MaxIndex = 65535,
			Object.assign(Xt.prototype, e.prototype, {
				isBufferGeometry: !0,
				getIndex: function() {
					return this.index
				},
				setIndex: function(t) {
					Array.isArray(t) ? this.index = new(Mt(t) > 65535 ? bt : _t)(t, 1) : this.index = t
				},
				addAttribute: function(t, e) {
					return(e && e.isBufferAttribute) === !1 && (e && e.isInterleavedBufferAttribute) === !1 ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
						void this.addAttribute(t, new ft(arguments[1], arguments[2]))) : "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
						void this.setIndex(e)) : (this.attributes[t] = e,
						this)
				},
				getAttribute: function(t) {
					return this.attributes[t]
				},
				removeAttribute: function(t) {
					return delete this.attributes[t],
						this
				},
				addGroup: function(t, e, n) {
					this.groups.push({
						start: t,
						count: e,
						materialIndex: void 0 !== n ? n : 0
					})
				},
				clearGroups: function() {
					this.groups = []
				},
				setDrawRange: function(t, e) {
					this.drawRange.start = t,
						this.drawRange.count = e
				},
				applyMatrix: function(t) {
					var e = this.attributes.position;
					void 0 !== e && (t.applyToBufferAttribute(e),
						e.needsUpdate = !0);
					var n = this.attributes.normal;
					if(void 0 !== n) {
						var i = (new et).getNormalMatrix(t);
						i.applyToBufferAttribute(n),
							n.needsUpdate = !0
					}
					return null !== this.boundingBox && this.computeBoundingBox(),
						null !== this.boundingSphere && this.computeBoundingSphere(),
						this
				},
				rotateX: function() {
					var t = new c;
					return function(e) {
						return t.makeRotationX(e),
							this.applyMatrix(t),
							this
					}
				}(),
				rotateY: function() {
					var t = new c;
					return function(e) {
						return t.makeRotationY(e),
							this.applyMatrix(t),
							this
					}
				}(),
				rotateZ: function() {
					var t = new c;
					return function(e) {
						return t.makeRotationZ(e),
							this.applyMatrix(t),
							this
					}
				}(),
				translate: function() {
					var t = new c;
					return function(e, n, i) {
						return t.makeTranslation(e, n, i),
							this.applyMatrix(t),
							this
					}
				}(),
				scale: function() {
					var t = new c;
					return function(e, n, i) {
						return t.makeScale(e, n, i),
							this.applyMatrix(t),
							this
					}
				}(),
				lookAt: function() {
					var t = new lt;
					return function(e) {
						t.lookAt(e),
							t.updateMatrix(),
							this.applyMatrix(t.matrix)
					}
				}(),
				center: function() {
					this.computeBoundingBox();
					var t = this.boundingBox.getCenter().negate();
					return this.translate(t.x, t.y, t.z),
						t
				},
				setFromObject: function(t) {
					var e = t.geometry;
					if(t.isPoints || t.isLine) {
						var n = new xt(3 * e.vertices.length, 3),
							i = new xt(3 * e.colors.length, 3);
						if(this.addAttribute("position", n.copyVector3sArray(e.vertices)),
							this.addAttribute("color", i.copyColorsArray(e.colors)),
							e.lineDistances && e.lineDistances.length === e.vertices.length) {
							var r = new xt(e.lineDistances.length, 1);
							this.addAttribute("lineDistance", r.copyArray(e.lineDistances))
						}
						null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
							null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
					} else
						t.isMesh && e && e.isGeometry && this.fromGeometry(e);
					return this
				},
				updateFromObject: function(t) {
					var e = t.geometry;
					if(t.isMesh) {
						var n = e.__directGeometry;
						if(e.elementsNeedUpdate === !0 && (n = void 0,
								e.elementsNeedUpdate = !1),
							void 0 === n)
							return this.fromGeometry(e);
						n.verticesNeedUpdate = e.verticesNeedUpdate,
							n.normalsNeedUpdate = e.normalsNeedUpdate,
							n.colorsNeedUpdate = e.colorsNeedUpdate,
							n.uvsNeedUpdate = e.uvsNeedUpdate,
							n.groupsNeedUpdate = e.groupsNeedUpdate,
							e.verticesNeedUpdate = !1,
							e.normalsNeedUpdate = !1,
							e.colorsNeedUpdate = !1,
							e.uvsNeedUpdate = !1,
							e.groupsNeedUpdate = !1,
							e = n
					}
					var i;
					return e.verticesNeedUpdate === !0 && (i = this.attributes.position,
							void 0 !== i && (i.copyVector3sArray(e.vertices),
								i.needsUpdate = !0),
							e.verticesNeedUpdate = !1),
						e.normalsNeedUpdate === !0 && (i = this.attributes.normal,
							void 0 !== i && (i.copyVector3sArray(e.normals),
								i.needsUpdate = !0),
							e.normalsNeedUpdate = !1),
						e.colorsNeedUpdate === !0 && (i = this.attributes.color,
							void 0 !== i && (i.copyColorsArray(e.colors),
								i.needsUpdate = !0),
							e.colorsNeedUpdate = !1),
						e.uvsNeedUpdate && (i = this.attributes.uv,
							void 0 !== i && (i.copyVector2sArray(e.uvs),
								i.needsUpdate = !0),
							e.uvsNeedUpdate = !1),
						e.lineDistancesNeedUpdate && (i = this.attributes.lineDistance,
							void 0 !== i && (i.copyArray(e.lineDistances),
								i.needsUpdate = !0),
							e.lineDistancesNeedUpdate = !1),
						e.groupsNeedUpdate && (e.computeGroups(t.geometry),
							this.groups = e.groups,
							e.groupsNeedUpdate = !1),
						this
				},
				fromGeometry: function(t) {
					return t.__directGeometry = (new Tt).fromGeometry(t),
						this.fromDirectGeometry(t.__directGeometry)
				},
				fromDirectGeometry: function(t) {
					var e = new Float32Array(3 * t.vertices.length);
					if(this.addAttribute("position", new ft(e, 3).copyVector3sArray(t.vertices)),
						t.normals.length > 0) {
						var n = new Float32Array(3 * t.normals.length);
						this.addAttribute("normal", new ft(n, 3).copyVector3sArray(t.normals))
					}
					if(t.colors.length > 0) {
						var i = new Float32Array(3 * t.colors.length);
						this.addAttribute("color", new ft(i, 3).copyColorsArray(t.colors))
					}
					if(t.uvs.length > 0) {
						var r = new Float32Array(2 * t.uvs.length);
						this.addAttribute("uv", new ft(r, 2).copyVector2sArray(t.uvs))
					}
					if(t.uvs2.length > 0) {
						var o = new Float32Array(2 * t.uvs2.length);
						this.addAttribute("uv2", new ft(o, 2).copyVector2sArray(t.uvs2))
					}
					if(t.indices.length > 0) {
						var a = Mt(t.indices) > 65535 ? Uint32Array : Uint16Array,
							s = new a(3 * t.indices.length);
						this.setIndex(new ft(s, 1).copyIndicesArray(t.indices))
					}
					this.groups = t.groups;
					for(var l in t.morphTargets) {
						for(var c = [], u = t.morphTargets[l], h = 0, d = u.length; h < d; h++) {
							var f = u[h],
								p = new xt(3 * f.length, 3);
							c.push(p.copyVector3sArray(f))
						}
						this.morphAttributes[l] = c
					}
					if(t.skinIndices.length > 0) {
						var m = new xt(4 * t.skinIndices.length, 4);
						this.addAttribute("skinIndex", m.copyVector4sArray(t.skinIndices))
					}
					if(t.skinWeights.length > 0) {
						var v = new xt(4 * t.skinWeights.length, 4);
						this.addAttribute("skinWeight", v.copyVector4sArray(t.skinWeights))
					}
					return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
						null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
						this
				},
				computeBoundingBox: function() {
					null === this.boundingBox && (this.boundingBox = new $);
					var t = this.attributes.position;
					void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(),
						(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
				},
				computeBoundingSphere: function() {
					var t = new $,
						e = new l;
					return function() {
						null === this.boundingSphere && (this.boundingSphere = new tt);
						var n = this.attributes.position;
						if(n) {
							var i = this.boundingSphere.center;
							t.setFromBufferAttribute(n),
								t.getCenter(i);
							for(var r = 0, o = 0, a = n.count; o < a; o++)
								e.x = n.getX(o),
								e.y = n.getY(o),
								e.z = n.getZ(o),
								r = Math.max(r, i.distanceToSquared(e));
							this.boundingSphere.radius = Math.sqrt(r),
								isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
						}
					}
				}(),
				computeFaceNormals: function() {},
				computeVertexNormals: function() {
					var t = this.index,
						e = this.attributes,
						n = this.groups;
					if(e.position) {
						var i = e.position.array;
						if(void 0 === e.normal)
							this.addAttribute("normal", new ft(new Float32Array(i.length), 3));
						else
							for(var r = e.normal.array, o = 0, a = r.length; o < a; o++)
								r[o] = 0;
						var s, c, u, h = e.normal.array,
							d = new l,
							f = new l,
							p = new l,
							m = new l,
							v = new l;
						if(t) {
							var g = t.array;
							0 === n.length && this.addGroup(0, g.length);
							for(var _ = 0, y = n.length; _ < y; ++_)
								for(var b = n[_], x = b.start, w = b.count, o = x, a = x + w; o < a; o += 3)
									s = 3 * g[o + 0],
									c = 3 * g[o + 1],
									u = 3 * g[o + 2],
									d.fromArray(i, s),
									f.fromArray(i, c),
									p.fromArray(i, u),
									m.subVectors(p, f),
									v.subVectors(d, f),
									m.cross(v),
									h[s] += m.x,
									h[s + 1] += m.y,
									h[s + 2] += m.z,
									h[c] += m.x,
									h[c + 1] += m.y,
									h[c + 2] += m.z,
									h[u] += m.x,
									h[u + 1] += m.y,
									h[u + 2] += m.z
						} else
							for(var o = 0, a = i.length; o < a; o += 9)
								d.fromArray(i, o),
								f.fromArray(i, o + 3),
								p.fromArray(i, o + 6),
								m.subVectors(p, f),
								v.subVectors(d, f),
								m.cross(v),
								h[o] = m.x,
								h[o + 1] = m.y,
								h[o + 2] = m.z,
								h[o + 3] = m.x,
								h[o + 4] = m.y,
								h[o + 5] = m.z,
								h[o + 6] = m.x,
								h[o + 7] = m.y,
								h[o + 8] = m.z;
						this.normalizeNormals(),
							e.normal.needsUpdate = !0
					}
				},
				merge: function(t, e) {
					if((t && t.isBufferGeometry) === !1)
						return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
					void 0 === e && (e = 0);
					var n = this.attributes;
					for(var i in n)
						if(void 0 !== t.attributes[i])
							for(var r = n[i], o = r.array, a = t.attributes[i], s = a.array, l = a.itemSize, c = 0, u = l * e; c < s.length; c++,
								u++)
								o[u] = s[c];
					return this
				},
				normalizeNormals: function() {
					for(var t, e, n, i, r = this.attributes.normal, o = 0, a = r.count; o < a; o++)
						t = r.getX(o),
						e = r.getY(o),
						n = r.getZ(o),
						i = 1 / Math.sqrt(t * t + e * e + n * n),
						r.setXYZ(o, t * i, e * i, n * i)
				},
				toNonIndexed: function() {
					if(null === this.index)
						return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
							this;
					var t = new Xt,
						e = this.index.array,
						n = this.attributes;
					for(var i in n) {
						for(var r = n[i], o = r.array, a = r.itemSize, s = new o.constructor(e.length * a), l = 0, c = 0, u = 0, h = e.length; u < h; u++) {
							l = e[u] * a;
							for(var d = 0; d < a; d++)
								s[c++] = o[l++]
						}
						t.addAttribute(i, new ft(s, a))
					}
					return t
				},
				toJSON: function() {
					var t = {
						metadata: {
							version: 4.5,
							type: "BufferGeometry",
							generator: "BufferGeometry.toJSON"
						}
					};
					if(t.uuid = this.uuid,
						t.type = this.type,
						"" !== this.name && (t.name = this.name),
						void 0 !== this.parameters) {
						var e = this.parameters;
						for(var n in e)
							void 0 !== e[n] && (t[n] = e[n]);
						return t
					}
					t.data = {
						attributes: {}
					};
					var i = this.index;
					if(null !== i) {
						var r = Array.prototype.slice.call(i.array);
						t.data.index = {
							type: i.array.constructor.name,
							array: r
						}
					}
					var o = this.attributes;
					for(var n in o) {
						var a = o[n],
							r = Array.prototype.slice.call(a.array);
						t.data.attributes[n] = {
							itemSize: a.itemSize,
							type: a.array.constructor.name,
							array: r,
							normalized: a.normalized
						}
					}
					var s = this.groups;
					s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
					var l = this.boundingSphere;
					return null !== l && (t.data.boundingSphere = {
							center: l.center.toArray(),
							radius: l.radius
						}),
						t
				},
				clone: function() {
					return(new Xt).copy(this)
				},
				copy: function(t) {
					var e, n, i;
					this.index = null,
						this.attributes = {},
						this.morphAttributes = {},
						this.groups = [],
						this.boundingBox = null,
						this.boundingSphere = null,
						this.name = t.name;
					var r = t.index;
					null !== r && this.setIndex(r.clone());
					var o = t.attributes;
					for(e in o) {
						var a = o[e];
						this.addAttribute(e, a.clone())
					}
					var s = t.morphAttributes;
					for(e in s) {
						var l = [],
							c = s[e];
						for(n = 0,
							i = c.length; n < i; n++)
							l.push(c[n].clone());
						this.morphAttributes[e] = l
					}
					var u = t.groups;
					for(n = 0,
						i = u.length; n < i; n++) {
						var h = u[n];
						this.addGroup(h.start, h.count, h.materialIndex)
					}
					var d = t.boundingBox;
					null !== d && (this.boundingBox = d.clone());
					var f = t.boundingSphere;
					return null !== f && (this.boundingSphere = f.clone()),
						this.drawRange.start = t.drawRange.start,
						this.drawRange.count = t.drawRange.count,
						this
				},
				dispose: function() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
			}),
			At.prototype = Object.assign(Object.create(lt.prototype), {
				constructor: At,
				isMesh: !0,
				setDrawMode: function(t) {
					this.drawMode = t
				},
				copy: function(t) {
					return lt.prototype.copy.call(this, t),
						this.drawMode = t.drawMode,
						this
				},
				updateMorphTargets: function() {
					var t = this.geometry.morphTargets;
					if(void 0 !== t && t.length > 0) {
						this.morphTargetInfluences = [],
							this.morphTargetDictionary = {};
						for(var e = 0, n = t.length; e < n; e++)
							this.morphTargetInfluences.push(0),
							this.morphTargetDictionary[t[e].name] = e
					}
				},
				raycast: function() {
					function t(t, e, n, i, r, o, a) {
						return ut.barycoordFromPoint(t, e, n, i, _),
							r.multiplyScalar(_.x),
							o.multiplyScalar(_.y),
							a.multiplyScalar(_.z),
							r.add(o).add(a),
							r.clone()
					}

					function e(t, e, n, i, r, o, a) {
						var s, l = t.material;
						if(s = l.side === vo ? n.intersectTriangle(o, r, i, !0, a) : n.intersectTriangle(i, r, o, l.side !== go, a),
							null === s)
							return null;
						b.copy(a),
							b.applyMatrix4(t.matrixWorld);
						var c = e.ray.origin.distanceTo(b);
						return c < e.near || c > e.far ? null : {
							distance: c,
							point: b.clone(),
							object: t
						}
					}

					function i(n, i, r, o, a, l, c, d) {
						s.fromBufferAttribute(o, l),
							u.fromBufferAttribute(o, c),
							h.fromBufferAttribute(o, d);
						var f = e(n, i, r, s, u, h, y);
						return f && (a && (m.fromBufferAttribute(a, l),
									v.fromBufferAttribute(a, c),
									g.fromBufferAttribute(a, d),
									f.uv = t(y, s, u, h, m, v, g)),
								f.face = new ht(l, c, d, ut.normal(s, u, h)),
								f.faceIndex = l),
							f
					}
					var r = new c,
						o = new ot,
						a = new tt,
						s = new l,
						u = new l,
						h = new l,
						d = new l,
						f = new l,
						p = new l,
						m = new n,
						v = new n,
						g = new n,
						_ = new l,
						y = new l,
						b = new l;
					return function(n, l) {
						var c = this.geometry,
							_ = this.material,
							b = this.matrixWorld;
						if(void 0 !== _ && (null === c.boundingSphere && c.computeBoundingSphere(),
								a.copy(c.boundingSphere),
								a.applyMatrix4(b),
								n.ray.intersectsSphere(a) !== !1 && (r.getInverse(b),
									o.copy(n.ray).applyMatrix4(r),
									null === c.boundingBox || o.intersectsBox(c.boundingBox) !== !1))) {
							var x;
							if(c.isBufferGeometry) {
								var w, T, M, E, S, X = c.index,
									A = c.attributes.position,
									P = c.attributes.uv;
								if(null !== X)
									for(E = 0,
										S = X.count; E < S; E += 3)
										w = X.getX(E),
										T = X.getX(E + 1),
										M = X.getX(E + 2),
										x = i(this, n, o, A, P, w, T, M),
										x && (x.faceIndex = Math.floor(E / 3),
											l.push(x));
								else
									for(E = 0,
										S = A.count; E < S; E += 3)
										w = E,
										T = E + 1,
										M = E + 2,
										x = i(this, n, o, A, P, w, T, M),
										x && (x.index = w,
											l.push(x))
							} else if(c.isGeometry) {
								var R, O, C, L, I = Array.isArray(_),
									D = c.vertices,
									B = c.faces,
									F = c.faceVertexUvs[0];
								F.length > 0 && (L = F);
								for(var z = 0, N = B.length; z < N; z++) {
									var k = B[z],
										U = I ? _[k.materialIndex] : _;
									if(void 0 !== U) {
										if(R = D[k.a],
											O = D[k.b],
											C = D[k.c],
											U.morphTargets === !0) {
											var j = c.morphTargets,
												V = this.morphTargetInfluences;
											s.set(0, 0, 0),
												u.set(0, 0, 0),
												h.set(0, 0, 0);
											for(var G = 0, H = j.length; G < H; G++) {
												var W = V[G];
												if(0 !== W) {
													var Y = j[G].vertices;
													s.addScaledVector(d.subVectors(Y[k.a], R), W),
														u.addScaledVector(f.subVectors(Y[k.b], O), W),
														h.addScaledVector(p.subVectors(Y[k.c], C), W)
												}
											}
											s.add(R),
												u.add(O),
												h.add(C),
												R = s,
												O = u,
												C = h
										}
										if(x = e(this, n, o, R, O, C, y)) {
											if(L && L[z]) {
												var q = L[z];
												m.copy(q[0]),
													v.copy(q[1]),
													g.copy(q[2]),
													x.uv = t(y, R, O, C, m, v, g)
											}
											x.face = k,
												x.faceIndex = z,
												l.push(x)
										}
									}
								}
							}
						}
					}
				}(),
				clone: function() {
					return new this.constructor(this.geometry, this.material).copy(this)
				}
			}),
			Pt.prototype = Object.create(St.prototype),
			Pt.prototype.constructor = Pt,
			Rt.prototype = Object.create(Xt.prototype),
			Rt.prototype.constructor = Rt,
			Ot.prototype = Object.create(St.prototype),
			Ot.prototype.constructor = Ot,
			Ct.prototype = Object.create(Xt.prototype),
			Ct.prototype.constructor = Ct,
			Lt.prototype = Object.assign(Object.create(lt.prototype), {
				constructor: Lt,
				isCamera: !0,
				copy: function(t) {
					return lt.prototype.copy.call(this, t),
						this.matrixWorldInverse.copy(t.matrixWorldInverse),
						this.projectionMatrix.copy(t.projectionMatrix),
						this
				},
				getWorldDirection: function() {
					var t = new s;
					return function(e) {
						var n = e || new l;
						return this.getWorldQuaternion(t),
							n.set(0, 0, -1).applyQuaternion(t)
					}
				}(),
				clone: function() {
					return(new this.constructor).copy(this)
				}
			}),
			It.prototype = Object.assign(Object.create(Lt.prototype), {
				constructor: It,
				isPerspectiveCamera: !0,
				copy: function(t) {
					return Lt.prototype.copy.call(this, t),
						this.fov = t.fov,
						this.zoom = t.zoom,
						this.near = t.near,
						this.far = t.far,
						this.focus = t.focus,
						this.aspect = t.aspect,
						this.view = null === t.view ? null : Object.assign({}, t.view),
						this.filmGauge = t.filmGauge,
						this.filmOffset = t.filmOffset,
						this
				},
				setFocalLength: function(t) {
					var e = .5 * this.getFilmHeight() / t;
					this.fov = 2 * xs.RAD2DEG * Math.atan(e),
						this.updateProjectionMatrix()
				},
				getFocalLength: function() {
					var t = Math.tan(.5 * xs.DEG2RAD * this.fov);
					return .5 * this.getFilmHeight() / t
				},
				getEffectiveFOV: function() {
					return 2 * xs.RAD2DEG * Math.atan(Math.tan(.5 * xs.DEG2RAD * this.fov) / this.zoom)
				},
				getFilmWidth: function() {
					return this.filmGauge * Math.min(this.aspect, 1)
				},
				getFilmHeight: function() {
					return this.filmGauge / Math.max(this.aspect, 1)
				},
				setViewOffset: function(t, e, n, i, r, o) {
					this.aspect = t / e,
						this.view = {
							fullWidth: t,
							fullHeight: e,
							offsetX: n,
							offsetY: i,
							width: r,
							height: o
						},
						this.updateProjectionMatrix()
				},
				clearViewOffset: function() {
					this.view = null,
						this.updateProjectionMatrix()
				},
				updateProjectionMatrix: function() {
					var t = this.near,
						e = t * Math.tan(.5 * xs.DEG2RAD * this.fov) / this.zoom,
						n = 2 * e,
						i = this.aspect * n,
						r = -.5 * i,
						o = this.view;
					if(null !== o) {
						var a = o.fullWidth,
							s = o.fullHeight;
						r += o.offsetX * i / a,
							e -= o.offsetY * n / s,
							i *= o.width / a,
							n *= o.height / s
					}
					var l = this.filmOffset;
					0 !== l && (r += t * l / this.getFilmWidth()),
						this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far)
				},
				toJSON: function(t) {
					var e = lt.prototype.toJSON.call(this, t);
					return e.object.fov = this.fov,
						e.object.zoom = this.zoom,
						e.object.near = this.near,
						e.object.far = this.far,
						e.object.focus = this.focus,
						e.object.aspect = this.aspect,
						null !== this.view && (e.object.view = Object.assign({}, this.view)),
						e.object.filmGauge = this.filmGauge,
						e.object.filmOffset = this.filmOffset,
						e
				}
			}),
			Dt.prototype = Object.assign(Object.create(Lt.prototype), {
				constructor: Dt,
				isOrthographicCamera: !0,
				copy: function(t) {
					return Lt.prototype.copy.call(this, t),
						this.left = t.left,
						this.right = t.right,
						this.top = t.top,
						this.bottom = t.bottom,
						this.near = t.near,
						this.far = t.far,
						this.zoom = t.zoom,
						this.view = null === t.view ? null : Object.assign({}, t.view),
						this
				},
				setViewOffset: function(t, e, n, i, r, o) {
					this.view = {
							fullWidth: t,
							fullHeight: e,
							offsetX: n,
							offsetY: i,
							width: r,
							height: o
						},
						this.updateProjectionMatrix()
				},
				clearViewOffset: function() {
					this.view = null,
						this.updateProjectionMatrix()
				},
				updateProjectionMatrix: function() {
					var t = (this.right - this.left) / (2 * this.zoom),
						e = (this.top - this.bottom) / (2 * this.zoom),
						n = (this.right + this.left) / 2,
						i = (this.top + this.bottom) / 2,
						r = n - t,
						o = n + t,
						a = i + e,
						s = i - e;
					if(null !== this.view) {
						var l = this.zoom / (this.view.width / this.view.fullWidth),
							c = this.zoom / (this.view.height / this.view.fullHeight),
							u = (this.right - this.left) / this.view.width,
							h = (this.top - this.bottom) / this.view.height;
						r += u * (this.view.offsetX / l),
							o = r + u * (this.view.width / l),
							a -= h * (this.view.offsetY / c),
							s = a - h * (this.view.height / c)
					}
					this.projectionMatrix.makeOrthographic(r, o, a, s, this.near, this.far)
				},
				toJSON: function(t) {
					var e = lt.prototype.toJSON.call(this, t);
					return e.object.zoom = this.zoom,
						e.object.left = this.left,
						e.object.right = this.right,
						e.object.top = this.top,
						e.object.bottom = this.bottom,
						e.object.near = this.near,
						e.object.far = this.far,
						null !== this.view && (e.object.view = Object.assign({}, this.view)),
						e
				}
			});
		var kc = 0;
		pe.prototype.isFogExp2 = !0,
			pe.prototype.clone = function() {
				return new pe(this.color.getHex(), this.density)
			},
			pe.prototype.toJSON = function(t) {
				return {
					type: "FogExp2",
					color: this.color.getHex(),
					density: this.density
				}
			},
			me.prototype.isFog = !0,
			me.prototype.clone = function() {
				return new me(this.color.getHex(), this.near, this.far)
			},
			me.prototype.toJSON = function(t) {
				return {
					type: "Fog",
					color: this.color.getHex(),
					near: this.near,
					far: this.far
				}
			},
			ve.prototype = Object.assign(Object.create(lt.prototype), {
				constructor: ve,
				copy: function(t, e) {
					return lt.prototype.copy.call(this, t, e),
						null !== t.background && (this.background = t.background.clone()),
						null !== t.fog && (this.fog = t.fog.clone()),
						null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
						this.autoUpdate = t.autoUpdate,
						this.matrixAutoUpdate = t.matrixAutoUpdate,
						this
				},
				toJSON: function(t) {
					var e = lt.prototype.toJSON.call(this, t);
					return null !== this.background && (e.object.background = this.background.toJSON(t)),
						null !== this.fog && (e.object.fog = this.fog.toJSON()),
						e
				}
			}),
			ge.prototype = Object.assign(Object.create(lt.prototype), {
				constructor: ge,
				isLensFlare: !0,
				copy: function(t) {
					lt.prototype.copy.call(this, t),
						this.positionScreen.copy(t.positionScreen),
						this.customUpdateCallback = t.customUpdateCallback;
					for(var e = 0, n = t.lensFlares.length; e < n; e++)
						this.lensFlares.push(t.lensFlares[e]);
					return this
				},
				add: function(t, e, n, i, r, o) {
					void 0 === e && (e = -1),
						void 0 === n && (n = 0),
						void 0 === o && (o = 1),
						void 0 === r && (r = new W(16777215)),
						void 0 === i && (i = Mo),
						n = Math.min(n, Math.max(0, n)),
						this.lensFlares.push({
							texture: t,
							size: e,
							distance: n,
							x: 0,
							y: 0,
							z: 0,
							scale: 1,
							rotation: 0,
							opacity: o,
							color: r,
							blending: i
						})
				},
				updateLensFlares: function() {
					var t, e, n = this.lensFlares.length,
						i = 2 * -this.positionScreen.x,
						r = 2 * -this.positionScreen.y;
					for(t = 0; t < n; t++)
						e = this.lensFlares[t],
						e.x = this.positionScreen.x + i * e.distance,
						e.y = this.positionScreen.y + r * e.distance,
						e.wantedRotation = e.x * Math.PI * .25,
						e.rotation += .25 * (e.wantedRotation - e.rotation)
				}
			}),
			_e.prototype = Object.create(Q.prototype),
			_e.prototype.constructor = _e,
			_e.prototype.isSpriteMaterial = !0,
			_e.prototype.copy = function(t) {
				return Q.prototype.copy.call(this, t),
					this.color.copy(t.color),
					this.map = t.map,
					this.rotation = t.rotation,
					this
			},
			ye.prototype = Object.assign(Object.create(lt.prototype), {
				constructor: ye,
				isSprite: !0,
				raycast: function() {
					var t = new l,
						e = new l,
						n = new l;
					return function(i, r) {
						e.setFromMatrixPosition(this.matrixWorld),
							i.ray.closestPointToPoint(e, t),
							n.setFromMatrixScale(this.matrixWorld);
						var o = n.x * n.y / 4;
						if(!(e.distanceToSquared(t) > o)) {
							var a = i.ray.origin.distanceTo(t);
							a < i.near || a > i.far || r.push({
								distance: a,
								point: t.clone(),
								face: null,
								object: this
							})
						}
					}
				}(),
				clone: function() {
					return new this.constructor(this.material).copy(this)
				}
			}),
			be.prototype = Object.assign(Object.create(lt.prototype), {
				constructor: be,
				copy: function(t) {
					lt.prototype.copy.call(this, t, !1);
					for(var e = t.levels, n = 0, i = e.length; n < i; n++) {
						var r = e[n];
						this.addLevel(r.object.clone(), r.distance)
					}
					return this
				},
				addLevel: function(t, e) {
					void 0 === e && (e = 0),
						e = Math.abs(e);
					for(var n = this.levels, i = 0; i < n.length && !(e < n[i].distance); i++)
					;
					n.splice(i, 0, {
							distance: e,
							object: t
						}),
						this.add(t)
				},
				getObjectForDistance: function(t) {
					for(var e = this.levels, n = 1, i = e.length; n < i && !(t < e[n].distance); n++)
					;
					return e[n - 1].object
				},
				raycast: function() {
					var t = new l;
					return function(e, n) {
						t.setFromMatrixPosition(this.matrixWorld);
						var i = e.ray.origin.distanceTo(t);
						this.getObjectForDistance(i).raycast(e, n)
					}
				}(),
				update: function() {
					var t = new l,
						e = new l;
					return function(n) {
						var i = this.levels;
						if(i.length > 1) {
							t.setFromMatrixPosition(n.matrixWorld),
								e.setFromMatrixPosition(this.matrixWorld);
							var r = t.distanceTo(e);
							i[0].object.visible = !0;
							for(var o = 1, a = i.length; o < a && r >= i[o].distance; o++)
								i[o - 1].object.visible = !1,
								i[o].object.visible = !0;
							for(; o < a; o++)
								i[o].object.visible = !1
						}
					}
				}(),
				toJSON: function(t) {
					var e = lt.prototype.toJSON.call(this, t);
					e.object.levels = [];
					for(var n = this.levels, i = 0, r = n.length; i < r; i++) {
						var o = n[i];
						e.object.levels.push({
							object: o.object.uuid,
							distance: o.distance
						})
					}
					return e
				}
			}),
			Object.assign(xe.prototype, {
				calculateInverses: function() {
					this.boneInverses = [];
					for(var t = 0, e = this.bones.length; t < e; t++) {
						var n = new c;
						this.bones[t] && n.getInverse(this.bones[t].matrixWorld),
							this.boneInverses.push(n)
					}
				},
				pose: function() {
					var t, e, n;
					for(e = 0,
						n = this.bones.length; e < n; e++)
						t = this.bones[e],
						t && t.matrixWorld.getInverse(this.boneInverses[e]);
					for(e = 0,
						n = this.bones.length; e < n; e++)
						t = this.bones[e],
						t && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld),
								t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld),
							t.matrix.decompose(t.position, t.quaternion, t.scale))
				},
				update: function() {
					var t = new c,
						e = new c;
					return function() {
						for(var n = this.bones, i = this.boneInverses, r = this.boneMatrices, o = this.boneTexture, a = 0, s = n.length; a < s; a++) {
							var l = n[a] ? n[a].matrixWorld : e;
							t.multiplyMatrices(l, i[a]),
								t.toArray(r, 16 * a)
						}
						void 0 !== o && (o.needsUpdate = !0)
					}
				}(),
				clone: function() {
					return new xe(this.bones, this.boneInverses)
				}
			}),
			we.prototype = Object.assign(Object.create(lt.prototype), {
				constructor: we,
				isBone: !0
			}),
			Te.prototype = Object.assign(Object.create(At.prototype), {
				constructor: Te,
				isSkinnedMesh: !0,
				initBones: function() {
					var t, e, n, i, r = [];
					if(this.geometry && void 0 !== this.geometry.bones) {
						for(n = 0,
							i = this.geometry.bones.length; n < i; n++)
							e = this.geometry.bones[n],
							t = new we,
							r.push(t),
							t.name = e.name,
							t.position.fromArray(e.pos),
							t.quaternion.fromArray(e.rotq),
							void 0 !== e.scl && t.scale.fromArray(e.scl);
						for(n = 0,
							i = this.geometry.bones.length; n < i; n++)
							e = this.geometry.bones[n],
							e.parent !== -1 && null !== e.parent && void 0 !== r[e.parent] ? r[e.parent].add(r[n]) : this.add(r[n])
					}
					return this.updateMatrixWorld(!0),
						r
				},
				bind: function(t, e) {
					this.skeleton = t,
						void 0 === e && (this.updateMatrixWorld(!0),
							this.skeleton.calculateInverses(),
							e = this.matrixWorld),
						this.bindMatrix.copy(e),
						this.bindMatrixInverse.getInverse(e)
				},
				pose: function() {
					this.skeleton.pose()
				},
				normalizeSkinWeights: function() {
					var t, e;
					if(this.geometry && this.geometry.isGeometry)
						for(e = 0; e < this.geometry.skinWeights.length; e++) {
							var n = this.geometry.skinWeights[e];
							t = 1 / n.lengthManhattan(),
								t !== 1 / 0 ? n.multiplyScalar(t) : n.set(1, 0, 0, 0)
						}
					else if(this.geometry && this.geometry.isBufferGeometry) {
						var i = new r,
							o = this.geometry.attributes.skinWeight;
						for(e = 0; e < o.count; e++)
							i.x = o.getX(e),
							i.y = o.getY(e),
							i.z = o.getZ(e),
							i.w = o.getW(e),
							t = 1 / i.lengthManhattan(),
							t !== 1 / 0 ? i.multiplyScalar(t) : i.set(1, 0, 0, 0),
							o.setXYZW(e, i.x, i.y, i.z, i.w)
					}
				},
				updateMatrixWorld: function(t) {
					At.prototype.updateMatrixWorld.call(this, t),
						"attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
				},
				clone: function() {
					return new this.constructor(this.geometry, this.material).copy(this)
				}
			}),
			Me.prototype = Object.create(Q.prototype),
			Me.prototype.constructor = Me,
			Me.prototype.isLineBasicMaterial = !0,
			Me.prototype.copy = function(t) {
				return Q.prototype.copy.call(this, t),
					this.color.copy(t.color),
					this.linewidth = t.linewidth,
					this.linecap = t.linecap,
					this.linejoin = t.linejoin,
					this
			},
			Ee.prototype = Object.assign(Object.create(lt.prototype), {
				constructor: Ee,
				isLine: !0,
				raycast: function() {
					var t = new c,
						e = new ot,
						n = new tt;
					return function(i, r) {
						var o = i.linePrecision,
							a = o * o,
							s = this.geometry,
							c = this.matrixWorld;
						if(null === s.boundingSphere && s.computeBoundingSphere(),
							n.copy(s.boundingSphere),
							n.applyMatrix4(c),
							i.ray.intersectsSphere(n) !== !1) {
							t.getInverse(c),
								e.copy(i.ray).applyMatrix4(t);
							var u = new l,
								h = new l,
								d = new l,
								f = new l,
								p = this && this.isLineSegments ? 2 : 1;
							if(s.isBufferGeometry) {
								var m = s.index,
									v = s.attributes,
									g = v.position.array;
								if(null !== m)
									for(var _ = m.array, y = 0, b = _.length - 1; y < b; y += p) {
										var x = _[y],
											w = _[y + 1];
										u.fromArray(g, 3 * x),
											h.fromArray(g, 3 * w);
										var T = e.distanceSqToSegment(u, h, f, d);
										if(!(T > a)) {
											f.applyMatrix4(this.matrixWorld);
											var M = i.ray.origin.distanceTo(f);
											M < i.near || M > i.far || r.push({
												distance: M,
												point: d.clone().applyMatrix4(this.matrixWorld),
												index: y,
												face: null,
												faceIndex: null,
												object: this
											})
										}
									}
								else
									for(var y = 0, b = g.length / 3 - 1; y < b; y += p) {
										u.fromArray(g, 3 * y),
											h.fromArray(g, 3 * y + 3);
										var T = e.distanceSqToSegment(u, h, f, d);
										if(!(T > a)) {
											f.applyMatrix4(this.matrixWorld);
											var M = i.ray.origin.distanceTo(f);
											M < i.near || M > i.far || r.push({
												distance: M,
												point: d.clone().applyMatrix4(this.matrixWorld),
												index: y,
												face: null,
												faceIndex: null,
												object: this
											})
										}
									}
							} else if(s.isGeometry)
								for(var E = s.vertices, S = E.length, y = 0; y < S - 1; y += p) {
									var T = e.distanceSqToSegment(E[y], E[y + 1], f, d);
									if(!(T > a)) {
										f.applyMatrix4(this.matrixWorld);
										var M = i.ray.origin.distanceTo(f);
										M < i.near || M > i.far || r.push({
											distance: M,
											point: d.clone().applyMatrix4(this.matrixWorld),
											index: y,
											face: null,
											faceIndex: null,
											object: this
										})
									}
								}
						}
					}
				}(),
				clone: function() {
					return new this.constructor(this.geometry, this.material).copy(this)
				}
			}),
			Se.prototype = Object.assign(Object.create(Ee.prototype), {
				constructor: Se,
				isLineSegments: !0
			}),
			Xe.prototype = Object.assign(Object.create(Ee.prototype), {
				constructor: Xe,
				isLineLoop: !0
			}),
			Ae.prototype = Object.create(Q.prototype),
			Ae.prototype.constructor = Ae,
			Ae.prototype.isPointsMaterial = !0,
			Ae.prototype.copy = function(t) {
				return Q.prototype.copy.call(this, t),
					this.color.copy(t.color),
					this.map = t.map,
					this.size = t.size,
					this.sizeAttenuation = t.sizeAttenuation,
					this
			},
			Pe.prototype = Object.assign(Object.create(lt.prototype), {
				constructor: Pe,
				isPoints: !0,
				raycast: function() {
					var t = new c,
						e = new ot,
						n = new tt;
					return function(i, r) {
						function o(t, n) {
							var o = e.distanceSqToPoint(t);
							if(o < d) {
								var s = e.closestPointToPoint(t);
								s.applyMatrix4(c);
								var l = i.ray.origin.distanceTo(s);
								if(l < i.near || l > i.far)
									return;
								r.push({
									distance: l,
									distanceToRay: Math.sqrt(o),
									point: s.clone(),
									index: n,
									face: null,
									object: a
								})
							}
						}
						var a = this,
							s = this.geometry,
							c = this.matrixWorld,
							u = i.params.Points.threshold;
						if(null === s.boundingSphere && s.computeBoundingSphere(),
							n.copy(s.boundingSphere),
							n.applyMatrix4(c),
							n.radius += u,
							i.ray.intersectsSphere(n) !== !1) {
							t.getInverse(c),
								e.copy(i.ray).applyMatrix4(t);
							var h = u / ((this.scale.x + this.scale.y + this.scale.z) / 3),
								d = h * h,
								f = new l;
							if(s.isBufferGeometry) {
								var p = s.index,
									m = s.attributes,
									v = m.position.array;
								if(null !== p)
									for(var g = p.array, _ = 0, y = g.length; _ < y; _++) {
										var b = g[_];
										f.fromArray(v, 3 * b),
											o(f, b)
									}
								else
									for(var _ = 0, x = v.length / 3; _ < x; _++)
										f.fromArray(v, 3 * _),
										o(f, _)
							} else
								for(var w = s.vertices, _ = 0, x = w.length; _ < x; _++)
									o(w[_], _)
						}
					}
				}(),
				clone: function() {
					return new this.constructor(this.geometry, this.material).copy(this)
				}
			}),
			Re.prototype = Object.assign(Object.create(lt.prototype), {
				constructor: Re
			}),
			Oe.prototype = Object.create(i.prototype),
			Oe.prototype.constructor = Oe,
			Ce.prototype = Object.create(i.prototype),
			Ce.prototype.constructor = Ce,
			Ce.prototype.isCompressedTexture = !0,
			Le.prototype = Object.create(i.prototype),
			Le.prototype.constructor = Le,
			Ie.prototype = Object.create(i.prototype),
			Ie.prototype.constructor = Ie,
			Ie.prototype.isDepthTexture = !0,
			De.prototype = Object.create(Xt.prototype),
			De.prototype.constructor = De,
			Be.prototype = Object.create(St.prototype),
			Be.prototype.constructor = Be,
			Fe.prototype = Object.create(Xt.prototype),
			Fe.prototype.constructor = Fe,
			ze.prototype = Object.create(St.prototype),
			ze.prototype.constructor = ze,
			Ne.prototype = Object.create(Xt.prototype),
			Ne.prototype.constructor = Ne,
			ke.prototype = Object.create(St.prototype),
			ke.prototype.constructor = ke,
			Ue.prototype = Object.create(Ne.prototype),
			Ue.prototype.constructor = Ue,
			je.prototype = Object.create(St.prototype),
			je.prototype.constructor = je,
			Ve.prototype = Object.create(Ne.prototype),
			Ve.prototype.constructor = Ve,
			Ge.prototype = Object.create(St.prototype),
			Ge.prototype.constructor = Ge,
			He.prototype = Object.create(Ne.prototype),
			He.prototype.constructor = He,
			We.prototype = Object.create(St.prototype),
			We.prototype.constructor = We,
			Ye.prototype = Object.create(Ne.prototype),
			Ye.prototype.constructor = Ye,
			qe.prototype = Object.create(St.prototype),
			qe.prototype.constructor = qe,
			Ze.prototype = Object.create(Xt.prototype),
			Ze.prototype.constructor = Ze,
			Qe.prototype = Object.create(St.prototype),
			Qe.prototype.constructor = Qe,
			Je.prototype = Object.create(Xt.prototype),
			Je.prototype.constructor = Je,
			Ke.prototype = Object.create(St.prototype),
			Ke.prototype.constructor = Ke,
			$e.prototype = Object.create(Xt.prototype),
			$e.prototype.constructor = $e;
		var Uc = {
			area: function(t) {
				for(var e = t.length, n = 0, i = e - 1, r = 0; r < e; i = r++)
					n += t[i].x * t[r].y - t[r].x * t[i].y;
				return .5 * n
			},
			triangulate: function() {
				function t(t, e, n, i, r, o) {
					var a, s, l, c, u, h, d, f, p;
					if(s = t[o[e]].x,
						l = t[o[e]].y,
						c = t[o[n]].x,
						u = t[o[n]].y,
						h = t[o[i]].x,
						d = t[o[i]].y,
						(c - s) * (d - l) - (u - l) * (h - s) <= 0)
						return !1;
					var m, v, g, _, y, b, x, w, T, M, E, S, X, A, P;
					for(m = h - c,
						v = d - u,
						g = s - h,
						_ = l - d,
						y = c - s,
						b = u - l,
						a = 0; a < r; a++)
						if(f = t[o[a]].x,
							p = t[o[a]].y, !(f === s && p === l || f === c && p === u || f === h && p === d) && (x = f - s,
								w = p - l,
								T = f - c,
								M = p - u,
								E = f - h,
								S = p - d,
								P = m * M - v * T,
								X = y * w - b * x,
								A = g * S - _ * E,
								P >= -Number.EPSILON && A >= -Number.EPSILON && X >= -Number.EPSILON))
							return !1;
					return !0
				}
				return function(e, n) {
					var i = e.length;
					if(i < 3)
						return null;
					var r, o, a, s = [],
						l = [],
						c = [];
					if(Uc.area(e) > 0)
						for(o = 0; o < i; o++)
							l[o] = o;
					else
						for(o = 0; o < i; o++)
							l[o] = i - 1 - o;
					var u = i,
						h = 2 * u;
					for(o = u - 1; u > 2;) {
						if(h-- <= 0)
							return console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"),
								n ? c : s;
						if(r = o,
							u <= r && (r = 0),
							o = r + 1,
							u <= o && (o = 0),
							a = o + 1,
							u <= a && (a = 0),
							t(e, r, o, a, u, l)) {
							var d, f, p, m, v;
							for(d = l[r],
								f = l[o],
								p = l[a],
								s.push([e[d], e[f], e[p]]),
								c.push([l[r], l[o], l[a]]),
								m = o,
								v = o + 1; v < u; m++,
								v++)
								l[m] = l[v];
							u--,
							h = 2 * u
						}
					}
					return n ? c : s
				}
			}(),
			triangulateShape: function(t, e) {
				function n(t) {
					var e = t.length;
					e > 2 && t[e - 1].equals(t[0]) && t.pop()
				}

				function i(t, e, n) {
					return t.x !== e.x ? t.x < e.x ? t.x <= n.x && n.x <= e.x : e.x <= n.x && n.x <= t.x : t.y < e.y ? t.y <= n.y && n.y <= e.y : e.y <= n.y && n.y <= t.y
				}

				function r(t, e, n, r, o) {
					var a = e.x - t.x,
						s = e.y - t.y,
						l = r.x - n.x,
						c = r.y - n.y,
						u = t.x - n.x,
						h = t.y - n.y,
						d = s * l - a * c,
						f = s * u - a * h;
					if(Math.abs(d) > Number.EPSILON) {
						var p;
						if(d > 0) {
							if(f < 0 || f > d)
								return [];
							if(p = c * u - l * h,
								p < 0 || p > d)
								return []
						} else {
							if(f > 0 || f < d)
								return [];
							if(p = c * u - l * h,
								p > 0 || p < d)
								return []
						}
						if(0 === p)
							return !o || 0 !== f && f !== d ? [t] : [];
						if(p === d)
							return !o || 0 !== f && f !== d ? [e] : [];
						if(0 === f)
							return [n];
						if(f === d)
							return [r];
						var m = p / d;
						return [{
							x: t.x + m * a,
							y: t.y + m * s
						}]
					}
					if(0 !== f || c * u !== l * h)
						return [];
					var v = 0 === a && 0 === s,
						g = 0 === l && 0 === c;
					if(v && g)
						return t.x !== n.x || t.y !== n.y ? [] : [t];
					if(v)
						return i(n, r, t) ? [t] : [];
					if(g)
						return i(t, e, n) ? [n] : [];
					var _, y, b, x, w, T, M, E;
					return 0 !== a ? (t.x < e.x ? (_ = t,
								b = t.x,
								y = e,
								x = e.x) : (_ = e,
								b = e.x,
								y = t,
								x = t.x),
							n.x < r.x ? (w = n,
								M = n.x,
								T = r,
								E = r.x) : (w = r,
								M = r.x,
								T = n,
								E = n.x)) : (t.y < e.y ? (_ = t,
								b = t.y,
								y = e,
								x = e.y) : (_ = e,
								b = e.y,
								y = t,
								x = t.y),
							n.y < r.y ? (w = n,
								M = n.y,
								T = r,
								E = r.y) : (w = r,
								M = r.y,
								T = n,
								E = n.y)),
						b <= M ? x < M ? [] : x === M ? o ? [] : [w] : x <= E ? [w, y] : [w, T] : b > E ? [] : b === E ? o ? [] : [_] : x <= E ? [_, y] : [_, T]
				}

				function o(t, e, n, i) {
					var r = e.x - t.x,
						o = e.y - t.y,
						a = n.x - t.x,
						s = n.y - t.y,
						l = i.x - t.x,
						c = i.y - t.y,
						u = r * s - o * a,
						h = r * c - o * l;
					if(Math.abs(u) > Number.EPSILON) {
						var d = l * s - c * a;
						return u > 0 ? h >= 0 && d >= 0 : h >= 0 || d >= 0
					}
					return h > 0
				}

				function a(t, e) {
					function n(t, e) {
						var n = _.length - 1,
							i = t - 1;
						i < 0 && (i = n);
						var r = t + 1;
						r > n && (r = 0);
						var a = o(_[t], _[i], _[r], s[e]);
						if(!a)
							return !1;
						var l = s.length - 1,
							c = e - 1;
						c < 0 && (c = l);
						var u = e + 1;
						return u > l && (u = 0),
							a = o(s[e], s[c], s[u], _[t]), !!a
					}

					function i(t, e) {
						var n, i, o;
						for(n = 0; n < _.length; n++)
							if(i = n + 1,
								i %= _.length,
								o = r(t, e, _[n], _[i], !0),
								o.length > 0)
								return !0;
						return !1
					}

					function a(t, n) {
						var i, o, a, s, l;
						for(i = 0; i < y.length; i++)
							for(o = e[y[i]],
								a = 0; a < o.length; a++)
								if(s = a + 1,
									s %= o.length,
									l = r(t, n, o[a], o[s], !0),
									l.length > 0)
									return !0;
						return !1
					}
					for(var s, l, c, u, h, d, f, p, m, v, g, _ = t.concat(), y = [], b = [], x = 0, w = e.length; x < w; x++)
						y.push(x);
					for(var T = 0, M = 2 * y.length; y.length > 0;) {
						if(M--,
							M < 0) {
							console.log("Infinite Loop! Holes left:" + y.length + ", Probably Hole outside Shape!");
							break
						}
						for(c = T; c < _.length; c++) {
							u = _[c],
								l = -1;
							for(var x = 0; x < y.length; x++)
								if(d = y[x],
									f = u.x + ":" + u.y + ":" + d,
									void 0 === b[f]) {
									s = e[d];
									for(var E = 0; E < s.length; E++)
										if(h = s[E],
											n(c, E) && !i(u, h) && !a(u, h)) {
											l = E,
												y.splice(x, 1),
												p = _.slice(0, c + 1),
												m = _.slice(c),
												v = s.slice(l),
												g = s.slice(0, l + 1),
												_ = p.concat(v).concat(g).concat(m),
												T = c;
											break
										}
									if(l >= 0)
										break;
									b[f] = !0
								}
							if(l >= 0)
								break
						}
					}
					return _
				}
				n(t),
					e.forEach(n);
				for(var s, l, c, u, h, d, f = {}, p = t.concat(), m = 0, v = e.length; m < v; m++)
					Array.prototype.push.apply(p, e[m]);
				for(s = 0,
					l = p.length; s < l; s++)
					h = p[s].x + ":" + p[s].y,
					void 0 !== f[h] && console.warn("THREE.ShapeUtils: Duplicate point", h, s),
					f[h] = s;
				var g = a(t, e),
					_ = Uc.triangulate(g, !1);
				for(s = 0,
					l = _.length; s < l; s++)
					for(u = _[s],
						c = 0; c < 3; c++)
						h = u[c].x + ":" + u[c].y,
						d = f[h],
						void 0 !== d && (u[c] = d);
				return _.concat()
			},
			isClockWise: function(t) {
				return Uc.area(t) < 0
			}
		};
		tn.prototype = Object.create(St.prototype),
			tn.prototype.constructor = tn,
			en.prototype = Object.create(Xt.prototype),
			en.prototype.constructor = en,
			en.prototype.getArrays = function() {
				var t = this.getAttribute("position"),
					e = t ? Array.prototype.slice.call(t.array) : [],
					n = this.getAttribute("uv"),
					i = n ? Array.prototype.slice.call(n.array) : [],
					r = this.index,
					o = r ? Array.prototype.slice.call(r.array) : [];
				return {
					position: e,
					uv: i,
					index: o
				}
			},
			en.prototype.addShapeList = function(t, e) {
				var n = t.length;
				e.arrays = this.getArrays();
				for(var i = 0; i < n; i++) {
					var r = t[i];
					this.addShape(r, e)
				}
				this.setIndex(e.arrays.index),
					this.addAttribute("position", new xt(e.arrays.position, 3)),
					this.addAttribute("uv", new xt(e.arrays.uv, 2))
			},
			en.prototype.addShape = function(t, e) {
				function i(t, e, n) {
					return e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
						e.clone().multiplyScalar(n).add(t)
				}

				function r(t, e, i) {
					var r, o, a = 1,
						s = t.x - e.x,
						l = t.y - e.y,
						c = i.x - t.x,
						u = i.y - t.y,
						h = s * s + l * l,
						d = s * u - l * c;
					if(Math.abs(d) > Number.EPSILON) {
						var f = Math.sqrt(h),
							p = Math.sqrt(c * c + u * u),
							m = e.x - l / f,
							v = e.y + s / f,
							g = i.x - u / p,
							_ = i.y + c / p,
							y = ((g - m) * u - (_ - v) * c) / (s * u - l * c);
						r = m + s * y - t.x,
							o = v + l * y - t.y;
						var b = r * r + o * o;
						if(b <= 2)
							return new n(r, o);
						a = Math.sqrt(b / 2)
					} else {
						var x = !1;
						s > Number.EPSILON ? c > Number.EPSILON && (x = !0) : s < -Number.EPSILON ? c < -Number.EPSILON && (x = !0) : Math.sign(l) === Math.sign(u) && (x = !0),
							x ? (r = -l,
								o = s,
								a = Math.sqrt(h)) : (r = s,
								o = l,
								a = Math.sqrt(h / 2))
					}
					return new n(r / a, o / a)
				}

				function o() {
					var t = b.length / 3;
					if(A) {
						var n = 0,
							i = Q * n;
						for($ = 0; $ < J; $++)
							Z = j[$],
							u(Z[2] + i, Z[1] + i, Z[0] + i);
						for(n = R + 2 * X,
							i = Q * n,
							$ = 0; $ < J; $++)
							Z = j[$],
							u(Z[0] + i, Z[1] + i, Z[2] + i)
					} else {
						for($ = 0; $ < J; $++)
							Z = j[$],
							u(Z[2], Z[1], Z[0]);
						for($ = 0; $ < J; $++)
							Z = j[$],
							u(Z[0] + Q * R, Z[1] + Q * R, Z[2] + Q * R)
					}
					F.addGroup(t, b.length / 3 - t, void 0 !== e.material ? e.material : 0)
				}

				function a() {
					var t = b.length / 3,
						n = 0;
					for(s(V, n),
						n += V.length,
						D = 0,
						B = k.length; D < B; D++)
						I = k[D],
						s(I, n),
						n += I.length;
					F.addGroup(t, b.length / 3 - t, void 0 !== e.extrudeMaterial ? e.extrudeMaterial : 1)
				}

				function s(t, e) {
					var n, i;
					for($ = t.length; --$ >= 0;) {
						n = $,
							i = $ - 1,
							i < 0 && (i = t.length - 1);
						var r = 0,
							o = R + 2 * X;
						for(r = 0; r < o; r++) {
							var a = Q * r,
								s = Q * (r + 1),
								l = e + n + a,
								c = e + i + a,
								u = e + i + s,
								d = e + n + s;
							h(l, c, u, d, t, r, o, n, i)
						}
					}
				}

				function c(t, e, n) {
					T.push(t),
						T.push(e),
						T.push(n)
				}

				function u(t, e, n) {
					d(t),
						d(e),
						d(n);
					var i = b.length / 3,
						r = L.generateTopUV(F, b, i - 3, i - 2, i - 1);
					f(r[0]),
						f(r[1]),
						f(r[2])
				}

				function h(t, e, n, i, r, o, a, s, l) {
					d(t),
						d(e),
						d(i),
						d(e),
						d(n),
						d(i);
					var c = b.length / 3,
						u = L.generateSideWallUV(F, b, c - 6, c - 3, c - 2, c - 1);
					f(u[0]),
						f(u[1]),
						f(u[3]),
						f(u[1]),
						f(u[2]),
						f(u[3])
				}

				function d(t) {
					x.push(b.length / 3),
						b.push(T[3 * t + 0]),
						b.push(T[3 * t + 1]),
						b.push(T[3 * t + 2])
				}

				function f(t) {
					w.push(t.x),
						w.push(t.y)
				}
				var p, m, v, g, _, y = e.arrays ? e.arrays : this.getArrays(),
					b = y.position,
					x = y.index,
					w = y.uv,
					T = [],
					M = void 0 !== e.amount ? e.amount : 100,
					E = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
					S = void 0 !== e.bevelSize ? e.bevelSize : E - 2,
					X = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
					A = void 0 === e.bevelEnabled || e.bevelEnabled,
					P = void 0 !== e.curveSegments ? e.curveSegments : 12,
					R = void 0 !== e.steps ? e.steps : 1,
					O = e.extrudePath,
					C = !1,
					L = void 0 !== e.UVGenerator ? e.UVGenerator : tn.WorldUVGenerator;
				O && (p = O.getSpacedPoints(R),
						C = !0,
						A = !1,
						m = void 0 !== e.frames ? e.frames : O.computeFrenetFrames(R, !1),
						v = new l,
						g = new l,
						_ = new l),
					A || (X = 0,
						E = 0,
						S = 0);
				var I, D, B, F = this,
					z = t.extractPoints(P),
					N = z.shape,
					k = z.holes,
					U = !Uc.isClockWise(N);
				if(U) {
					for(N = N.reverse(),
						D = 0,
						B = k.length; D < B; D++)
						I = k[D],
						Uc.isClockWise(I) && (k[D] = I.reverse());
					U = !1
				}
				var j = Uc.triangulateShape(N, k),
					V = N;
				for(D = 0,
					B = k.length; D < B; D++)
					I = k[D],
					N = N.concat(I);
				for(var G, H, W, Y, q, Z, Q = N.length, J = j.length, K = [], $ = 0, tt = V.length, et = tt - 1, nt = $ + 1; $ < tt; $++,
					et++,
					nt++)
					et === tt && (et = 0),
					nt === tt && (nt = 0),
					K[$] = r(V[$], V[et], V[nt]);
				var it, rt = [],
					ot = K.concat();
				for(D = 0,
					B = k.length; D < B; D++) {
					for(I = k[D],
						it = [],
						$ = 0,
						tt = I.length,
						et = tt - 1,
						nt = $ + 1; $ < tt; $++,
						et++,
						nt++)
						et === tt && (et = 0),
						nt === tt && (nt = 0),
						it[$] = r(I[$], I[et], I[nt]);
					rt.push(it),
						ot = ot.concat(it)
				}
				for(G = 0; G < X; G++) {
					for(W = G / X,
						Y = E * Math.cos(W * Math.PI / 2),
						H = S * Math.sin(W * Math.PI / 2),
						$ = 0,
						tt = V.length; $ < tt; $++)
						q = i(V[$], K[$], H),
						c(q.x, q.y, -Y);
					for(D = 0,
						B = k.length; D < B; D++)
						for(I = k[D],
							it = rt[D],
							$ = 0,
							tt = I.length; $ < tt; $++)
							q = i(I[$], it[$], H),
							c(q.x, q.y, -Y)
				}
				for(H = S,
					$ = 0; $ < Q; $++)
					q = A ? i(N[$], ot[$], H) : N[$],
					C ? (g.copy(m.normals[0]).multiplyScalar(q.x),
						v.copy(m.binormals[0]).multiplyScalar(q.y),
						_.copy(p[0]).add(g).add(v),
						c(_.x, _.y, _.z)) : c(q.x, q.y, 0);
				var at;
				for(at = 1; at <= R; at++)
					for($ = 0; $ < Q; $++)
						q = A ? i(N[$], ot[$], H) : N[$],
						C ? (g.copy(m.normals[at]).multiplyScalar(q.x),
							v.copy(m.binormals[at]).multiplyScalar(q.y),
							_.copy(p[at]).add(g).add(v),
							c(_.x, _.y, _.z)) : c(q.x, q.y, M / R * at);
				for(G = X - 1; G >= 0; G--) {
					for(W = G / X,
						Y = E * Math.cos(W * Math.PI / 2),
						H = S * Math.sin(W * Math.PI / 2),
						$ = 0,
						tt = V.length; $ < tt; $++)
						q = i(V[$], K[$], H),
						c(q.x, q.y, M + Y);
					for(D = 0,
						B = k.length; D < B; D++)
						for(I = k[D],
							it = rt[D],
							$ = 0,
							tt = I.length; $ < tt; $++)
							q = i(I[$], it[$], H),
							C ? c(q.x, q.y + p[R - 1].y, p[R - 1].x + Y) : c(q.x, q.y, M + Y)
				}
				o(),
					a(),
					e.arrays || (this.setIndex(x),
						this.addAttribute("position", new xt(b, 3)),
						this.addAttribute("uv", new xt(e.arrays.uv, 2)))
			},
			tn.WorldUVGenerator = {
				generateTopUV: function(t, e, i, r, o) {
					var a = e[3 * i],
						s = e[3 * i + 1],
						l = e[3 * r],
						c = e[3 * r + 1],
						u = e[3 * o],
						h = e[3 * o + 1];
					return [new n(a, s), new n(l, c), new n(u, h)]
				},
				generateSideWallUV: function(t, e, i, r, o, a) {
					var s = e[3 * i],
						l = e[3 * i + 1],
						c = e[3 * i + 2],
						u = e[3 * r],
						h = e[3 * r + 1],
						d = e[3 * r + 2],
						f = e[3 * o],
						p = e[3 * o + 1],
						m = e[3 * o + 2],
						v = e[3 * a],
						g = e[3 * a + 1],
						_ = e[3 * a + 2];
					return Math.abs(l - h) < .01 ? [new n(s, 1 - c), new n(u, 1 - d), new n(f, 1 - m), new n(v, 1 - _)] : [new n(l, 1 - c), new n(h, 1 - d), new n(p, 1 - m), new n(g, 1 - _)]
				}
			},
			nn.prototype = Object.create(St.prototype),
			nn.prototype.constructor = nn,
			rn.prototype = Object.create(en.prototype),
			rn.prototype.constructor = rn,
			on.prototype = Object.create(St.prototype),
			on.prototype.constructor = on,
			an.prototype = Object.create(Xt.prototype),
			an.prototype.constructor = an,
			sn.prototype = Object.create(St.prototype),
			sn.prototype.constructor = sn,
			ln.prototype = Object.create(Xt.prototype),
			ln.prototype.constructor = ln,
			cn.prototype = Object.create(St.prototype),
			cn.prototype.constructor = cn,
			un.prototype = Object.create(Xt.prototype),
			un.prototype.constructor = un,
			hn.prototype = Object.create(St.prototype),
			hn.prototype.constructor = hn,
			dn.prototype = Object.create(Xt.prototype),
			dn.prototype.constructor = dn,
			fn.prototype = Object.create(Xt.prototype),
			fn.prototype.constructor = fn,
			pn.prototype = Object.create(St.prototype),
			pn.prototype.constructor = pn,
			mn.prototype = Object.create(Xt.prototype),
			mn.prototype.constructor = mn,
			vn.prototype = Object.create(pn.prototype),
			vn.prototype.constructor = vn,
			gn.prototype = Object.create(mn.prototype),
			gn.prototype.constructor = gn,
			_n.prototype = Object.create(St.prototype),
			_n.prototype.constructor = _n,
			yn.prototype = Object.create(Xt.prototype),
			yn.prototype.constructor = yn;
		var jc = Object.freeze({
			WireframeGeometry: De,
			ParametricGeometry: Be,
			ParametricBufferGeometry: Fe,
			TetrahedronGeometry: ke,
			TetrahedronBufferGeometry: Ue,
			OctahedronGeometry: je,
			OctahedronBufferGeometry: Ve,
			IcosahedronGeometry: Ge,
			IcosahedronBufferGeometry: He,
			DodecahedronGeometry: We,
			DodecahedronBufferGeometry: Ye,
			PolyhedronGeometry: ze,
			PolyhedronBufferGeometry: Ne,
			TubeGeometry: qe,
			TubeBufferGeometry: Ze,
			TorusKnotGeometry: Qe,
			TorusKnotBufferGeometry: Je,
			TorusGeometry: Ke,
			TorusBufferGeometry: $e,
			TextGeometry: nn,
			TextBufferGeometry: rn,
			SphereGeometry: on,
			SphereBufferGeometry: an,
			RingGeometry: sn,
			RingBufferGeometry: ln,
			PlaneGeometry: Ot,
			PlaneBufferGeometry: Ct,
			LatheGeometry: cn,
			LatheBufferGeometry: un,
			ShapeGeometry: hn,
			ShapeBufferGeometry: dn,
			ExtrudeGeometry: tn,
			ExtrudeBufferGeometry: en,
			EdgesGeometry: fn,
			ConeGeometry: vn,
			ConeBufferGeometry: gn,
			CylinderGeometry: pn,
			CylinderBufferGeometry: mn,
			CircleGeometry: _n,
			CircleBufferGeometry: yn,
			BoxGeometry: Pt,
			BoxBufferGeometry: Rt
		});
		bn.prototype = Object.create(J.prototype),
			bn.prototype.constructor = bn,
			bn.prototype.isShadowMaterial = !0,
			xn.prototype = Object.create(J.prototype),
			xn.prototype.constructor = xn,
			xn.prototype.isRawShaderMaterial = !0,
			wn.prototype = Object.create(Q.prototype),
			wn.prototype.constructor = wn,
			wn.prototype.isMeshStandardMaterial = !0,
			wn.prototype.copy = function(t) {
				return Q.prototype.copy.call(this, t),
					this.defines = {
						STANDARD: ""
					},
					this.color.copy(t.color),
					this.roughness = t.roughness,
					this.metalness = t.metalness,
					this.map = t.map,
					this.lightMap = t.lightMap,
					this.lightMapIntensity = t.lightMapIntensity,
					this.aoMap = t.aoMap,
					this.aoMapIntensity = t.aoMapIntensity,
					this.emissive.copy(t.emissive),
					this.emissiveMap = t.emissiveMap,
					this.emissiveIntensity = t.emissiveIntensity,
					this.bumpMap = t.bumpMap,
					this.bumpScale = t.bumpScale,
					this.normalMap = t.normalMap,
					this.normalScale.copy(t.normalScale),
					this.displacementMap = t.displacementMap,
					this.displacementScale = t.displacementScale,
					this.displacementBias = t.displacementBias,
					this.roughnessMap = t.roughnessMap,
					this.metalnessMap = t.metalnessMap,
					this.alphaMap = t.alphaMap,
					this.envMap = t.envMap,
					this.envMapIntensity = t.envMapIntensity,
					this.refractionRatio = t.refractionRatio,
					this.wireframe = t.wireframe,
					this.wireframeLinewidth = t.wireframeLinewidth,
					this.wireframeLinecap = t.wireframeLinecap,
					this.wireframeLinejoin = t.wireframeLinejoin,
					this.skinning = t.skinning,
					this.morphTargets = t.morphTargets,
					this.morphNormals = t.morphNormals,
					this
			},
			Tn.prototype = Object.create(wn.prototype),
			Tn.prototype.constructor = Tn,
			Tn.prototype.isMeshPhysicalMaterial = !0,
			Tn.prototype.copy = function(t) {
				return wn.prototype.copy.call(this, t),
					this.defines = {
						PHYSICAL: ""
					},
					this.reflectivity = t.reflectivity,
					this.clearCoat = t.clearCoat,
					this.clearCoatRoughness = t.clearCoatRoughness,
					this
			},
			Mn.prototype = Object.create(Q.prototype),
			Mn.prototype.constructor = Mn,
			Mn.prototype.isMeshPhongMaterial = !0,
			Mn.prototype.copy = function(t) {
				return Q.prototype.copy.call(this, t),
					this.color.copy(t.color),
					this.specular.copy(t.specular),
					this.shininess = t.shininess,
					this.map = t.map,
					this.lightMap = t.lightMap,
					this.lightMapIntensity = t.lightMapIntensity,
					this.aoMap = t.aoMap,
					this.aoMapIntensity = t.aoMapIntensity,
					this.emissive.copy(t.emissive),
					this.emissiveMap = t.emissiveMap,
					this.emissiveIntensity = t.emissiveIntensity,
					this.bumpMap = t.bumpMap,
					this.bumpScale = t.bumpScale,
					this.normalMap = t.normalMap,
					this.normalScale.copy(t.normalScale),
					this.displacementMap = t.displacementMap,
					this.displacementScale = t.displacementScale,
					this.displacementBias = t.displacementBias,
					this.specularMap = t.specularMap,
					this.alphaMap = t.alphaMap,
					this.envMap = t.envMap,
					this.combine = t.combine,
					this.reflectivity = t.reflectivity,
					this.refractionRatio = t.refractionRatio,
					this.wireframe = t.wireframe,
					this.wireframeLinewidth = t.wireframeLinewidth,
					this.wireframeLinecap = t.wireframeLinecap,
					this.wireframeLinejoin = t.wireframeLinejoin,
					this.skinning = t.skinning,
					this.morphTargets = t.morphTargets,
					this.morphNormals = t.morphNormals,
					this
			},
			En.prototype = Object.create(Mn.prototype),
			En.prototype.constructor = En,
			En.prototype.isMeshToonMaterial = !0,
			En.prototype.copy = function(t) {
				return Mn.prototype.copy.call(this, t),
					this.gradientMap = t.gradientMap,
					this
			},
			Sn.prototype = Object.create(Q.prototype),
			Sn.prototype.constructor = Sn,
			Sn.prototype.isMeshNormalMaterial = !0,
			Sn.prototype.copy = function(t) {
				return Q.prototype.copy.call(this, t),
					this.bumpMap = t.bumpMap,
					this.bumpScale = t.bumpScale,
					this.normalMap = t.normalMap,
					this.normalScale.copy(t.normalScale),
					this.displacementMap = t.displacementMap,
					this.displacementScale = t.displacementScale,
					this.displacementBias = t.displacementBias,
					this.wireframe = t.wireframe,
					this.wireframeLinewidth = t.wireframeLinewidth,
					this.skinning = t.skinning,
					this.morphTargets = t.morphTargets,
					this.morphNormals = t.morphNormals,
					this
			},
			Xn.prototype = Object.create(Q.prototype),
			Xn.prototype.constructor = Xn,
			Xn.prototype.isMeshLambertMaterial = !0,
			Xn.prototype.copy = function(t) {
				return Q.prototype.copy.call(this, t),
					this.color.copy(t.color),
					this.map = t.map,
					this.lightMap = t.lightMap,
					this.lightMapIntensity = t.lightMapIntensity,
					this.aoMap = t.aoMap,
					this.aoMapIntensity = t.aoMapIntensity,
					this.emissive.copy(t.emissive),
					this.emissiveMap = t.emissiveMap,
					this.emissiveIntensity = t.emissiveIntensity,
					this.specularMap = t.specularMap,
					this.alphaMap = t.alphaMap,
					this.envMap = t.envMap,
					this.combine = t.combine,
					this.reflectivity = t.reflectivity,
					this.refractionRatio = t.refractionRatio,
					this.wireframe = t.wireframe,
					this.wireframeLinewidth = t.wireframeLinewidth,
					this.wireframeLinecap = t.wireframeLinecap,
					this.wireframeLinejoin = t.wireframeLinejoin,
					this.skinning = t.skinning,
					this.morphTargets = t.morphTargets,
					this.morphNormals = t.morphNormals,
					this
			},
			An.prototype = Object.create(Q.prototype),
			An.prototype.constructor = An,
			An.prototype.isLineDashedMaterial = !0,
			An.prototype.copy = function(t) {
				return Q.prototype.copy.call(this, t),
					this.color.copy(t.color),
					this.linewidth = t.linewidth,
					this.scale = t.scale,
					this.dashSize = t.dashSize,
					this.gapSize = t.gapSize,
					this
			};
		var Vc = Object.freeze({
				ShadowMaterial: bn,
				SpriteMaterial: _e,
				RawShaderMaterial: xn,
				ShaderMaterial: J,
				PointsMaterial: Ae,
				MeshPhysicalMaterial: Tn,
				MeshStandardMaterial: wn,
				MeshPhongMaterial: Mn,
				MeshToonMaterial: En,
				MeshNormalMaterial: Sn,
				MeshLambertMaterial: Xn,
				MeshDepthMaterial: K,
				MeshBasicMaterial: dt,
				LineDashedMaterial: An,
				LineBasicMaterial: Me,
				Material: Q
			}),
			Gc = {
				enabled: !1,
				files: {},
				add: function(t, e) {
					this.enabled !== !1 && (this.files[t] = e)
				},
				get: function(t) {
					if(this.enabled !== !1)
						return this.files[t]
				},
				remove: function(t) {
					delete this.files[t]
				},
				clear: function() {
					this.files = {}
				}
			},
			Hc = new Pn;
		Object.assign(Rn.prototype, {
				load: function(t, e, n, i) {
					void 0 === t && (t = ""),
						void 0 !== this.path && (t = this.path + t);
					var r = this,
						o = Gc.get(t);
					if(void 0 !== o)
						return r.manager.itemStart(t),
							setTimeout(function() {
								e && e(o),
									r.manager.itemEnd(t)
							}, 0),
							o;
					var a = /^data:(.*?)(;base64)?,(.*)$/,
						s = t.match(a);
					if(s) {
						var l = s[1],
							c = !!s[2],
							u = s[3];
						u = window.decodeURIComponent(u),
							c && (u = window.atob(u));
						try {
							var h, d = (this.responseType || "").toLowerCase();
							switch(d) {
								case "arraybuffer":
								case "blob":
									h = new ArrayBuffer(u.length);
									for(var f = new Uint8Array(h), p = 0; p < u.length; p++)
										f[p] = u.charCodeAt(p);
									"blob" === d && (h = new Blob([h], {
										type: l
									}));
									break;
								case "document":
									var m = new DOMParser;
									h = m.parseFromString(u, l);
									break;
								case "json":
									h = JSON.parse(u);
									break;
								default:
									h = u
							}
							window.setTimeout(function() {
								e && e(h),
									r.manager.itemEnd(t)
							}, 0)
						} catch(e) {
							window.setTimeout(function() {
								i && i(e),
									r.manager.itemEnd(t),
									r.manager.itemError(t)
							}, 0)
						}
					} else {
						var v = new XMLHttpRequest;
						v.open("GET", t, !0),
							v.addEventListener("load", function(n) {
								var o = n.target.response;
								Gc.add(t, o),
									200 === this.status ? (e && e(o),
										r.manager.itemEnd(t)) : 0 === this.status ? (console.warn("THREE.FileLoader: HTTP Status 0 received."),
										e && e(o),
										r.manager.itemEnd(t)) : (i && i(n),
										r.manager.itemEnd(t),
										r.manager.itemError(t))
							}, !1),
							void 0 !== n && v.addEventListener("progress", function(t) {
								n(t)
							}, !1),
							v.addEventListener("error", function(e) {
								i && i(e),
									r.manager.itemEnd(t),
									r.manager.itemError(t)
							}, !1),
							void 0 !== this.responseType && (v.responseType = this.responseType),
							void 0 !== this.withCredentials && (v.withCredentials = this.withCredentials),
							v.overrideMimeType && v.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
						for(var g in this.requestHeader)
							v.setRequestHeader(g, this.requestHeader[g]);
						v.send(null)
					}
					return r.manager.itemStart(t),
						v
				},
				setPath: function(t) {
					return this.path = t,
						this
				},
				setResponseType: function(t) {
					return this.responseType = t,
						this
				},
				setWithCredentials: function(t) {
					return this.withCredentials = t,
						this
				},
				setMimeType: function(t) {
					return this.mimeType = t,
						this
				},
				setRequestHeader: function(t) {
					return this.requestHeader = t,
						this
				}
			}),
			Object.assign(On.prototype, {
				load: function(t, e, n, i) {
					function r(r) {
						l.load(t[r], function(t) {
							var n = o._parser(t, !0);
							a[r] = {
									width: n.width,
									height: n.height,
									format: n.format,
									mipmaps: n.mipmaps
								},
								c += 1,
								6 === c && (1 === n.mipmapCount && (s.minFilter = xa),
									s.format = n.format,
									s.needsUpdate = !0,
									e && e(s))
						}, n, i)
					}
					var o = this,
						a = [],
						s = new Ce;
					s.image = a;
					var l = new Rn(this.manager);
					if(l.setPath(this.path),
						l.setResponseType("arraybuffer"),
						Array.isArray(t))
						for(var c = 0, u = 0, h = t.length; u < h; ++u)
							r(u);
					else
						l.load(t, function(t) {
							var n = o._parser(t, !0);
							if(n.isCubemap)
								for(var i = n.mipmaps.length / n.mipmapCount, r = 0; r < i; r++) {
									a[r] = {
										mipmaps: []
									};
									for(var l = 0; l < n.mipmapCount; l++)
										a[r].mipmaps.push(n.mipmaps[r * n.mipmapCount + l]),
										a[r].format = n.format,
										a[r].width = n.width,
										a[r].height = n.height
								}
							else
								s.image.width = n.width,
								s.image.height = n.height,
								s.mipmaps = n.mipmaps;
							1 === n.mipmapCount && (s.minFilter = xa),
								s.format = n.format,
								s.needsUpdate = !0,
								e && e(s)
						}, n, i);
					return s
				},
				setPath: function(t) {
					return this.path = t,
						this
				}
			}),
			Object.assign(Cn.prototype, {
				load: function(t, e, n, i) {
					var r = this,
						o = new u,
						a = new Rn(this.manager);
					return a.setResponseType("arraybuffer"),
						a.load(t, function(t) {
							var n = r._parser(t);
							n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width,
									o.image.height = n.height,
									o.image.data = n.data),
								o.wrapS = void 0 !== n.wrapS ? n.wrapS : va,
								o.wrapT = void 0 !== n.wrapT ? n.wrapT : va,
								o.magFilter = void 0 !== n.magFilter ? n.magFilter : xa,
								o.minFilter = void 0 !== n.minFilter ? n.minFilter : Ta,
								o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1,
								void 0 !== n.format && (o.format = n.format),
								void 0 !== n.type && (o.type = n.type),
								void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps),
								1 === n.mipmapCount && (o.minFilter = xa),
								o.needsUpdate = !0,
								e && e(o, n))
						}, n, i),
						o
				}
			}),
			Object.assign(Ln.prototype, {
				load: function(t, e, n, i) {
					void 0 === t && (t = ""),
						void 0 !== this.path && (t = this.path + t);
					var r = this,
						o = Gc.get(t);
					if(void 0 !== o)
						return r.manager.itemStart(t),
							setTimeout(function() {
								e && e(o),
									r.manager.itemEnd(t)
							}, 0),
							o;
					var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
					return a.addEventListener("load", function() {
							Gc.add(t, this),
								e && e(this),
								r.manager.itemEnd(t)
						}, !1),
						a.addEventListener("error", function(e) {
							i && i(e),
								r.manager.itemEnd(t),
								r.manager.itemError(t)
						}, !1),
						"data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
						r.manager.itemStart(t),
						a.src = t,
						a
				},
				setCrossOrigin: function(t) {
					return this.crossOrigin = t,
						this
				},
				setPath: function(t) {
					return this.path = t,
						this
				}
			}),
			Object.assign(In.prototype, {
				load: function(t, e, n, i) {
					function r(n) {
						a.load(t[n], function(t) {
							o.images[n] = t,
								s++,
								6 === s && (o.needsUpdate = !0,
									e && e(o))
						}, void 0, i)
					}
					var o = new h,
						a = new Ln(this.manager);
					a.setCrossOrigin(this.crossOrigin),
						a.setPath(this.path);
					for(var s = 0, l = 0; l < t.length; ++l)
						r(l);
					return o
				},
				setCrossOrigin: function(t) {
					return this.crossOrigin = t,
						this
				},
				setPath: function(t) {
					return this.path = t,
						this
				}
			}),
			Object.assign(Dn.prototype, {
				load: function(t, e, n, r) {
					var o = new Ln(this.manager);
					o.setCrossOrigin(this.crossOrigin),
						o.setPath(this.path);
					var a = new i;
					return a.image = o.load(t, function() {
							var n = t.search(/\.(jpg|jpeg)$/) > 0 || 0 === t.search(/^data\:image\/jpeg/);
							a.format = n ? Fa : za,
								a.needsUpdate = !0,
								void 0 !== e && e(a)
						}, n, r),
						a
				},
				setCrossOrigin: function(t) {
					return this.crossOrigin = t,
						this
				},
				setPath: function(t) {
					return this.path = t,
						this
				}
			}),
			Bn.prototype = Object.assign(Object.create(lt.prototype), {
				constructor: Bn,
				isLight: !0,
				copy: function(t) {
					return lt.prototype.copy.call(this, t),
						this.color.copy(t.color),
						this.intensity = t.intensity,
						this
				},
				toJSON: function(t) {
					var e = lt.prototype.toJSON.call(this, t);
					return e.object.color = this.color.getHex(),
						e.object.intensity = this.intensity,
						void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
						void 0 !== this.distance && (e.object.distance = this.distance),
						void 0 !== this.angle && (e.object.angle = this.angle),
						void 0 !== this.decay && (e.object.decay = this.decay),
						void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
						void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
						e
				}
			}),
			Fn.prototype = Object.assign(Object.create(Bn.prototype), {
				constructor: Fn,
				isHemisphereLight: !0,
				copy: function(t) {
					return Bn.prototype.copy.call(this, t),
						this.groundColor.copy(t.groundColor),
						this
				}
			}),
			Object.assign(zn.prototype, {
				copy: function(t) {
					return this.camera = t.camera.clone(),
						this.bias = t.bias,
						this.radius = t.radius,
						this.mapSize.copy(t.mapSize),
						this
				},
				clone: function() {
					return(new this.constructor).copy(this)
				},
				toJSON: function() {
					var t = {};
					return 0 !== this.bias && (t.bias = this.bias),
						1 !== this.radius && (t.radius = this.radius),
						512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
						t.camera = this.camera.toJSON(!1).object,
						delete t.camera.matrix,
						t
				}
			}),
			Nn.prototype = Object.assign(Object.create(zn.prototype), {
				constructor: Nn,
				isSpotLightShadow: !0,
				update: function(t) {
					var e = this.camera,
						n = 2 * xs.RAD2DEG * t.angle,
						i = this.mapSize.width / this.mapSize.height,
						r = t.distance || e.far;
					n === e.fov && i === e.aspect && r === e.far || (e.fov = n,
						e.aspect = i,
						e.far = r,
						e.updateProjectionMatrix())
				}
			}),
			kn.prototype = Object.assign(Object.create(Bn.prototype), {
				constructor: kn,
				isSpotLight: !0,
				copy: function(t) {
					return Bn.prototype.copy.call(this, t),
						this.distance = t.distance,
						this.angle = t.angle,
						this.penumbra = t.penumbra,
						this.decay = t.decay,
						this.target = t.target.clone(),
						this.shadow = t.shadow.clone(),
						this
				}
			}),
			Un.prototype = Object.assign(Object.create(Bn.prototype), {
				constructor: Un,
				isPointLight: !0,
				copy: function(t) {
					return Bn.prototype.copy.call(this, t),
						this.distance = t.distance,
						this.decay = t.decay,
						this.shadow = t.shadow.clone(),
						this
				}
			}),
			jn.prototype = Object.assign(Object.create(zn.prototype), {
				constructor: jn
			}),
			Vn.prototype = Object.assign(Object.create(Bn.prototype), {
				constructor: Vn,
				isDirectionalLight: !0,
				copy: function(t) {
					return Bn.prototype.copy.call(this, t),
						this.target = t.target.clone(),
						this.shadow = t.shadow.clone(),
						this
				}
			}),
			Gn.prototype = Object.assign(Object.create(Bn.prototype), {
				constructor: Gn,
				isAmbientLight: !0
			}),
			Hn.prototype = Object.assign(Object.create(Bn.prototype), {
				constructor: Hn,
				isRectAreaLight: !0,
				copy: function(t) {
					return Bn.prototype.copy.call(this, t),
						this.width = t.width,
						this.height = t.height,
						this
				},
				toJSON: function(t) {
					var e = Bn.prototype.toJSON.call(this, t);
					return e.object.width = this.width,
						e.object.height = this.height,
						e
				}
			});
		var Wc = {
			arraySlice: function(t, e, n) {
				return Wc.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
			},
			convertArray: function(t, e, n) {
				return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
			},
			isTypedArray: function(t) {
				return ArrayBuffer.isView(t) && !(t instanceof DataView)
			},
			getKeyframeOrder: function(t) {
				function e(e, n) {
					return t[e] - t[n]
				}
				for(var n = t.length, i = new Array(n), r = 0; r !== n; ++r)
					i[r] = r;
				return i.sort(e),
					i
			},
			sortedArray: function(t, e, n) {
				for(var i = t.length, r = new t.constructor(i), o = 0, a = 0; a !== i; ++o)
					for(var s = n[o] * e, l = 0; l !== e; ++l)
						r[a++] = t[s + l];
				return r
			},
			flattenJSON: function(t, e, n, i) {
				for(var r = 1, o = t[0]; void 0 !== o && void 0 === o[i];)
					o = t[r++];
				if(void 0 !== o) {
					var a = o[i];
					if(void 0 !== a)
						if(Array.isArray(a)) {
							do
								a = o[i],
								void 0 !== a && (e.push(o.time),
									n.push.apply(n, a)),
								o = t[r++];
							while (void 0 !== o)
						} else if(void 0 !== a.toArray) {
						do
							a = o[i],
							void 0 !== a && (e.push(o.time),
								a.toArray(n, n.length)),
							o = t[r++];
						while (void 0 !== o)
					} else
						do
							a = o[i],
							void 0 !== a && (e.push(o.time),
								n.push(a)),
							o = t[r++];
						while (void 0 !== o)
				}
			}
		};
		Object.assign(Wn.prototype, {
				evaluate: function(t) {
					var e = this.parameterPositions,
						n = this._cachedIndex,
						i = e[n],
						r = e[n - 1];
					t: {
						e: {
							var o;
							n: {
								i: if(!(t < i)) {
									for(var a = n + 2;;) {
										if(void 0 === i) {
											if(t < r)
												break i;
											return n = e.length,
												this._cachedIndex = n,
												this.afterEnd_(n - 1, t, r)
										}
										if(n === a)
											break;
										if(r = i,
											i = e[++n],
											t < i)
											break e
									}
									o = e.length;
									break n
								} {
									if(t >= r)
										break t;
									var s = e[1];
									t < s && (n = 2,
										r = s);
									for(var a = n - 2;;) {
										if(void 0 === r)
											return this._cachedIndex = 0,
												this.beforeStart_(0, t, i);
										if(n === a)
											break;
										if(i = r,
											r = e[--n - 1],
											t >= r)
											break e
									}
									o = n,
										n = 0
								}
							}
							for(; n < o;) {
								var l = n + o >>> 1;
								t < e[l] ? o = l : n = l + 1
							}
							if(i = e[n],
								r = e[n - 1],
								void 0 === r)
								return this._cachedIndex = 0,
									this.beforeStart_(0, t, i);
							if(void 0 === i)
								return n = e.length,
									this._cachedIndex = n,
									this.afterEnd_(n - 1, r, t)
						}
						this._cachedIndex = n,
						this.intervalChanged_(n, r, i)
					}
					return this.interpolate_(n, r, t, i)
				},
				settings: null,
				DefaultSettings_: {},
				getSettings_: function() {
					return this.settings || this.DefaultSettings_
				},
				copySampleValue_: function(t) {
					for(var e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i, o = 0; o !== i; ++o)
						e[o] = n[r + o];
					return e
				},
				interpolate_: function(t, e, n, i) {
					throw new Error("call to abstract method")
				},
				intervalChanged_: function(t, e, n) {}
			}),
			//!\ DECLARE ALIAS AFTER assign prototype !
			Object.assign(Wn.prototype, {
				beforeStart_: Wn.prototype.copySampleValue_,
				afterEnd_: Wn.prototype.copySampleValue_
			}),
			Yn.prototype = Object.assign(Object.create(Wn.prototype), {
				constructor: Yn,
				DefaultSettings_: {
					endingStart: os,
					endingEnd: os
				},
				intervalChanged_: function(t, e, n) {
					var i = this.parameterPositions,
						r = t - 2,
						o = t + 1,
						a = i[r],
						s = i[o];
					if(void 0 === a)
						switch(this.getSettings_().endingStart) {
							case as:
								r = t,
									a = 2 * e - n;
								break;
							case ss:
								r = i.length - 2,
									a = e + i[r] - i[r + 1];
								break;
							default:
								r = t,
									a = n
						}
					if(void 0 === s)
						switch(this.getSettings_().endingEnd) {
							case as:
								o = t,
									s = 2 * n - e;
								break;
							case ss:
								o = 1,
									s = n + i[1] - i[0];
								break;
							default:
								o = t - 1,
									s = e
						}
					var l = .5 * (n - e),
						c = this.valueSize;
					this._weightPrev = l / (e - a),
						this._weightNext = l / (s - n),
						this._offsetPrev = r * c,
						this._offsetNext = o * c
				},
				interpolate_: function(t, e, n, i) {
					for(var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, l = s - a, c = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, f = (n - e) / (i - e), p = f * f, m = p * f, v = -h * m + 2 * h * p - h * f, g = (1 + h) * m + (-1.5 - 2 * h) * p + (-.5 + h) * f + 1, _ = (-1 - d) * m + (1.5 + d) * p + .5 * f, y = d * m - d * p, b = 0; b !== a; ++b)
						r[b] = v * o[c + b] + g * o[l + b] + _ * o[s + b] + y * o[u + b];
					return r
				}
			}),
			qn.prototype = Object.assign(Object.create(Wn.prototype), {
				constructor: qn,
				interpolate_: function(t, e, n, i) {
					for(var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, l = s - a, c = (n - e) / (i - e), u = 1 - c, h = 0; h !== a; ++h)
						r[h] = o[l + h] * u + o[s + h] * c;
					return r
				}
			}),
			Zn.prototype = Object.assign(Object.create(Wn.prototype), {
				constructor: Zn,
				interpolate_: function(t, e, n, i) {
					return this.copySampleValue_(t - 1)
				}
			});
		var Yc;
		Yc = {
				TimeBufferType: Float32Array,
				ValueBufferType: Float32Array,
				DefaultInterpolation: is,
				InterpolantFactoryMethodDiscrete: function(t) {
					return new Zn(this.times, this.values, this.getValueSize(), t)
				},
				InterpolantFactoryMethodLinear: function(t) {
					return new qn(this.times, this.values, this.getValueSize(), t)
				},
				InterpolantFactoryMethodSmooth: function(t) {
					return new Yn(this.times, this.values, this.getValueSize(), t)
				},
				setInterpolation: function(t) {
					var e;
					switch(t) {
						case ns:
							e = this.InterpolantFactoryMethodDiscrete;
							break;
						case is:
							e = this.InterpolantFactoryMethodLinear;
							break;
						case rs:
							e = this.InterpolantFactoryMethodSmooth
					}
					if(void 0 === e) {
						var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
						if(void 0 === this.createInterpolant) {
							if(t === this.DefaultInterpolation)
								throw new Error(n);
							this.setInterpolation(this.DefaultInterpolation)
						}
						return void console.warn(n)
					}
					this.createInterpolant = e
				},
				getInterpolation: function() {
					switch(this.createInterpolant) {
						case this.InterpolantFactoryMethodDiscrete:
							return ns;
						case this.InterpolantFactoryMethodLinear:
							return is;
						case this.InterpolantFactoryMethodSmooth:
							return rs
					}
				},
				getValueSize: function() {
					return this.values.length / this.times.length
				},
				shift: function(t) {
					if(0 !== t)
						for(var e = this.times, n = 0, i = e.length; n !== i; ++n)
							e[n] += t;
					return this
				},
				scale: function(t) {
					if(1 !== t)
						for(var e = this.times, n = 0, i = e.length; n !== i; ++n)
							e[n] *= t;
					return this
				},
				trim: function(t, e) {
					for(var n = this.times, i = n.length, r = 0, o = i - 1; r !== i && n[r] < t;)
						++r;
					for(; o !== -1 && n[o] > e;)
						--o;
					if(++o,
						0 !== r || o !== i) {
						r >= o && (o = Math.max(o, 1),
							r = o - 1);
						var a = this.getValueSize();
						this.times = Wc.arraySlice(n, r, o),
							this.values = Wc.arraySlice(this.values, r * a, o * a)
					}
					return this
				},
				validate: function() {
					var t = !0,
						e = this.getValueSize();
					e - Math.floor(e) !== 0 && (console.error("invalid value size in track", this),
						t = !1);
					var n = this.times,
						i = this.values,
						r = n.length;
					0 === r && (console.error("track is empty", this),
						t = !1);
					for(var o = null, a = 0; a !== r; a++) {
						var s = n[a];
						if("number" == typeof s && isNaN(s)) {
							console.error("time is not a valid number", this, a, s),
								t = !1;
							break
						}
						if(null !== o && o > s) {
							console.error("out of order keys", this, a, s, o),
								t = !1;
							break
						}
						o = s
					}
					if(void 0 !== i && Wc.isTypedArray(i))
						for(var a = 0, l = i.length; a !== l; ++a) {
							var c = i[a];
							if(isNaN(c)) {
								console.error("value is not a valid number", this, a, c),
									t = !1;
								break
							}
						}
					return t
				},
				optimize: function() {
					for(var t = this.times, e = this.values, n = this.getValueSize(), i = this.getInterpolation() === rs, r = 1, o = t.length - 1, a = 1; a < o; ++a) {
						var s = !1,
							l = t[a],
							c = t[a + 1];
						if(l !== c && (1 !== a || l !== l[0]))
							if(i)
								s = !0;
							else
								for(var u = a * n, h = u - n, d = u + n, f = 0; f !== n; ++f) {
									var p = e[u + f];
									if(p !== e[h + f] || p !== e[d + f]) {
										s = !0;
										break
									}
								}
						if(s) {
							if(a !== r) {
								t[r] = t[a];
								for(var m = a * n, v = r * n, f = 0; f !== n; ++f)
									e[v + f] = e[m + f]
							}
							++r
						}
					}
					if(o > 0) {
						t[r] = t[o];
						for(var m = o * n, v = r * n, f = 0; f !== n; ++f)
							e[v + f] = e[m + f];
						++r
					}
					return r !== t.length && (this.times = Wc.arraySlice(t, 0, r),
							this.values = Wc.arraySlice(e, 0, r * n)),
						this
				}
			},
			Jn.prototype = Object.assign(Object.create(Yc), {
				constructor: Jn,
				ValueTypeName: "vector"
			}),
			Kn.prototype = Object.assign(Object.create(Wn.prototype), {
				constructor: Kn,
				interpolate_: function(t, e, n, i) {
					for(var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = t * a, c = (n - e) / (i - e), u = l + a; l !== u; l += 4)
						s.slerpFlat(r, 0, o, l - a, o, l, c);
					return r
				}
			}),
			$n.prototype = Object.assign(Object.create(Yc), {
				constructor: $n,
				ValueTypeName: "quaternion",
				DefaultInterpolation: is,
				InterpolantFactoryMethodLinear: function(t) {
					return new Kn(this.times, this.values, this.getValueSize(), t)
				},
				InterpolantFactoryMethodSmooth: void 0
			}),
			ti.prototype = Object.assign(Object.create(Yc), {
				constructor: ti,
				ValueTypeName: "number"
			}),
			ei.prototype = Object.assign(Object.create(Yc), {
				constructor: ei,
				ValueTypeName: "string",
				ValueBufferType: Array,
				DefaultInterpolation: ns,
				InterpolantFactoryMethodLinear: void 0,
				InterpolantFactoryMethodSmooth: void 0
			}),
			ni.prototype = Object.assign(Object.create(Yc), {
				constructor: ni,
				ValueTypeName: "bool",
				ValueBufferType: Array,
				DefaultInterpolation: ns,
				InterpolantFactoryMethodLinear: void 0,
				InterpolantFactoryMethodSmooth: void 0
			}),
			ii.prototype = Object.assign(Object.create(Yc), {
				constructor: ii,
				ValueTypeName: "color"
			}),
			ri.prototype = Yc,
			Yc.constructor = ri,
			Object.assign(ri, {
				parse: function(t) {
					if(void 0 === t.type)
						throw new Error("track type undefined, can not parse");
					var e = ri._getTrackTypeForValueTypeName(t.type);
					if(void 0 === t.times) {
						var n = [],
							i = [];
						Wc.flattenJSON(t.keys, n, i, "value"),
							t.times = n,
							t.values = i
					}
					return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
				},
				toJSON: function(t) {
					var e, n = t.constructor;
					if(void 0 !== n.toJSON)
						e = n.toJSON(t);
					else {
						e = {
							name: t.name,
							times: Wc.convertArray(t.times, Array),
							values: Wc.convertArray(t.values, Array)
						};
						var i = t.getInterpolation();
						i !== t.DefaultInterpolation && (e.interpolation = i)
					}
					return e.type = t.ValueTypeName,
						e
				},
				_getTrackTypeForValueTypeName: function(t) {
					switch(t.toLowerCase()) {
						case "scalar":
						case "double":
						case "float":
						case "number":
						case "integer":
							return ti;
						case "vector":
						case "vector2":
						case "vector3":
						case "vector4":
							return Jn;
						case "color":
							return ii;
						case "quaternion":
							return $n;
						case "bool":
						case "boolean":
							return ni;
						case "string":
							return ei
					}
					throw new Error("Unsupported typeName: " + t)
				}
			}),
			Object.assign(oi, {
				parse: function(t) {
					for(var e = [], n = t.tracks, i = 1 / (t.fps || 1), r = 0, o = n.length; r !== o; ++r)
						e.push(ri.parse(n[r]).scale(i));
					return new oi(t.name, t.duration, e)
				},
				toJSON: function(t) {
					for(var e = [], n = t.tracks, i = {
							name: t.name,
							duration: t.duration,
							tracks: e
						}, r = 0, o = n.length; r !== o; ++r)
						e.push(ri.toJSON(n[r]));
					return i
				},
				CreateFromMorphTargetSequence: function(t, e, n, i) {
					for(var r = e.length, o = [], a = 0; a < r; a++) {
						var s = [],
							l = [];
						s.push((a + r - 1) % r, a, (a + 1) % r),
							l.push(0, 1, 0);
						var c = Wc.getKeyframeOrder(s);
						s = Wc.sortedArray(s, 1, c),
							l = Wc.sortedArray(l, 1, c),
							i || 0 !== s[0] || (s.push(r),
								l.push(l[0])),
							o.push(new ti(".morphTargetInfluences[" + e[a].name + "]", s, l).scale(1 / n))
					}
					return new oi(t, -1, o)
				},
				findByName: function(t, e) {
					var n = t;
					if(!Array.isArray(t)) {
						var i = t;
						n = i.geometry && i.geometry.animations || i.animations
					}
					for(var r = 0; r < n.length; r++)
						if(n[r].name === e)
							return n[r];
					return null
				},
				CreateClipsFromMorphTargetSequences: function(t, e, n) {
					for(var i = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
						var s = t[o],
							l = s.name.match(r);
						if(l && l.length > 1) {
							var c = l[1],
								u = i[c];
							u || (i[c] = u = []),
								u.push(s)
						}
					}
					var h = [];
					for(var c in i)
						h.push(oi.CreateFromMorphTargetSequence(c, i[c], e, n));
					return h
				},
				parseAnimation: function(t, e) {
					if(!t)
						return console.error("  no animation in JSONLoader data"),
							null;
					for(var n = function(t, e, n, i, r) {
							if(0 !== n.length) {
								var o = [],
									a = [];
								Wc.flattenJSON(n, o, a, i),
									0 !== o.length && r.push(new t(e, o, a))
							}
						}, i = [], r = t.name || "default", o = t.length || -1, a = t.fps || 30, s = t.hierarchy || [], l = 0; l < s.length; l++) {
						var c = s[l].keys;
						if(c && 0 !== c.length)
							if(c[0].morphTargets) {
								for(var u = {}, h = 0; h < c.length; h++)
									if(c[h].morphTargets)
										for(var d = 0; d < c[h].morphTargets.length; d++)
											u[c[h].morphTargets[d]] = -1;
								for(var f in u) {
									for(var p = [], m = [], d = 0; d !== c[h].morphTargets.length; ++d) {
										var v = c[h];
										p.push(v.time),
											m.push(v.morphTarget === f ? 1 : 0)
									}
									i.push(new ti(".morphTargetInfluence[" + f + "]", p, m))
								}
								o = u.length * (a || 1)
							} else {
								var g = ".bones[" + e[l].name + "]";
								n(Jn, g + ".position", c, "pos", i),
									n($n, g + ".quaternion", c, "rot", i),
									n(Jn, g + ".scale", c, "scl", i)
							}
					}
					if(0 === i.length)
						return null;
					var _ = new oi(r, o, i);
					return _
				}
			}),
			Object.assign(oi.prototype, {
				resetDuration: function() {
					for(var t = this.tracks, e = 0, n = 0, i = t.length; n !== i; ++n) {
						var r = this.tracks[n];
						e = Math.max(e, r.times[r.times.length - 1])
					}
					this.duration = e
				},
				trim: function() {
					for(var t = 0; t < this.tracks.length; t++)
						this.tracks[t].trim(0, this.duration);
					return this
				},
				optimize: function() {
					for(var t = 0; t < this.tracks.length; t++)
						this.tracks[t].optimize();
					return this
				}
			}),
			Object.assign(ai.prototype, {
				load: function(t, e, n, i) {
					var r = this,
						o = new Rn(r.manager);
					o.setResponseType("json"),
						o.load(t, function(t) {
							e(r.parse(t))
						}, n, i)
				},
				setTextures: function(t) {
					this.textures = t
				},
				parse: function(t) {
					function e(t) {
						return void 0 === i[t] && console.warn("THREE.MaterialLoader: Undefined texture", t),
							i[t]
					}
					var i = this.textures,
						r = new Vc[t.type];
					if(void 0 !== t.uuid && (r.uuid = t.uuid),
						void 0 !== t.name && (r.name = t.name),
						void 0 !== t.color && r.color.setHex(t.color),
						void 0 !== t.roughness && (r.roughness = t.roughness),
						void 0 !== t.metalness && (r.metalness = t.metalness),
						void 0 !== t.emissive && r.emissive.setHex(t.emissive),
						void 0 !== t.specular && r.specular.setHex(t.specular),
						void 0 !== t.shininess && (r.shininess = t.shininess),
						void 0 !== t.clearCoat && (r.clearCoat = t.clearCoat),
						void 0 !== t.clearCoatRoughness && (r.clearCoatRoughness = t.clearCoatRoughness),
						void 0 !== t.uniforms && (r.uniforms = t.uniforms),
						void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader),
						void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader),
						void 0 !== t.vertexColors && (r.vertexColors = t.vertexColors),
						void 0 !== t.fog && (r.fog = t.fog),
						void 0 !== t.shading && (r.shading = t.shading),
						void 0 !== t.blending && (r.blending = t.blending),
						void 0 !== t.side && (r.side = t.side),
						void 0 !== t.opacity && (r.opacity = t.opacity),
						void 0 !== t.transparent && (r.transparent = t.transparent),
						void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest),
						void 0 !== t.depthTest && (r.depthTest = t.depthTest),
						void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite),
						void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite),
						void 0 !== t.wireframe && (r.wireframe = t.wireframe),
						void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth),
						void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap),
						void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin),
						void 0 !== t.skinning && (r.skinning = t.skinning),
						void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets),
						void 0 !== t.size && (r.size = t.size),
						void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation),
						void 0 !== t.map && (r.map = e(t.map)),
						void 0 !== t.alphaMap && (r.alphaMap = e(t.alphaMap),
							r.transparent = !0),
						void 0 !== t.bumpMap && (r.bumpMap = e(t.bumpMap)),
						void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale),
						void 0 !== t.normalMap && (r.normalMap = e(t.normalMap)),
						void 0 !== t.normalScale) {
						var o = t.normalScale;
						Array.isArray(o) === !1 && (o = [o, o]),
							r.normalScale = (new n).fromArray(o)
					}
					return void 0 !== t.displacementMap && (r.displacementMap = e(t.displacementMap)),
						void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale),
						void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias),
						void 0 !== t.roughnessMap && (r.roughnessMap = e(t.roughnessMap)),
						void 0 !== t.metalnessMap && (r.metalnessMap = e(t.metalnessMap)),
						void 0 !== t.emissiveMap && (r.emissiveMap = e(t.emissiveMap)),
						void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity),
						void 0 !== t.specularMap && (r.specularMap = e(t.specularMap)),
						void 0 !== t.envMap && (r.envMap = e(t.envMap)),
						void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity),
						void 0 !== t.lightMap && (r.lightMap = e(t.lightMap)),
						void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity),
						void 0 !== t.aoMap && (r.aoMap = e(t.aoMap)),
						void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity),
						void 0 !== t.gradientMap && (r.gradientMap = e(t.gradientMap)),
						r
				}
			}),
			Object.assign(si.prototype, {
				load: function(t, e, n, i) {
					var r = this,
						o = new Rn(r.manager);
					o.setResponseType("json"),
						o.load(t, function(t) {
							e(r.parse(t))
						}, n, i)
				},
				parse: function(t) {
					var e = new Xt,
						n = t.data.index;
					if(void 0 !== n) {
						var i = new qc[n.type](n.array);
						e.setIndex(new ft(i, 1))
					}
					var r = t.data.attributes;
					for(var o in r) {
						var a = r[o],
							i = new qc[a.type](a.array);
						e.addAttribute(o, new ft(i, a.itemSize, a.normalized))
					}
					var s = t.data.groups || t.data.drawcalls || t.data.offsets;
					if(void 0 !== s)
						for(var c = 0, u = s.length; c !== u; ++c) {
							var h = s[c];
							e.addGroup(h.start, h.count, h.materialIndex)
						}
					var d = t.data.boundingSphere;
					if(void 0 !== d) {
						var f = new l;
						void 0 !== d.center && f.fromArray(d.center),
							e.boundingSphere = new tt(f, d.radius)
					}
					return e
				}
			});
		var qc = {
			Int8Array: Int8Array,
			Uint8Array: Uint8Array,
			Uint8ClampedArray: Uint8ClampedArray,
			Int16Array: Int16Array,
			Uint16Array: Uint16Array,
			Int32Array: Int32Array,
			Uint32Array: Uint32Array,
			Float32Array: Float32Array,
			Float64Array: Float64Array
		};
		li.Handlers = {
				handlers: [],
				add: function(t, e) {
					this.handlers.push(t, e)
				},
				get: function(t) {
					for(var e = this.handlers, n = 0, i = e.length; n < i; n += 2) {
						var r = e[n],
							o = e[n + 1];
						if(r.test(t))
							return o
					}
					return null
				}
			},
			Object.assign(li.prototype, {
				crossOrigin: void 0,
				extractUrlBase: function(t) {
					var e = t.split("/");
					return 1 === e.length ? "./" : (e.pop(),
						e.join("/") + "/")
				},
				initMaterials: function(t, e, n) {
					for(var i = [], r = 0; r < t.length; ++r)
						i[r] = this.createMaterial(t[r], e, n);
					return i
				},
				createMaterial: function() {
					var t = {
							NoBlending: To,
							NormalBlending: Mo,
							AdditiveBlending: Eo,
							SubtractiveBlending: So,
							MultiplyBlending: Xo,
							CustomBlending: Ao
						},
						e = new W,
						n = new Dn,
						i = new ai;
					return function(r, o, a) {
						function s(t, e, i, r, s) {
							var c, u = o + t,
								h = li.Handlers.get(u);
							null !== h ? c = h.load(u) : (n.setCrossOrigin(a),
									c = n.load(u)),
								void 0 !== e && (c.repeat.fromArray(e),
									1 !== e[0] && (c.wrapS = ma),
									1 !== e[1] && (c.wrapT = ma)),
								void 0 !== i && c.offset.fromArray(i),
								void 0 !== r && ("repeat" === r[0] && (c.wrapS = ma),
									"mirror" === r[0] && (c.wrapS = ga),
									"repeat" === r[1] && (c.wrapT = ma),
									"mirror" === r[1] && (c.wrapT = ga)),
								void 0 !== s && (c.anisotropy = s);
							var d = xs.generateUUID();
							return l[d] = c,
								d
						}
						var l = {},
							c = {
								uuid: xs.generateUUID(),
								type: "MeshLambertMaterial"
							};
						for(var u in r) {
							var h = r[u];
							switch(u) {
								case "DbgColor":
								case "DbgIndex":
								case "opticalDensity":
								case "illumination":
									break;
								case "DbgName":
									c.name = h;
									break;
								case "blending":
									c.blending = t[h];
									break;
								case "colorAmbient":
								case "mapAmbient":
									console.warn("THREE.Loader.createMaterial:", u, "is no longer supported.");
									break;
								case "colorDiffuse":
									c.color = e.fromArray(h).getHex();
									break;
								case "colorSpecular":
									c.specular = e.fromArray(h).getHex();
									break;
								case "colorEmissive":
									c.emissive = e.fromArray(h).getHex();
									break;
								case "specularCoef":
									c.shininess = h;
									break;
								case "shading":
									"basic" === h.toLowerCase() && (c.type = "MeshBasicMaterial"),
										"phong" === h.toLowerCase() && (c.type = "MeshPhongMaterial"),
										"standard" === h.toLowerCase() && (c.type = "MeshStandardMaterial");
									break;
								case "mapDiffuse":
									c.map = s(h, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
									break;
								case "mapDiffuseRepeat":
								case "mapDiffuseOffset":
								case "mapDiffuseWrap":
								case "mapDiffuseAnisotropy":
									break;
								case "mapEmissive":
									c.emissiveMap = s(h, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy);
									break;
								case "mapEmissiveRepeat":
								case "mapEmissiveOffset":
								case "mapEmissiveWrap":
								case "mapEmissiveAnisotropy":
									break;
								case "mapLight":
									c.lightMap = s(h, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
									break;
								case "mapLightRepeat":
								case "mapLightOffset":
								case "mapLightWrap":
								case "mapLightAnisotropy":
									break;
								case "mapAO":
									c.aoMap = s(h, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
									break;
								case "mapAORepeat":
								case "mapAOOffset":
								case "mapAOWrap":
								case "mapAOAnisotropy":
									break;
								case "mapBump":
									c.bumpMap = s(h, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
									break;
								case "mapBumpScale":
									c.bumpScale = h;
									break;
								case "mapBumpRepeat":
								case "mapBumpOffset":
								case "mapBumpWrap":
								case "mapBumpAnisotropy":
									break;
								case "mapNormal":
									c.normalMap = s(h, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
									break;
								case "mapNormalFactor":
									c.normalScale = [h, h];
									break;
								case "mapNormalRepeat":
								case "mapNormalOffset":
								case "mapNormalWrap":
								case "mapNormalAnisotropy":
									break;
								case "mapSpecular":
									c.specularMap = s(h, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
									break;
								case "mapSpecularRepeat":
								case "mapSpecularOffset":
								case "mapSpecularWrap":
								case "mapSpecularAnisotropy":
									break;
								case "mapMetalness":
									c.metalnessMap = s(h, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy);
									break;
								case "mapMetalnessRepeat":
								case "mapMetalnessOffset":
								case "mapMetalnessWrap":
								case "mapMetalnessAnisotropy":
									break;
								case "mapRoughness":
									c.roughnessMap = s(h, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy);
									break;
								case "mapRoughnessRepeat":
								case "mapRoughnessOffset":
								case "mapRoughnessWrap":
								case "mapRoughnessAnisotropy":
									break;
								case "mapAlpha":
									c.alphaMap = s(h, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
									break;
								case "mapAlphaRepeat":
								case "mapAlphaOffset":
								case "mapAlphaWrap":
								case "mapAlphaAnisotropy":
									break;
								case "flipSided":
									c.side = vo;
									break;
								case "doubleSided":
									c.side = go;
									break;
								case "transparency":
									console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"),
										c.opacity = h;
									break;
								case "depthTest":
								case "depthWrite":
								case "colorWrite":
								case "opacity":
								case "reflectivity":
								case "transparent":
								case "visible":
								case "wireframe":
									c[u] = h;
									break;
								case "vertexColors":
									h === !0 && (c.vertexColors = wo),
										"face" === h && (c.vertexColors = xo);
									break;
								default:
									console.error("THREE.Loader.createMaterial: Unsupported", u, h)
							}
						}
						return "MeshBasicMaterial" === c.type && delete c.emissive,
							"MeshPhongMaterial" !== c.type && delete c.specular,
							c.opacity < 1 && (c.transparent = !0),
							i.setTextures(l),
							i.parse(c)
					}
				}()
			}),
			Object.assign(ci.prototype, {
				load: function(t, e, n, i) {
					var r = this,
						o = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : li.prototype.extractUrlBase(t),
						a = new Rn(this.manager);
					a.setResponseType("json"),
						a.setWithCredentials(this.withCredentials),
						a.load(t, function(n) {
							var i = n.metadata;
							if(void 0 !== i) {
								var a = i.type;
								if(void 0 !== a) {
									if("object" === a.toLowerCase())
										return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.");
									if("scene" === a.toLowerCase())
										return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.SceneLoader instead.")
								}
							}
							var s = r.parse(n, o);
							e(s.geometry, s.materials)
						}, n, i)
				},
				setTexturePath: function(t) {
					this.texturePath = t
				},
				parse: function() {
					function t(t, e) {
						function i(t, e) {
							return t & 1 << e
						}
						var r, o, a, s, c, u, h, d, f, p, m, v, g, _, y, b, x, w, T, M, E, S, X, A, P, R, O, C = t.faces,
							L = t.vertices,
							I = t.normals,
							D = t.colors,
							B = t.scale,
							F = 0;
						if(void 0 !== t.uvs) {
							for(r = 0; r < t.uvs.length; r++)
								t.uvs[r].length && F++;
							for(r = 0; r < F; r++)
								e.faceVertexUvs[r] = []
						}
						for(s = 0,
							c = L.length; s < c;)
							w = new l,
							w.x = L[s++] * B,
							w.y = L[s++] * B,
							w.z = L[s++] * B,
							e.vertices.push(w);
						for(s = 0,
							c = C.length; s < c;)
							if(p = C[s++],
								m = i(p, 0),
								v = i(p, 1),
								g = i(p, 3),
								_ = i(p, 4),
								y = i(p, 5),
								b = i(p, 6),
								x = i(p, 7),
								m) {
								if(M = new ht,
									M.a = C[s],
									M.b = C[s + 1],
									M.c = C[s + 3],
									E = new ht,
									E.a = C[s + 1],
									E.b = C[s + 2],
									E.c = C[s + 3],
									s += 4,
									v && (f = C[s++],
										M.materialIndex = f,
										E.materialIndex = f),
									a = e.faces.length,
									g)
									for(r = 0; r < F; r++)
										for(A = t.uvs[r],
											e.faceVertexUvs[r][a] = [],
											e.faceVertexUvs[r][a + 1] = [],
											o = 0; o < 4; o++)
											d = C[s++],
											R = A[2 * d],
											O = A[2 * d + 1],
											P = new n(R, O),
											2 !== o && e.faceVertexUvs[r][a].push(P),
											0 !== o && e.faceVertexUvs[r][a + 1].push(P);
								if(_ && (h = 3 * C[s++],
										M.normal.set(I[h++], I[h++], I[h]),
										E.normal.copy(M.normal)),
									y)
									for(r = 0; r < 4; r++)
										h = 3 * C[s++],
										X = new l(I[h++], I[h++], I[h]),
										2 !== r && M.vertexNormals.push(X),
										0 !== r && E.vertexNormals.push(X);
								if(b && (u = C[s++],
										S = D[u],
										M.color.setHex(S),
										E.color.setHex(S)),
									x)
									for(r = 0; r < 4; r++)
										u = C[s++],
										S = D[u],
										2 !== r && M.vertexColors.push(new W(S)),
										0 !== r && E.vertexColors.push(new W(S));
								e.faces.push(M),
									e.faces.push(E)
							} else {
								if(T = new ht,
									T.a = C[s++],
									T.b = C[s++],
									T.c = C[s++],
									v && (f = C[s++],
										T.materialIndex = f),
									a = e.faces.length,
									g)
									for(r = 0; r < F; r++)
										for(A = t.uvs[r],
											e.faceVertexUvs[r][a] = [],
											o = 0; o < 3; o++)
											d = C[s++],
											R = A[2 * d],
											O = A[2 * d + 1],
											P = new n(R, O),
											e.faceVertexUvs[r][a].push(P);
								if(_ && (h = 3 * C[s++],
										T.normal.set(I[h++], I[h++], I[h])),
									y)
									for(r = 0; r < 3; r++)
										h = 3 * C[s++],
										X = new l(I[h++], I[h++], I[h]),
										T.vertexNormals.push(X);
								if(b && (u = C[s++],
										T.color.setHex(D[u])),
									x)
									for(r = 0; r < 3; r++)
										u = C[s++],
										T.vertexColors.push(new W(D[u]));
								e.faces.push(T)
							}
					}

					function e(t, e) {
						var n = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
						if(t.skinWeights)
							for(var i = 0, o = t.skinWeights.length; i < o; i += n) {
								var a = t.skinWeights[i],
									s = n > 1 ? t.skinWeights[i + 1] : 0,
									l = n > 2 ? t.skinWeights[i + 2] : 0,
									c = n > 3 ? t.skinWeights[i + 3] : 0;
								e.skinWeights.push(new r(a, s, l, c))
							}
						if(t.skinIndices)
							for(var i = 0, o = t.skinIndices.length; i < o; i += n) {
								var u = t.skinIndices[i],
									h = n > 1 ? t.skinIndices[i + 1] : 0,
									d = n > 2 ? t.skinIndices[i + 2] : 0,
									f = n > 3 ? t.skinIndices[i + 3] : 0;
								e.skinIndices.push(new r(u, h, d, f))
							}
						e.bones = t.bones,
							e.bones && e.bones.length > 0 && (e.skinWeights.length !== e.skinIndices.length || e.skinIndices.length !== e.vertices.length) && console.warn("When skinning, number of vertices (" + e.vertices.length + "), skinIndices (" + e.skinIndices.length + "), and skinWeights (" + e.skinWeights.length + ") should match.")
					}

					function i(t, e) {
						var n = t.scale;
						if(void 0 !== t.morphTargets)
							for(var i = 0, r = t.morphTargets.length; i < r; i++) {
								e.morphTargets[i] = {},
									e.morphTargets[i].name = t.morphTargets[i].name,
									e.morphTargets[i].vertices = [];
								for(var o = e.morphTargets[i].vertices, a = t.morphTargets[i].vertices, s = 0, c = a.length; s < c; s += 3) {
									var u = new l;
									u.x = a[s] * n,
										u.y = a[s + 1] * n,
										u.z = a[s + 2] * n,
										o.push(u)
								}
							}
						if(void 0 !== t.morphColors && t.morphColors.length > 0) {
							console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
							for(var h = e.faces, d = t.morphColors[0].colors, i = 0, r = h.length; i < r; i++)
								h[i].color.fromArray(d, 3 * i)
						}
					}

					function o(t, e) {
						var n = [],
							i = [];
						void 0 !== t.animation && i.push(t.animation),
							void 0 !== t.animations && (t.animations.length ? i = i.concat(t.animations) : i.push(t.animations));
						for(var r = 0; r < i.length; r++) {
							var o = oi.parseAnimation(i[r], e.bones);
							o && n.push(o)
						}
						if(e.morphTargets) {
							var a = oi.CreateClipsFromMorphTargetSequences(e.morphTargets, 10);
							n = n.concat(a)
						}
						n.length > 0 && (e.animations = n)
					}
					return function(n, r) {
						void 0 !== n.data && (n = n.data),
							void 0 !== n.scale ? n.scale = 1 / n.scale : n.scale = 1;
						var a = new St;
						if(t(n, a),
							e(n, a),
							i(n, a),
							o(n, a),
							a.computeFaceNormals(),
							a.computeBoundingSphere(),
							void 0 === n.materials || 0 === n.materials.length)
							return {
								geometry: a
							};
						var s = li.prototype.initMaterials(n.materials, r, this.crossOrigin);
						return {
							geometry: a,
							materials: s
						}
					}
				}()
			}),
			Object.assign(ui.prototype, {
				load: function(t, e, n, i) {
					"" === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
					var r = this,
						o = new Rn(r.manager);
					o.load(t, function(n) {
						var o = null;
						try {
							o = JSON.parse(n)
						} catch(e) {
							return void 0 !== i && i(e),
								void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
						}
						var a = o.metadata;
						return void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase() ? void console.error("THREE.ObjectLoader: Can't load " + t + ". Use THREE.JSONLoader instead.") : void r.parse(o, e)
					}, n, i)
				},
				setTexturePath: function(t) {
					this.texturePath = t
				},
				setCrossOrigin: function(t) {
					this.crossOrigin = t
				},
				parse: function(t, e) {
					var n = this.parseGeometries(t.geometries),
						i = this.parseImages(t.images, function() {
							void 0 !== e && e(a)
						}),
						r = this.parseTextures(t.textures, i),
						o = this.parseMaterials(t.materials, r),
						a = this.parseObject(t.object, n, o);
					return t.animations && (a.animations = this.parseAnimations(t.animations)),
						void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(a),
						a
				},
				parseGeometries: function(t) {
					var e = {};
					if(void 0 !== t)
						for(var n = new ci, i = new si, r = 0, o = t.length; r < o; r++) {
							var a, s = t[r];
							switch(s.type) {
								case "PlaneGeometry":
								case "PlaneBufferGeometry":
									a = new jc[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
									break;
								case "BoxGeometry":
								case "BoxBufferGeometry":
								case "CubeGeometry":
									a = new jc[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
									break;
								case "CircleGeometry":
								case "CircleBufferGeometry":
									a = new jc[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
									break;
								case "CylinderGeometry":
								case "CylinderBufferGeometry":
									a = new jc[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
									break;
								case "ConeGeometry":
								case "ConeBufferGeometry":
									a = new jc[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
									break;
								case "SphereGeometry":
								case "SphereBufferGeometry":
									a = new jc[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
									break;
								case "DodecahedronGeometry":
								case "IcosahedronGeometry":
								case "OctahedronGeometry":
								case "TetrahedronGeometry":
									a = new jc[s.type](s.radius, s.detail);
									break;
								case "RingGeometry":
								case "RingBufferGeometry":
									a = new jc[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
									break;
								case "TorusGeometry":
								case "TorusBufferGeometry":
									a = new jc[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
									break;
								case "TorusKnotGeometry":
								case "TorusKnotBufferGeometry":
									a = new jc[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
									break;
								case "LatheGeometry":
								case "LatheBufferGeometry":
									a = new jc[s.type](s.points, s.segments, s.phiStart, s.phiLength);
									break;
								case "BufferGeometry":
									a = i.parse(s);
									break;
								case "Geometry":
									a = n.parse(s, this.texturePath).geometry;
									break;
								default:
									console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
									continue
							}
							a.uuid = s.uuid,
								void 0 !== s.name && (a.name = s.name),
								e[s.uuid] = a
						}
					return e
				},
				parseMaterials: function(t, e) {
					var n = {};
					if(void 0 !== t) {
						var i = new ai;
						i.setTextures(e);
						for(var r = 0, o = t.length; r < o; r++) {
							var a = t[r];
							if("MultiMaterial" === a.type) {
								for(var s = [], l = 0; l < a.materials.length; l++)
									s.push(i.parse(a.materials[l]));
								n[a.uuid] = s
							} else
								n[a.uuid] = i.parse(a)
						}
					}
					return n
				},
				parseAnimations: function(t) {
					for(var e = [], n = 0; n < t.length; n++) {
						var i = oi.parse(t[n]);
						e.push(i)
					}
					return e
				},
				parseImages: function(t, e) {
					function n(t) {
						return i.manager.itemStart(t),
							a.load(t, function() {
								i.manager.itemEnd(t)
							}, void 0, function() {
								i.manager.itemEnd(t),
									i.manager.itemError(t)
							})
					}
					var i = this,
						r = {};
					if(void 0 !== t && t.length > 0) {
						var o = new Pn(e),
							a = new Ln(o);
						a.setCrossOrigin(this.crossOrigin);
						for(var s = 0, l = t.length; s < l; s++) {
							var c = t[s],
								u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : i.texturePath + c.url;
							r[c.uuid] = n(u)
						}
					}
					return r
				},
				parseTextures: function(t, e) {
					function n(t, e) {
						return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t),
							e[t])
					}
					var r = {};
					if(void 0 !== t)
						for(var o = 0, a = t.length; o < a; o++) {
							var s = t[o];
							void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid),
								void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
							var l = new i(e[s.image]);
							l.needsUpdate = !0,
								l.uuid = s.uuid,
								void 0 !== s.name && (l.name = s.name),
								void 0 !== s.mapping && (l.mapping = n(s.mapping, Zc)),
								void 0 !== s.offset && l.offset.fromArray(s.offset),
								void 0 !== s.repeat && l.repeat.fromArray(s.repeat),
								void 0 !== s.wrap && (l.wrapS = n(s.wrap[0], Qc),
									l.wrapT = n(s.wrap[1], Qc)),
								void 0 !== s.minFilter && (l.minFilter = n(s.minFilter, Jc)),
								void 0 !== s.magFilter && (l.magFilter = n(s.magFilter, Jc)),
								void 0 !== s.anisotropy && (l.anisotropy = s.anisotropy),
								void 0 !== s.flipY && (l.flipY = s.flipY),
								r[s.uuid] = l
						}
					return r
				},
				parseObject: function() {
					var t = new c;
					return function(e, n, i) {
						function r(t) {
							return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t),
								n[t]
						}

						function o(t) {
							if(void 0 !== t) {
								if(Array.isArray(t)) {
									for(var e = [], n = 0, r = t.length; n < r; n++) {
										var o = t[n];
										void 0 === i[o] && console.warn("THREE.ObjectLoader: Undefined material", o),
											e.push(i[o])
									}
									return e
								}
								return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined material", t),
									i[t]
							}
						}
						var a;
						switch(e.type) {
							case "Scene":
								a = new ve,
									void 0 !== e.background && Number.isInteger(e.background) && (a.background = new W(e.background)),
									void 0 !== e.fog && ("Fog" === e.fog.type ? a.fog = new me(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (a.fog = new pe(e.fog.color, e.fog.density)));
								break;
							case "PerspectiveCamera":
								a = new It(e.fov, e.aspect, e.near, e.far),
									void 0 !== e.focus && (a.focus = e.focus),
									void 0 !== e.zoom && (a.zoom = e.zoom),
									void 0 !== e.filmGauge && (a.filmGauge = e.filmGauge),
									void 0 !== e.filmOffset && (a.filmOffset = e.filmOffset),
									void 0 !== e.view && (a.view = Object.assign({}, e.view));
								break;
							case "OrthographicCamera":
								a = new Dt(e.left, e.right, e.top, e.bottom, e.near, e.far);
								break;
							case "AmbientLight":
								a = new Gn(e.color, e.intensity);
								break;
							case "DirectionalLight":
								a = new Vn(e.color, e.intensity);
								break;
							case "PointLight":
								a = new Un(e.color, e.intensity, e.distance, e.decay);
								break;
							case "RectAreaLight":
								a = new Hn(e.color, e.intensity, e.width, e.height);
								break;
							case "SpotLight":
								a = new kn(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
								break;
							case "HemisphereLight":
								a = new Fn(e.color, e.groundColor, e.intensity);
								break;
							case "SkinnedMesh":
								console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
							case "Mesh":
								var s = r(e.geometry),
									l = o(e.material);
								a = s.bones && s.bones.length > 0 ? new Te(s, l) : new At(s, l);
								break;
							case "LOD":
								a = new be;
								break;
							case "Line":
								a = new Ee(r(e.geometry), o(e.material), e.mode);
								break;
							case "LineLoop":
								a = new Xe(r(e.geometry), o(e.material));
								break;
							case "LineSegments":
								a = new Se(r(e.geometry), o(e.material));
								break;
							case "PointCloud":
							case "Points":
								a = new Pe(r(e.geometry), o(e.material));
								break;
							case "Sprite":
								a = new ye(o(e.material));
								break;
							case "Group":
								a = new Re;
								break;
							default:
								a = new lt
						}
						if(a.uuid = e.uuid,
							void 0 !== e.name && (a.name = e.name),
							void 0 !== e.matrix ? (t.fromArray(e.matrix),
								t.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== e.position && a.position.fromArray(e.position),
								void 0 !== e.rotation && a.rotation.fromArray(e.rotation),
								void 0 !== e.quaternion && a.quaternion.fromArray(e.quaternion),
								void 0 !== e.scale && a.scale.fromArray(e.scale)),
							void 0 !== e.castShadow && (a.castShadow = e.castShadow),
							void 0 !== e.receiveShadow && (a.receiveShadow = e.receiveShadow),
							e.shadow && (void 0 !== e.shadow.bias && (a.shadow.bias = e.shadow.bias),
								void 0 !== e.shadow.radius && (a.shadow.radius = e.shadow.radius),
								void 0 !== e.shadow.mapSize && a.shadow.mapSize.fromArray(e.shadow.mapSize),
								void 0 !== e.shadow.camera && (a.shadow.camera = this.parseObject(e.shadow.camera))),
							void 0 !== e.visible && (a.visible = e.visible),
							void 0 !== e.userData && (a.userData = e.userData),
							void 0 !== e.children)
							for(var c in e.children)
								a.add(this.parseObject(e.children[c], n, i));
						if("LOD" === e.type)
							for(var u = e.levels, h = 0; h < u.length; h++) {
								var d = u[h],
									c = a.getObjectByProperty("uuid", d.object);
								void 0 !== c && a.addLevel(c, d.distance)
							}
						return a
					}
				}()
			});
		var Zc = {
				UVMapping: sa,
				CubeReflectionMapping: la,
				CubeRefractionMapping: ca,
				EquirectangularReflectionMapping: ua,
				EquirectangularRefractionMapping: ha,
				SphericalReflectionMapping: da,
				CubeUVReflectionMapping: fa,
				CubeUVRefractionMapping: pa
			},
			Qc = {
				RepeatWrapping: ma,
				ClampToEdgeWrapping: va,
				MirroredRepeatWrapping: ga
			},
			Jc = {
				NearestFilter: _a,
				NearestMipMapNearestFilter: ya,
				NearestMipMapLinearFilter: ba,
				LinearFilter: xa,
				LinearMipMapNearestFilter: wa,
				LinearMipMapLinearFilter: Ta
			};
		Object.assign(xi.prototype, {
				getPoint: function() {
					return console.warn("THREE.Curve: .getPoint() not implemented."),
						null
				},
				getPointAt: function(t) {
					var e = this.getUtoTmapping(t);
					return this.getPoint(e)
				},
				getPoints: function(t) {
					void 0 === t && (t = 5);
					for(var e = [], n = 0; n <= t; n++)
						e.push(this.getPoint(n / t));
					return e
				},
				getSpacedPoints: function(t) {
					void 0 === t && (t = 5);
					for(var e = [], n = 0; n <= t; n++)
						e.push(this.getPointAt(n / t));
					return e
				},
				getLength: function() {
					var t = this.getLengths();
					return t[t.length - 1]
				},
				getLengths: function(t) {
					if(void 0 === t && (t = this.arcLengthDivisions),
						this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
						return this.cacheArcLengths;
					this.needsUpdate = !1;
					var e, n, i = [],
						r = this.getPoint(0),
						o = 0;
					for(i.push(0),
						n = 1; n <= t; n++)
						e = this.getPoint(n / t),
						o += e.distanceTo(r),
						i.push(o),
						r = e;
					return this.cacheArcLengths = i,
						i
				},
				updateArcLengths: function() {
					this.needsUpdate = !0,
						this.getLengths()
				},
				getUtoTmapping: function(t, e) {
					var n, i = this.getLengths(),
						r = 0,
						o = i.length;
					n = e ? e : t * i[o - 1];
					for(var a, s = 0, l = o - 1; s <= l;)
						if(r = Math.floor(s + (l - s) / 2),
							a = i[r] - n,
							a < 0)
							s = r + 1;
						else {
							if(!(a > 0)) {
								l = r;
								break
							}
							l = r - 1
						}
					if(r = l,
						i[r] === n)
						return r / (o - 1);
					var c = i[r],
						u = i[r + 1],
						h = u - c,
						d = (n - c) / h,
						f = (r + d) / (o - 1);
					return f
				},
				getTangent: function(t) {
					var e = 1e-4,
						n = t - e,
						i = t + e;
					n < 0 && (n = 0),
						i > 1 && (i = 1);
					var r = this.getPoint(n),
						o = this.getPoint(i),
						a = o.clone().sub(r);
					return a.normalize()
				},
				getTangentAt: function(t) {
					var e = this.getUtoTmapping(t);
					return this.getTangent(e)
				},
				computeFrenetFrames: function(t, e) {
					var n, i, r, o = new l,
						a = [],
						s = [],
						u = [],
						h = new l,
						d = new c;
					for(n = 0; n <= t; n++)
						i = n / t,
						a[n] = this.getTangentAt(i),
						a[n].normalize();
					s[0] = new l,
						u[0] = new l;
					var f = Number.MAX_VALUE,
						p = Math.abs(a[0].x),
						m = Math.abs(a[0].y),
						v = Math.abs(a[0].z);
					for(p <= f && (f = p,
							o.set(1, 0, 0)),
						m <= f && (f = m,
							o.set(0, 1, 0)),
						v <= f && o.set(0, 0, 1),
						h.crossVectors(a[0], o).normalize(),
						s[0].crossVectors(a[0], h),
						u[0].crossVectors(a[0], s[0]),
						n = 1; n <= t; n++)
						s[n] = s[n - 1].clone(),
						u[n] = u[n - 1].clone(),
						h.crossVectors(a[n - 1], a[n]),
						h.length() > Number.EPSILON && (h.normalize(),
							r = Math.acos(xs.clamp(a[n - 1].dot(a[n]), -1, 1)),
							s[n].applyMatrix4(d.makeRotationAxis(h, r))),
						u[n].crossVectors(a[n], s[n]);
					if(e === !0)
						for(r = Math.acos(xs.clamp(s[0].dot(s[t]), -1, 1)),
							r /= t,
							a[0].dot(h.crossVectors(s[0], s[t])) > 0 && (r = -r),
							n = 1; n <= t; n++)
							s[n].applyMatrix4(d.makeRotationAxis(a[n], r * n)),
							u[n].crossVectors(a[n], s[n]);
					return {
						tangents: a,
						normals: s,
						binormals: u
					}
				}
			}),
			wi.prototype = Object.create(xi.prototype),
			wi.prototype.constructor = wi,
			wi.prototype.isLineCurve = !0,
			wi.prototype.getPoint = function(t) {
				if(1 === t)
					return this.v2.clone();
				var e = this.v2.clone().sub(this.v1);
				return e.multiplyScalar(t).add(this.v1),
					e
			},
			wi.prototype.getPointAt = function(t) {
				return this.getPoint(t)
			},
			wi.prototype.getTangent = function(t) {
				var e = this.v2.clone().sub(this.v1);
				return e.normalize()
			},
			Ti.prototype = Object.assign(Object.create(xi.prototype), {
				constructor: Ti,
				add: function(t) {
					this.curves.push(t)
				},
				closePath: function() {
					var t = this.curves[0].getPoint(0),
						e = this.curves[this.curves.length - 1].getPoint(1);
					t.equals(e) || this.curves.push(new wi(e, t))
				},
				getPoint: function(t) {
					for(var e = t * this.getLength(), n = this.getCurveLengths(), i = 0; i < n.length;) {
						if(n[i] >= e) {
							var r = n[i] - e,
								o = this.curves[i],
								a = o.getLength(),
								s = 0 === a ? 0 : 1 - r / a;
							return o.getPointAt(s)
						}
						i++
					}
					return null
				},
				getLength: function() {
					var t = this.getCurveLengths();
					return t[t.length - 1]
				},
				updateArcLengths: function() {
					this.needsUpdate = !0,
						this.cacheLengths = null,
						this.getCurveLengths()
				},
				getCurveLengths: function() {
					if(this.cacheLengths && this.cacheLengths.length === this.curves.length)
						return this.cacheLengths;
					for(var t = [], e = 0, n = 0, i = this.curves.length; n < i; n++)
						e += this.curves[n].getLength(),
						t.push(e);
					return this.cacheLengths = t,
						t
				},
				getSpacedPoints: function(t) {
					void 0 === t && (t = 40);
					for(var e = [], n = 0; n <= t; n++)
						e.push(this.getPoint(n / t));
					return this.autoClose && e.push(e[0]),
						e
				},
				getPoints: function(t) {
					t = t || 12;
					for(var e, n = [], i = 0, r = this.curves; i < r.length; i++)
						for(var o = r[i], a = o && o.isEllipseCurve ? 2 * t : o && o.isLineCurve ? 1 : o && o.isSplineCurve ? t * o.points.length : t, s = o.getPoints(a), l = 0; l < s.length; l++) {
							var c = s[l];
							e && e.equals(c) || (n.push(c),
								e = c)
						}
					return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]),
						n
				},
				createPointsGeometry: function(t) {
					var e = this.getPoints(t);
					return this.createGeometry(e)
				},
				createSpacedPointsGeometry: function(t) {
					var e = this.getSpacedPoints(t);
					return this.createGeometry(e)
				},
				createGeometry: function(t) {
					for(var e = new St, n = 0, i = t.length; n < i; n++) {
						var r = t[n];
						e.vertices.push(new l(r.x, r.y, r.z || 0))
					}
					return e
				}
			}),
			Mi.prototype = Object.create(xi.prototype),
			Mi.prototype.constructor = Mi,
			Mi.prototype.isEllipseCurve = !0,
			Mi.prototype.getPoint = function(t) {
				for(var e = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, r = Math.abs(i) < Number.EPSILON; i < 0;)
					i += e;
				for(; i > e;)
					i -= e;
				i < Number.EPSILON && (i = r ? 0 : e),
					this.aClockwise !== !0 || r || (i === e ? i = -e : i -= e);
				var o = this.aStartAngle + t * i,
					a = this.aX + this.xRadius * Math.cos(o),
					s = this.aY + this.yRadius * Math.sin(o);
				if(0 !== this.aRotation) {
					var l = Math.cos(this.aRotation),
						c = Math.sin(this.aRotation),
						u = a - this.aX,
						h = s - this.aY;
					a = u * l - h * c + this.aX,
						s = u * c + h * l + this.aY
				}
				return new n(a, s)
			},
			Ei.prototype = Object.create(xi.prototype),
			Ei.prototype.constructor = Ei,
			Ei.prototype.isSplineCurve = !0,
			Ei.prototype.getPoint = function(t) {
				var e = this.points,
					i = (e.length - 1) * t,
					r = Math.floor(i),
					o = i - r,
					a = e[0 === r ? r : r - 1],
					s = e[r],
					l = e[r > e.length - 2 ? e.length - 1 : r + 1],
					c = e[r > e.length - 3 ? e.length - 1 : r + 2];
				return new n(hi(o, a.x, s.x, l.x, c.x), hi(o, a.y, s.y, l.y, c.y))
			},
			Si.prototype = Object.create(xi.prototype),
			Si.prototype.constructor = Si,
			Si.prototype.getPoint = function(t) {
				var e = this.v0,
					i = this.v1,
					r = this.v2,
					o = this.v3;
				return new n(bi(t, e.x, i.x, r.x, o.x), bi(t, e.y, i.y, r.y, o.y))
			},
			Xi.prototype = Object.create(xi.prototype),
			Xi.prototype.constructor = Xi,
			Xi.prototype.getPoint = function(t) {
				var e = this.v0,
					i = this.v1,
					r = this.v2;
				return new n(mi(t, e.x, i.x, r.x), mi(t, e.y, i.y, r.y))
			};
		var Kc = Object.assign(Object.create(Ti.prototype), {
			fromPoints: function(t) {
				this.moveTo(t[0].x, t[0].y);
				for(var e = 1, n = t.length; e < n; e++)
					this.lineTo(t[e].x, t[e].y)
			},
			moveTo: function(t, e) {
				this.currentPoint.set(t, e)
			},
			lineTo: function(t, e) {
				var i = new wi(this.currentPoint.clone(), new n(t, e));
				this.curves.push(i),
					this.currentPoint.set(t, e)
			},
			quadraticCurveTo: function(t, e, i, r) {
				var o = new Xi(this.currentPoint.clone(), new n(t, e), new n(i, r));
				this.curves.push(o),
					this.currentPoint.set(i, r)
			},
			bezierCurveTo: function(t, e, i, r, o, a) {
				var s = new Si(this.currentPoint.clone(), new n(t, e), new n(i, r), new n(o, a));
				this.curves.push(s),
					this.currentPoint.set(o, a)
			},
			splineThru: function(t) {
				var e = [this.currentPoint.clone()].concat(t),
					n = new Ei(e);
				this.curves.push(n),
					this.currentPoint.copy(t[t.length - 1])
			},
			arc: function(t, e, n, i, r, o) {
				var a = this.currentPoint.x,
					s = this.currentPoint.y;
				this.absarc(t + a, e + s, n, i, r, o)
			},
			absarc: function(t, e, n, i, r, o) {
				this.absellipse(t, e, n, n, i, r, o)
			},
			ellipse: function(t, e, n, i, r, o, a, s) {
				var l = this.currentPoint.x,
					c = this.currentPoint.y;
				this.absellipse(t + l, e + c, n, i, r, o, a, s)
			},
			absellipse: function(t, e, n, i, r, o, a, s) {
				var l = new Mi(t, e, n, i, r, o, a, s);
				if(this.curves.length > 0) {
					var c = l.getPoint(0);
					c.equals(this.currentPoint) || this.lineTo(c.x, c.y)
				}
				this.curves.push(l);
				var u = l.getPoint(1);
				this.currentPoint.copy(u)
			}
		});
		Ai.prototype = Kc,
			Kc.constructor = Ai,
			Pi.prototype = Object.assign(Object.create(Kc), {
				constructor: Pi,
				getPointsHoles: function(t) {
					for(var e = [], n = 0, i = this.holes.length; n < i; n++)
						e[n] = this.holes[n].getPoints(t);
					return e
				},
				extractAllPoints: function(t) {
					return {
						shape: this.getPoints(t),
						holes: this.getPointsHoles(t)
					}
				},
				extractPoints: function(t) {
					return this.extractAllPoints(t)
				}
			}),
			Object.assign(Ri.prototype, {
				moveTo: function(t, e) {
					this.currentPath = new Ai,
						this.subPaths.push(this.currentPath),
						this.currentPath.moveTo(t, e)
				},
				lineTo: function(t, e) {
					this.currentPath.lineTo(t, e)
				},
				quadraticCurveTo: function(t, e, n, i) {
					this.currentPath.quadraticCurveTo(t, e, n, i)
				},
				bezierCurveTo: function(t, e, n, i, r, o) {
					this.currentPath.bezierCurveTo(t, e, n, i, r, o)
				},
				splineThru: function(t) {
					this.currentPath.splineThru(t)
				},
				toShapes: function(t, e) {
					function n(t) {
						for(var e = [], n = 0, i = t.length; n < i; n++) {
							var r = t[n],
								o = new Pi;
							o.curves = r.curves,
								e.push(o)
						}
						return e
					}

					function i(t, e) {
						for(var n = e.length, i = !1, r = n - 1, o = 0; o < n; r = o++) {
							var a = e[r],
								s = e[o],
								l = s.x - a.x,
								c = s.y - a.y;
							if(Math.abs(c) > Number.EPSILON) {
								if(c < 0 && (a = e[o],
										l = -l,
										s = e[r],
										c = -c),
									t.y < a.y || t.y > s.y)
									continue;
								if(t.y === a.y) {
									if(t.x === a.x)
										return !0
								} else {
									var u = c * (t.x - a.x) - l * (t.y - a.y);
									if(0 === u)
										return !0;
									if(u < 0)
										continue;
									i = !i
								}
							} else {
								if(t.y !== a.y)
									continue;
								if(s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x)
									return !0
							}
						}
						return i
					}
					var r = Uc.isClockWise,
						o = this.subPaths;
					if(0 === o.length)
						return [];
					if(e === !0)
						return n(o);
					var a, s, l, c = [];
					if(1 === o.length)
						return s = o[0],
							l = new Pi,
							l.curves = s.curves,
							c.push(l),
							c;
					var u = !r(o[0].getPoints());
					u = t ? !u : u;
					var h, d = [],
						f = [],
						p = [],
						m = 0;
					f[m] = void 0,
						p[m] = [];
					for(var v = 0, g = o.length; v < g; v++)
						s = o[v],
						h = s.getPoints(),
						a = r(h),
						a = t ? !a : a,
						a ? (!u && f[m] && m++,
							f[m] = {
								s: new Pi,
								p: h
							},
							f[m].s.curves = s.curves,
							u && m++,
							p[m] = []) : p[m].push({
							h: s,
							p: h[0]
						});
					if(!f[0])
						return n(o);
					if(f.length > 1) {
						for(var _ = !1, y = [], b = 0, x = f.length; b < x; b++)
							d[b] = [];
						for(var b = 0, x = f.length; b < x; b++)
							for(var w = p[b], T = 0; T < w.length; T++) {
								for(var M = w[T], E = !0, S = 0; S < f.length; S++)
									i(M.p, f[S].p) && (b !== S && y.push({
											froms: b,
											tos: S,
											hole: T
										}),
										E ? (E = !1,
											d[S].push(M)) : _ = !0);
								E && d[b].push(M)
							}
						y.length > 0 && (_ || (p = d))
					}
					for(var X, v = 0, A = f.length; v < A; v++) {
						l = f[v].s,
							c.push(l),
							X = p[v];
						for(var P = 0, R = X.length; P < R; P++)
							l.holes.push(X[P].h)
					}
					return c
				}
			}),
			Object.assign(Oi.prototype, {
				isFont: !0,
				generateShapes: function(t, e, n) {
					function i(t) {
						for(var n = String(t).split(""), i = e / o.resolution, a = (o.boundingBox.yMax - o.boundingBox.yMin + o.underlineThickness) * i, s = 0, l = 0, c = [], u = 0; u < n.length; u++) {
							var h = n[u];
							if("\n" === h)
								s = 0,
								l -= a;
							else {
								var d = r(h, i, s, l);
								s += d.offsetX,
									c.push(d.path)
							}
						}
						return c
					}

					function r(t, e, i, r) {
						var a = o.glyphs[t] || o.glyphs["?"];
						if(a) {
							var s, l, c, u, h, d, f, p, m, v, g, _ = new Ri,
								y = [];
							if(a.o)
								for(var b = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), x = 0, w = b.length; x < w;) {
									var T = b[x++];
									switch(T) {
										case "m":
											s = b[x++] * e + i,
												l = b[x++] * e + r,
												_.moveTo(s, l);
											break;
										case "l":
											s = b[x++] * e + i,
												l = b[x++] * e + r,
												_.lineTo(s, l);
											break;
										case "q":
											if(c = b[x++] * e + i,
												u = b[x++] * e + r,
												f = b[x++] * e + i,
												p = b[x++] * e + r,
												_.quadraticCurveTo(f, p, c, u),
												g = y[y.length - 1]) {
												h = g.x,
													d = g.y;
												for(var M = 1; M <= n; M++) {
													var E = M / n;
													mi(E, h, f, c),
														mi(E, d, p, u)
												}
											}
											break;
										case "b":
											if(c = b[x++] * e + i,
												u = b[x++] * e + r,
												f = b[x++] * e + i,
												p = b[x++] * e + r,
												m = b[x++] * e + i,
												v = b[x++] * e + r,
												_.bezierCurveTo(f, p, m, v, c, u),
												g = y[y.length - 1]) {
												h = g.x,
													d = g.y;
												for(var M = 1; M <= n; M++) {
													var E = M / n;
													bi(E, h, f, m, c),
														bi(E, d, p, v, u)
												}
											}
									}
								}
							return {
								offsetX: a.ha * e,
								path: _
							}
						}
					}
					void 0 === e && (e = 100),
						void 0 === n && (n = 4);
					for(var o = this.data, a = i(t), s = [], l = 0, c = a.length; l < c; l++)
						Array.prototype.push.apply(s, a[l].toShapes());
					return s
				}
			}),
			Object.assign(Ci.prototype, {
				load: function(t, e, n, i) {
					var r = this,
						o = new Rn(this.manager);
					o.load(t, function(t) {
						var n;
						try {
							n = JSON.parse(t)
						} catch(e) {
							console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
								n = JSON.parse(t.substring(65, t.length - 2))
						}
						var i = r.parse(n);
						e && e(i)
					}, n, i)
				},
				parse: function(t) {
					return new Oi(t)
				}
			});
		var $c, tu = {
			getContext: function() {
				return void 0 === $c && ($c = new(window.AudioContext || window.webkitAudioContext)),
					$c
			},
			setContext: function(t) {
				$c = t
			}
		};
		Object.assign(Li.prototype, {
				load: function(t, e, n, i) {
					var r = new Rn(this.manager);
					r.setResponseType("arraybuffer"),
						r.load(t, function(t) {
							var n = tu.getContext();
							n.decodeAudioData(t, function(t) {
								e(t)
							})
						}, n, i)
				}
			}),
			Object.assign(Ii.prototype, {
				update: function() {
					var t, e, n, i, r, o, a, s, l = new c,
						u = new c;
					return function(c) {
						var h = t !== this || e !== c.focus || n !== c.fov || i !== c.aspect * this.aspect || r !== c.near || o !== c.far || a !== c.zoom || s !== this.eyeSep;
						if(h) {
							t = this,
								e = c.focus,
								n = c.fov,
								i = c.aspect * this.aspect,
								r = c.near,
								o = c.far,
								a = c.zoom;
							var d = c.projectionMatrix.clone();
							s = this.eyeSep / 2;
							var f, p, m = s * r / e,
								v = r * Math.tan(xs.DEG2RAD * n * .5) / a;
							u.elements[12] = -s,
								l.elements[12] = s,
								f = -v * i + m,
								p = v * i + m,
								d.elements[0] = 2 * r / (p - f),
								d.elements[8] = (p + f) / (p - f),
								this.cameraL.projectionMatrix.copy(d),
								f = -v * i - m,
								p = v * i - m,
								d.elements[0] = 2 * r / (p - f),
								d.elements[8] = (p + f) / (p - f),
								this.cameraR.projectionMatrix.copy(d)
						}
						this.cameraL.matrixWorld.copy(c.matrixWorld).multiply(u),
							this.cameraR.matrixWorld.copy(c.matrixWorld).multiply(l)
					}
				}()
			}),
			Di.prototype = Object.create(lt.prototype),
			Di.prototype.constructor = Di,
			Bi.prototype = Object.assign(Object.create(It.prototype), {
				constructor: Bi,
				isArrayCamera: !0
			}),
			Fi.prototype = Object.assign(Object.create(lt.prototype), {
				constructor: Fi,
				getInput: function() {
					return this.gain
				},
				removeFilter: function() {
					null !== this.filter && (this.gain.disconnect(this.filter),
						this.filter.disconnect(this.context.destination),
						this.gain.connect(this.context.destination),
						this.filter = null)
				},
				getFilter: function() {
					return this.filter
				},
				setFilter: function(t) {
					null !== this.filter ? (this.gain.disconnect(this.filter),
							this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
						this.filter = t,
						this.gain.connect(this.filter),
						this.filter.connect(this.context.destination)
				},
				getMasterVolume: function() {
					return this.gain.gain.value
				},
				setMasterVolume: function(t) {
					this.gain.gain.value = t
				},
				updateMatrixWorld: function() {
					var t = new l,
						e = new s,
						n = new l,
						i = new l;
					return function(r) {
						lt.prototype.updateMatrixWorld.call(this, r);
						var o = this.context.listener,
							a = this.up;
						this.matrixWorld.decompose(t, e, n),
							i.set(0, 0, -1).applyQuaternion(e),
							o.positionX ? (o.positionX.setValueAtTime(t.x, this.context.currentTime),
								o.positionY.setValueAtTime(t.y, this.context.currentTime),
								o.positionZ.setValueAtTime(t.z, this.context.currentTime),
								o.forwardX.setValueAtTime(i.x, this.context.currentTime),
								o.forwardY.setValueAtTime(i.y, this.context.currentTime),
								o.forwardZ.setValueAtTime(i.z, this.context.currentTime),
								o.upX.setValueAtTime(a.x, this.context.currentTime),
								o.upY.setValueAtTime(a.y, this.context.currentTime),
								o.upZ.setValueAtTime(a.z, this.context.currentTime)) : (o.setPosition(t.x, t.y, t.z),
								o.setOrientation(i.x, i.y, i.z, a.x, a.y, a.z))
					}
				}()
			}),
			zi.prototype = Object.assign(Object.create(lt.prototype), {
				constructor: zi,
				getOutput: function() {
					return this.gain
				},
				setNodeSource: function(t) {
					return this.hasPlaybackControl = !1,
						this.sourceType = "audioNode",
						this.source = t,
						this.connect(),
						this
				},
				setBuffer: function(t) {
					return this.buffer = t,
						this.sourceType = "buffer",
						this.autoplay && this.play(),
						this
				},
				play: function() {
					if(this.isPlaying === !0)
						return void console.warn("THREE.Audio: Audio is already playing.");
					if(this.hasPlaybackControl === !1)
						return void console.warn("THREE.Audio: this Audio has no playback control.");
					var t = this.context.createBufferSource();
					return t.buffer = this.buffer,
						t.loop = this.loop,
						t.onended = this.onEnded.bind(this),
						t.playbackRate.setValueAtTime(this.playbackRate, this.startTime),
						t.start(0, this.startTime),
						this.isPlaying = !0,
						this.source = t,
						this.connect()
				},
				pause: function() {
					return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(),
						this.startTime = this.context.currentTime,
						this.isPlaying = !1,
						this)
				},
				stop: function() {
					return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(),
						this.startTime = 0,
						this.isPlaying = !1,
						this)
				},
				connect: function() {
					if(this.filters.length > 0) {
						this.source.connect(this.filters[0]);
						for(var t = 1, e = this.filters.length; t < e; t++)
							this.filters[t - 1].connect(this.filters[t]);
						this.filters[this.filters.length - 1].connect(this.getOutput())
					} else
						this.source.connect(this.getOutput());
					return this
				},
				disconnect: function() {
					if(this.filters.length > 0) {
						this.source.disconnect(this.filters[0]);
						for(var t = 1, e = this.filters.length; t < e; t++)
							this.filters[t - 1].disconnect(this.filters[t]);
						this.filters[this.filters.length - 1].disconnect(this.getOutput())
					} else
						this.source.disconnect(this.getOutput());
					return this
				},
				getFilters: function() {
					return this.filters
				},
				setFilters: function(t) {
					return t || (t = []),
						this.isPlaying === !0 ? (this.disconnect(),
							this.filters = t,
							this.connect()) : this.filters = t,
						this
				},
				getFilter: function() {
					return this.getFilters()[0]
				},
				setFilter: function(t) {
					return this.setFilters(t ? [t] : [])
				},
				setPlaybackRate: function(t) {
					return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.playbackRate = t,
						this.isPlaying === !0 && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime),
						this)
				},
				getPlaybackRate: function() {
					return this.playbackRate
				},
				onEnded: function() {
					this.isPlaying = !1
				},
				getLoop: function() {
					return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
				},
				setLoop: function(t) {
					return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.loop = t,
						this.isPlaying === !0 && (this.source.loop = this.loop),
						this)
				},
				getVolume: function() {
					return this.gain.gain.value
				},
				setVolume: function(t) {
					return this.gain.gain.value = t,
						this
				}
			}),
			Ni.prototype = Object.assign(Object.create(zi.prototype), {
				constructor: Ni,
				getOutput: function() {
					return this.panner
				},
				getRefDistance: function() {
					return this.panner.refDistance
				},
				setRefDistance: function(t) {
					this.panner.refDistance = t
				},
				getRolloffFactor: function() {
					return this.panner.rolloffFactor
				},
				setRolloffFactor: function(t) {
					this.panner.rolloffFactor = t
				},
				getDistanceModel: function() {
					return this.panner.distanceModel
				},
				setDistanceModel: function(t) {
					this.panner.distanceModel = t
				},
				getMaxDistance: function() {
					return this.panner.maxDistance
				},
				setMaxDistance: function(t) {
					this.panner.maxDistance = t
				},
				updateMatrixWorld: function() {
					var t = new l;
					return function(e) {
						lt.prototype.updateMatrixWorld.call(this, e),
							t.setFromMatrixPosition(this.matrixWorld),
							this.panner.setPosition(t.x, t.y, t.z)
					}
				}()
			}),
			Object.assign(ki.prototype, {
				getFrequencyData: function() {
					return this.analyser.getByteFrequencyData(this.data),
						this.data
				},
				getAverageFrequency: function() {
					for(var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++)
						t += e[n];
					return t / e.length
				}
			}),
			Object.assign(Ui.prototype, {
				accumulate: function(t, e) {
					var n = this.buffer,
						i = this.valueSize,
						r = t * i + i,
						o = this.cumulativeWeight;
					if(0 === o) {
						for(var a = 0; a !== i; ++a)
							n[r + a] = n[a];
						o = e
					} else {
						o += e;
						var s = e / o;
						this._mixBufferRegion(n, r, 0, s, i)
					}
					this.cumulativeWeight = o
				},
				apply: function(t) {
					var e = this.valueSize,
						n = this.buffer,
						i = t * e + e,
						r = this.cumulativeWeight,
						o = this.binding;
					if(this.cumulativeWeight = 0,
						r < 1) {
						var a = 3 * e;
						this._mixBufferRegion(n, i, a, 1 - r, e)
					}
					for(var s = e, l = e + e; s !== l; ++s)
						if(n[s] !== n[s + e]) {
							o.setValue(n, i);
							break
						}
				},
				saveOriginalState: function() {
					var t = this.binding,
						e = this.buffer,
						n = this.valueSize,
						i = 3 * n;
					t.getValue(e, i);
					for(var r = n, o = i; r !== o; ++r)
						e[r] = e[i + r % n];
					this.cumulativeWeight = 0
				},
				restoreOriginalState: function() {
					var t = 3 * this.valueSize;
					this.binding.setValue(this.buffer, t)
				},
				_select: function(t, e, n, i, r) {
					if(i >= .5)
						for(var o = 0; o !== r; ++o)
							t[e + o] = t[n + o]
				},
				_slerp: function(t, e, n, i) {
					s.slerpFlat(t, e, t, e, t, n, i)
				},
				_lerp: function(t, e, n, i, r) {
					for(var o = 1 - i, a = 0; a !== r; ++a) {
						var s = e + a;
						t[s] = t[s] * o + t[n + a] * i
					}
				}
			}),
			Object.assign(ji.prototype, {
				getValue: function(t, e) {
					this.bind();
					var n = this._targetGroup.nCachedObjects_,
						i = this._bindings[n];
					void 0 !== i && i.getValue(t, e)
				},
				setValue: function(t, e) {
					for(var n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
						n[i].setValue(t, e)
				},
				bind: function() {
					for(var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
						t[e].bind()
				},
				unbind: function() {
					for(var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
						t[e].unbind()
				}
			}),
			Object.assign(Vi, {
				Composite: ji,
				create: function(t, e, n) {
					return t && t.isAnimationObjectGroup ? new Vi.Composite(t, e, n) : new Vi(t, e, n)
				},
				parseTrackName: function() {
					var t = /((?:[\w-]+[\/:])*)/,
						e = /([\w-\.]+)?/,
						n = /(?:\.([\w-]+)(?:\[(.+)\])?)?/,
						i = /\.([\w-]+)(?:\[(.+)\])?/,
						r = new RegExp("^" + t.source + e.source + n.source + i.source + "$"),
						o = ["material", "materials", "bones"];
					return function(t) {
						var e = r.exec(t);
						if(!e)
							throw new Error("PropertyBinding: Cannot parse trackName: " + t);
						var n = {
								nodeName: e[2],
								objectName: e[3],
								objectIndex: e[4],
								propertyName: e[5],
								propertyIndex: e[6]
							},
							i = n.nodeName && n.nodeName.lastIndexOf(".");
						if(void 0 !== i && i !== -1) {
							var a = n.nodeName.substring(i + 1);
							o.indexOf(a) !== -1 && (n.nodeName = n.nodeName.substring(0, i),
								n.objectName = a)
						}
						if(null === n.propertyName || 0 === n.propertyName.length)
							throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
						return n
					}
				}(),
				findNode: function(t, e) {
					if(!e || "" === e || "root" === e || "." === e || e === -1 || e === t.name || e === t.uuid)
						return t;
					if(t.skeleton) {
						var n = function(t) {
								for(var n = 0; n < t.bones.length; n++) {
									var i = t.bones[n];
									if(i.name === e)
										return i
								}
								return null
							},
							i = n(t.skeleton);
						if(i)
							return i
					}
					if(t.children) {
						var r = function(t) {
								for(var n = 0; n < t.length; n++) {
									var i = t[n];
									if(i.name === e || i.uuid === e)
										return i;
									var o = r(i.children);
									if(o)
										return o
								}
								return null
							},
							o = r(t.children);
						if(o)
							return o
					}
					return null
				}
			}),
			Object.assign(Vi.prototype, {
				_getValue_unavailable: function() {},
				_setValue_unavailable: function() {},
				BindingType: {
					Direct: 0,
					EntireArray: 1,
					ArrayElement: 2,
					HasFromToArray: 3
				},
				Versioning: {
					None: 0,
					NeedsUpdate: 1,
					MatrixWorldNeedsUpdate: 2
				},
				GetterByBindingType: [function(t, e) {
					t[e] = this.node[this.propertyName]
				}, function(t, e) {
					for(var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)
						t[e++] = n[i]
				}, function(t, e) {
					t[e] = this.resolvedProperty[this.propertyIndex]
				}, function(t, e) {
					this.resolvedProperty.toArray(t, e)
				}],
				SetterByBindingTypeAndVersioning: [
					[function(t, e) {
						this.node[this.propertyName] = t[e]
					}, function(t, e) {
						this.node[this.propertyName] = t[e],
							this.targetObject.needsUpdate = !0
					}, function(t, e) {
						this.node[this.propertyName] = t[e],
							this.targetObject.matrixWorldNeedsUpdate = !0
					}],
					[function(t, e) {
						for(var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)
							n[i] = t[e++]
					}, function(t, e) {
						for(var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)
							n[i] = t[e++];
						this.targetObject.needsUpdate = !0
					}, function(t, e) {
						for(var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)
							n[i] = t[e++];
						this.targetObject.matrixWorldNeedsUpdate = !0
					}],
					[function(t, e) {
						this.resolvedProperty[this.propertyIndex] = t[e]
					}, function(t, e) {
						this.resolvedProperty[this.propertyIndex] = t[e],
							this.targetObject.needsUpdate = !0
					}, function(t, e) {
						this.resolvedProperty[this.propertyIndex] = t[e],
							this.targetObject.matrixWorldNeedsUpdate = !0
					}],
					[function(t, e) {
						this.resolvedProperty.fromArray(t, e)
					}, function(t, e) {
						this.resolvedProperty.fromArray(t, e),
							this.targetObject.needsUpdate = !0
					}, function(t, e) {
						this.resolvedProperty.fromArray(t, e),
							this.targetObject.matrixWorldNeedsUpdate = !0
					}]
				],
				getValue: function(t, e) {
					this.bind(),
						this.getValue(t, e)
				},
				setValue: function(t, e) {
					this.bind(),
						this.setValue(t, e)
				},
				bind: function() {
					var t = this.node,
						e = this.parsedPath,
						n = e.objectName,
						i = e.propertyName,
						r = e.propertyIndex;
					if(t || (t = Vi.findNode(this.rootNode, e.nodeName) || this.rootNode,
							this.node = t),
						this.getValue = this._getValue_unavailable,
						this.setValue = this._setValue_unavailable, !t)
						return void console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
					if(n) {
						var o = e.objectIndex;
						switch(n) {
							case "materials":
								if(!t.material)
									return void console.error("  can not bind to material as node does not have a material", this);
								if(!t.material.materials)
									return void console.error("  can not bind to material.materials as node.material does not have a materials array", this);
								t = t.material.materials;
								break;
							case "bones":
								if(!t.skeleton)
									return void console.error("  can not bind to bones as node does not have a skeleton", this);
								t = t.skeleton.bones;
								for(var a = 0; a < t.length; a++)
									if(t[a].name === o) {
										o = a;
										break
									}
								break;
							default:
								if(void 0 === t[n])
									return void console.error("  can not bind to objectName of node, undefined", this);
								t = t[n]
						}
						if(void 0 !== o) {
							if(void 0 === t[o])
								return void console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, t);
							t = t[o]
						}
					}
					var s = t[i];
					if(void 0 === s) {
						var l = e.nodeName;
						return void console.error("  trying to update property for track: " + l + "." + i + " but it wasn't found.", t)
					}
					var c = this.Versioning.None;
					void 0 !== t.needsUpdate ? (c = this.Versioning.NeedsUpdate,
						this.targetObject = t) : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate,
						this.targetObject = t);
					var u = this.BindingType.Direct;
					if(void 0 !== r) {
						if("morphTargetInfluences" === i) {
							if(!t.geometry)
								return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
							if(!t.geometry.morphTargets)
								return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
							for(var a = 0; a < this.node.geometry.morphTargets.length; a++)
								if(t.geometry.morphTargets[a].name === r) {
									r = a;
									break
								}
						}
						u = this.BindingType.ArrayElement,
							this.resolvedProperty = s,
							this.propertyIndex = r
					} else
						void 0 !== s.fromArray && void 0 !== s.toArray ? (u = this.BindingType.HasFromToArray,
							this.resolvedProperty = s) : Array.isArray(s) ? (u = this.BindingType.EntireArray,
							this.resolvedProperty = s) : this.propertyName = i;
					this.getValue = this.GetterByBindingType[u],
						this.setValue = this.SetterByBindingTypeAndVersioning[u][c]
				},
				unbind: function() {
					this.node = null,
						this.getValue = this._getValue_unbound,
						this.setValue = this._setValue_unbound
				}
			}),
			//!\ DECLARE ALIAS AFTER assign prototype !
			Object.assign(Vi.prototype, {
				_getValue_unbound: Vi.prototype.getValue,
				_setValue_unbound: Vi.prototype.setValue
			}),
			Object.assign(Gi.prototype, {
				isAnimationObjectGroup: !0,
				add: function(t) {
					for(var e = this._objects, n = e.length, i = this.nCachedObjects_, r = this._indicesByUUID, o = this._paths, a = this._parsedPaths, s = this._bindings, l = s.length, c = 0, u = arguments.length; c !== u; ++c) {
						var h = arguments[c],
							d = h.uuid,
							f = r[d],
							p = void 0;
						if(void 0 === f) {
							f = n++,
								r[d] = f,
								e.push(h);
							for(var m = 0, v = l; m !== v; ++m)
								s[m].push(new Vi(h, o[m], a[m]))
						} else if(f < i) {
							p = e[f];
							var g = --i,
								_ = e[g];
							r[_.uuid] = f,
								e[f] = _,
								r[d] = g,
								e[g] = h;
							for(var m = 0, v = l; m !== v; ++m) {
								var y = s[m],
									b = y[g],
									x = y[f];
								y[f] = b,
									void 0 === x && (x = new Vi(h, o[m], a[m])),
									y[g] = x
							}
						} else
							e[f] !== p && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")
					}
					this.nCachedObjects_ = i
				},
				remove: function(t) {
					for(var e = this._objects, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, o = r.length, a = 0, s = arguments.length; a !== s; ++a) {
						var l = arguments[a],
							c = l.uuid,
							u = i[c];
						if(void 0 !== u && u >= n) {
							var h = n++,
								d = e[h];
							i[d.uuid] = u,
								e[u] = d,
								i[c] = h,
								e[h] = l;
							for(var f = 0, p = o; f !== p; ++f) {
								var m = r[f],
									v = m[h],
									g = m[u];
								m[u] = v,
									m[h] = g
							}
						}
					}
					this.nCachedObjects_ = n
				},
				uncache: function(t) {
					for(var e = this._objects, n = e.length, i = this.nCachedObjects_, r = this._indicesByUUID, o = this._bindings, a = o.length, s = 0, l = arguments.length; s !== l; ++s) {
						var c = arguments[s],
							u = c.uuid,
							h = r[u];
						if(void 0 !== h)
							if(delete r[u],
								h < i) {
								var d = --i,
									f = e[d],
									p = --n,
									m = e[p];
								r[f.uuid] = h,
									e[h] = f,
									r[m.uuid] = d,
									e[d] = m,
									e.pop();
								for(var v = 0, g = a; v !== g; ++v) {
									var _ = o[v],
										y = _[d],
										b = _[p];
									_[h] = y,
										_[d] = b,
										_.pop()
								}
							} else {
								var p = --n,
									m = e[p];
								r[m.uuid] = h,
									e[h] = m,
									e.pop();
								for(var v = 0, g = a; v !== g; ++v) {
									var _ = o[v];
									_[h] = _[p],
										_.pop()
								}
							}
					}
					this.nCachedObjects_ = i
				},
				subscribe_: function(t, e) {
					var n = this._bindingsIndicesByPath,
						i = n[t],
						r = this._bindings;
					if(void 0 !== i)
						return r[i];
					var o = this._paths,
						a = this._parsedPaths,
						s = this._objects,
						l = s.length,
						c = this.nCachedObjects_,
						u = new Array(l);
					i = r.length,
						n[t] = i,
						o.push(t),
						a.push(e),
						r.push(u);
					for(var h = c, d = s.length; h !== d; ++h) {
						var f = s[h];
						u[h] = new Vi(f, t, e)
					}
					return u
				},
				unsubscribe_: function(t) {
					var e = this._bindingsIndicesByPath,
						n = e[t];
					if(void 0 !== n) {
						var i = this._paths,
							r = this._parsedPaths,
							o = this._bindings,
							a = o.length - 1,
							s = o[a],
							l = t[a];
						e[l] = n,
							o[n] = s,
							o.pop(),
							r[n] = r[a],
							r.pop(),
							i[n] = i[a],
							i.pop()
					}
				}
			}),
			Object.assign(Hi.prototype, {
				play: function() {
					return this._mixer._activateAction(this),
						this
				},
				stop: function() {
					return this._mixer._deactivateAction(this),
						this.reset()
				},
				reset: function() {
					return this.paused = !1,
						this.enabled = !0,
						this.time = 0,
						this._loopCount = -1,
						this._startTime = null,
						this.stopFading().stopWarping()
				},
				isRunning: function() {
					return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
				},
				isScheduled: function() {
					return this._mixer._isActiveAction(this)
				},
				startAt: function(t) {
					return this._startTime = t,
						this
				},
				setLoop: function(t, e) {
					return this.loop = t,
						this.repetitions = e,
						this
				},
				setEffectiveWeight: function(t) {
					return this.weight = t,
						this._effectiveWeight = this.enabled ? t : 0,
						this.stopFading()
				},
				getEffectiveWeight: function() {
					return this._effectiveWeight
				},
				fadeIn: function(t) {
					return this._scheduleFading(t, 0, 1)
				},
				fadeOut: function(t) {
					return this._scheduleFading(t, 1, 0)
				},
				crossFadeFrom: function(t, e, n) {
					if(t.fadeOut(e),
						this.fadeIn(e),
						n) {
						var i = this._clip.duration,
							r = t._clip.duration,
							o = r / i,
							a = i / r;
						t.warp(1, o, e),
							this.warp(a, 1, e)
					}
					return this
				},
				crossFadeTo: function(t, e, n) {
					return t.crossFadeFrom(this, e, n)
				},
				stopFading: function() {
					var t = this._weightInterpolant;
					return null !== t && (this._weightInterpolant = null,
							this._mixer._takeBackControlInterpolant(t)),
						this
				},
				setEffectiveTimeScale: function(t) {
					return this.timeScale = t,
						this._effectiveTimeScale = this.paused ? 0 : t,
						this.stopWarping()
				},
				getEffectiveTimeScale: function() {
					return this._effectiveTimeScale
				},
				setDuration: function(t) {
					return this.timeScale = this._clip.duration / t,
						this.stopWarping()
				},
				syncWith: function(t) {
					return this.time = t.time,
						this.timeScale = t.timeScale,
						this.stopWarping()
				},
				halt: function(t) {
					return this.warp(this._effectiveTimeScale, 0, t)
				},
				warp: function(t, e, n) {
					var i = this._mixer,
						r = i.time,
						o = this._timeScaleInterpolant,
						a = this.timeScale;
					null === o && (o = i._lendControlInterpolant(),
						this._timeScaleInterpolant = o);
					var s = o.parameterPositions,
						l = o.sampleValues;
					return s[0] = r,
						s[1] = r + n,
						l[0] = t / a,
						l[1] = e / a,
						this
				},
				stopWarping: function() {
					var t = this._timeScaleInterpolant;
					return null !== t && (this._timeScaleInterpolant = null,
							this._mixer._takeBackControlInterpolant(t)),
						this
				},
				getMixer: function() {
					return this._mixer
				},
				getClip: function() {
					return this._clip
				},
				getRoot: function() {
					return this._localRoot || this._mixer._root
				},
				_update: function(t, e, n, i) {
					if(!this.enabled)
						return void this._updateWeight(t);
					var r = this._startTime;
					if(null !== r) {
						var o = (t - r) * n;
						if(o < 0 || 0 === n)
							return;
						this._startTime = null,
							e = n * o
					}
					e *= this._updateTimeScale(t);
					var a = this._updateTime(e),
						s = this._updateWeight(t);
					if(s > 0)
						for(var l = this._interpolants, c = this._propertyBindings, u = 0, h = l.length; u !== h; ++u)
							l[u].evaluate(a),
							c[u].accumulate(i, s)
				},
				_updateWeight: function(t) {
					var e = 0;
					if(this.enabled) {
						e = this.weight;
						var n = this._weightInterpolant;
						if(null !== n) {
							var i = n.evaluate(t)[0];
							e *= i,
								t > n.parameterPositions[1] && (this.stopFading(),
									0 === i && (this.enabled = !1))
						}
					}
					return this._effectiveWeight = e,
						e
				},
				_updateTimeScale: function(t) {
					var e = 0;
					if(!this.paused) {
						e = this.timeScale;
						var n = this._timeScaleInterpolant;
						if(null !== n) {
							var i = n.evaluate(t)[0];
							e *= i,
								t > n.parameterPositions[1] && (this.stopWarping(),
									0 === e ? this.paused = !0 : this.timeScale = e)
						}
					}
					return this._effectiveTimeScale = e,
						e
				},
				_updateTime: function(t) {
					var e = this.time + t;
					if(0 === t)
						return e;
					var n = this._clip.duration,
						i = this.loop,
						r = this._loopCount;
					if(i === $a) {
						r === -1 && (this._loopCount = 0,
							this._setEndings(!0, !0, !1));
						t: {
							if(e >= n)
								e = n;
							else {
								if(!(e < 0))
									break t;
								e = 0
							}
							this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
							this._mixer.dispatchEvent({
								type: "finished",
								action: this,
								direction: t < 0 ? -1 : 1
							})
						}
					} else {
						var o = i === es;
						if(r === -1 && (t >= 0 ? (r = 0,
								this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)),
							e >= n || e < 0) {
							var a = Math.floor(e / n);
							e -= n * a,
								r += Math.abs(a);
							var s = this.repetitions - r;
							if(s < 0)
								this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
								e = t > 0 ? n : 0,
								this._mixer.dispatchEvent({
									type: "finished",
									action: this,
									direction: t > 0 ? 1 : -1
								});
							else {
								if(0 === s) {
									var l = t < 0;
									this._setEndings(l, !l, o)
								} else
									this._setEndings(!1, !1, o);
								this._loopCount = r,
									this._mixer.dispatchEvent({
										type: "loop",
										action: this,
										loopDelta: a
									})
							}
						}
						if(o && 1 === (1 & r))
							return this.time = e,
								n - e
					}
					return this.time = e,
						e
				},
				_setEndings: function(t, e, n) {
					var i = this._interpolantSettings;
					n ? (i.endingStart = as,
						i.endingEnd = as) : (t ? i.endingStart = this.zeroSlopeAtStart ? as : os : i.endingStart = ss,
						e ? i.endingEnd = this.zeroSlopeAtEnd ? as : os : i.endingEnd = ss)
				},
				_scheduleFading: function(t, e, n) {
					var i = this._mixer,
						r = i.time,
						o = this._weightInterpolant;
					null === o && (o = i._lendControlInterpolant(),
						this._weightInterpolant = o);
					var a = o.parameterPositions,
						s = o.sampleValues;
					return a[0] = r,
						s[0] = e,
						a[1] = r + t,
						s[1] = n,
						this
				}
			}),
			Object.assign(Wi.prototype, e.prototype, {
				_bindAction: function(t, e) {
					var n = t._localRoot || this._root,
						i = t._clip.tracks,
						r = i.length,
						o = t._propertyBindings,
						a = t._interpolants,
						s = n.uuid,
						l = this._bindingsByRootAndName,
						c = l[s];
					void 0 === c && (c = {},
						l[s] = c);
					for(var u = 0; u !== r; ++u) {
						var h = i[u],
							d = h.name,
							f = c[d];
						if(void 0 !== f)
							o[u] = f;
						else {
							if(f = o[u],
								void 0 !== f) {
								null === f._cacheIndex && (++f.referenceCount,
									this._addInactiveBinding(f, s, d));
								continue
							}
							var p = e && e._propertyBindings[u].binding.parsedPath;
							f = new Ui(Vi.create(n, d, p), h.ValueTypeName, h.getValueSize()),
								++f.referenceCount,
								this._addInactiveBinding(f, s, d),
								o[u] = f
						}
						a[u].resultBuffer = f.buffer
					}
				},
				_activateAction: function(t) {
					if(!this._isActiveAction(t)) {
						if(null === t._cacheIndex) {
							var e = (t._localRoot || this._root).uuid,
								n = t._clip.uuid,
								i = this._actionsByClip[n];
							this._bindAction(t, i && i.knownActions[0]),
								this._addInactiveAction(t, n, e)
						}
						for(var r = t._propertyBindings, o = 0, a = r.length; o !== a; ++o) {
							var s = r[o];
							0 === s.useCount++ && (this._lendBinding(s),
								s.saveOriginalState())
						}
						this._lendAction(t)
					}
				},
				_deactivateAction: function(t) {
					if(this._isActiveAction(t)) {
						for(var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
							var r = e[n];
							0 === --r.useCount && (r.restoreOriginalState(),
								this._takeBackBinding(r))
						}
						this._takeBackAction(t)
					}
				},
				_initMemoryManager: function() {
					this._actions = [],
						this._nActiveActions = 0,
						this._actionsByClip = {},
						this._bindings = [],
						this._nActiveBindings = 0,
						this._bindingsByRootAndName = {},
						this._controlInterpolants = [],
						this._nActiveControlInterpolants = 0;
					var t = this;
					this.stats = {
						actions: {
							get total() {
								return t._actions.length
							},
							get inUse() {
								return t._nActiveActions
							}
						},
						bindings: {
							get total() {
								return t._bindings.length
							},
							get inUse() {
								return t._nActiveBindings
							}
						},
						controlInterpolants: {
							get total() {
								return t._controlInterpolants.length
							},
							get inUse() {
								return t._nActiveControlInterpolants
							}
						}
					}
				},
				_isActiveAction: function(t) {
					var e = t._cacheIndex;
					return null !== e && e < this._nActiveActions
				},
				_addInactiveAction: function(t, e, n) {
					var i = this._actions,
						r = this._actionsByClip,
						o = r[e];
					if(void 0 === o)
						o = {
							knownActions: [t],
							actionByRoot: {}
						},
						t._byClipCacheIndex = 0,
						r[e] = o;
					else {
						var a = o.knownActions;
						t._byClipCacheIndex = a.length,
							a.push(t)
					}
					t._cacheIndex = i.length,
						i.push(t),
						o.actionByRoot[n] = t
				},
				_removeInactiveAction: function(t) {
					var e = this._actions,
						n = e[e.length - 1],
						i = t._cacheIndex;
					n._cacheIndex = i,
						e[i] = n,
						e.pop(),
						t._cacheIndex = null;
					var r = t._clip.uuid,
						o = this._actionsByClip,
						a = o[r],
						s = a.knownActions,
						l = s[s.length - 1],
						c = t._byClipCacheIndex;
					l._byClipCacheIndex = c,
						s[c] = l,
						s.pop(),
						t._byClipCacheIndex = null;
					var u = a.actionByRoot,
						h = (t._localRoot || this._root).uuid;
					delete u[h],
						0 === s.length && delete o[r],
						this._removeInactiveBindingsForAction(t)
				},
				_removeInactiveBindingsForAction: function(t) {
					for(var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
						var r = e[n];
						0 === --r.referenceCount && this._removeInactiveBinding(r)
					}
				},
				_lendAction: function(t) {
					var e = this._actions,
						n = t._cacheIndex,
						i = this._nActiveActions++,
						r = e[i];
					t._cacheIndex = i,
						e[i] = t,
						r._cacheIndex = n,
						e[n] = r
				},
				_takeBackAction: function(t) {
					var e = this._actions,
						n = t._cacheIndex,
						i = --this._nActiveActions,
						r = e[i];
					t._cacheIndex = i,
						e[i] = t,
						r._cacheIndex = n,
						e[n] = r
				},
				_addInactiveBinding: function(t, e, n) {
					var i = this._bindingsByRootAndName,
						r = i[e],
						o = this._bindings;
					void 0 === r && (r = {},
							i[e] = r),
						r[n] = t,
						t._cacheIndex = o.length,
						o.push(t)
				},
				_removeInactiveBinding: function(t) {
					var e = this._bindings,
						n = t.binding,
						i = n.rootNode.uuid,
						r = n.path,
						o = this._bindingsByRootAndName,
						a = o[i],
						s = e[e.length - 1],
						l = t._cacheIndex;
					s._cacheIndex = l,
						e[l] = s,
						e.pop(),
						delete a[r];
					t: {
						for(var c in a)
							break t;
						delete o[i]
					}
				},
				_lendBinding: function(t) {
					var e = this._bindings,
						n = t._cacheIndex,
						i = this._nActiveBindings++,
						r = e[i];
					t._cacheIndex = i,
						e[i] = t,
						r._cacheIndex = n,
						e[n] = r
				},
				_takeBackBinding: function(t) {
					var e = this._bindings,
						n = t._cacheIndex,
						i = --this._nActiveBindings,
						r = e[i];
					t._cacheIndex = i,
						e[i] = t,
						r._cacheIndex = n,
						e[n] = r
				},
				_lendControlInterpolant: function() {
					var t = this._controlInterpolants,
						e = this._nActiveControlInterpolants++,
						n = t[e];
					return void 0 === n && (n = new qn(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer),
							n.__cacheIndex = e,
							t[e] = n),
						n
				},
				_takeBackControlInterpolant: function(t) {
					var e = this._controlInterpolants,
						n = t.__cacheIndex,
						i = --this._nActiveControlInterpolants,
						r = e[i];
					t.__cacheIndex = i,
						e[i] = t,
						r.__cacheIndex = n,
						e[n] = r
				},
				_controlInterpolantsResultBuffer: new Float32Array(1),
				clipAction: function(t, e) {
					var n = e || this._root,
						i = n.uuid,
						r = "string" == typeof t ? oi.findByName(n, t) : t,
						o = null !== r ? r.uuid : t,
						a = this._actionsByClip[o],
						s = null;
					if(void 0 !== a) {
						var l = a.actionByRoot[i];
						if(void 0 !== l)
							return l;
						s = a.knownActions[0],
							null === r && (r = s._clip)
					}
					if(null === r)
						return null;
					var c = new Hi(this, r, e);
					return this._bindAction(c, s),
						this._addInactiveAction(c, o, i),
						c
				},
				existingAction: function(t, e) {
					var n = e || this._root,
						i = n.uuid,
						r = "string" == typeof t ? oi.findByName(n, t) : t,
						o = r ? r.uuid : t,
						a = this._actionsByClip[o];
					return void 0 !== a ? a.actionByRoot[i] || null : null
				},
				stopAllAction: function() {
					var t = this._actions,
						e = this._nActiveActions,
						n = this._bindings,
						i = this._nActiveBindings;
					this._nActiveActions = 0,
						this._nActiveBindings = 0;
					for(var r = 0; r !== e; ++r)
						t[r].reset();
					for(var r = 0; r !== i; ++r)
						n[r].useCount = 0;
					return this
				},
				update: function(t) {
					t *= this.timeScale;
					for(var e = this._actions, n = this._nActiveActions, i = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== n; ++a) {
						var s = e[a];
						s._update(i, t, r, o)
					}
					for(var l = this._bindings, c = this._nActiveBindings, a = 0; a !== c; ++a)
						l[a].apply(o);
					return this
				},
				getRoot: function() {
					return this._root
				},
				uncacheClip: function(t) {
					var e = this._actions,
						n = t.uuid,
						i = this._actionsByClip,
						r = i[n];
					if(void 0 !== r) {
						for(var o = r.knownActions, a = 0, s = o.length; a !== s; ++a) {
							var l = o[a];
							this._deactivateAction(l);
							var c = l._cacheIndex,
								u = e[e.length - 1];
							l._cacheIndex = null,
								l._byClipCacheIndex = null,
								u._cacheIndex = c,
								e[c] = u,
								e.pop(),
								this._removeInactiveBindingsForAction(l)
						}
						delete i[n]
					}
				},
				uncacheRoot: function(t) {
					var e = t.uuid,
						n = this._actionsByClip;
					for(var i in n) {
						var r = n[i].actionByRoot,
							o = r[e];
						void 0 !== o && (this._deactivateAction(o),
							this._removeInactiveAction(o))
					}
					var a = this._bindingsByRootAndName,
						s = a[e];
					if(void 0 !== s)
						for(var l in s) {
							var c = s[l];
							c.restoreOriginalState(),
								this._removeInactiveBinding(c)
						}
				},
				uncacheAction: function(t, e) {
					var n = this.existingAction(t, e);
					null !== n && (this._deactivateAction(n),
						this._removeInactiveAction(n))
				}
			}),
			Yi.prototype.clone = function() {
				return new Yi(void 0 === this.value.clone ? this.value : this.value.clone())
			},
			qi.prototype = Object.assign(Object.create(Xt.prototype), {
				constructor: qi,
				isInstancedBufferGeometry: !0,
				addGroup: function(t, e, n) {
					this.groups.push({
						start: t,
						count: e,
						materialIndex: n
					})
				},
				copy: function(t) {
					var e = t.index;
					null !== e && this.setIndex(e.clone());
					var n = t.attributes;
					for(var i in n) {
						var r = n[i];
						this.addAttribute(i, r.clone())
					}
					for(var o = t.groups, a = 0, s = o.length; a < s; a++) {
						var l = o[a];
						this.addGroup(l.start, l.count, l.materialIndex)
					}
					return this
				}
			}),
			Object.defineProperties(Zi.prototype, {
				count: {
					get: function() {
						return this.data.count
					}
				},
				array: {
					get: function() {
						return this.data.array
					}
				}
			}),
			Object.assign(Zi.prototype, {
				isInterleavedBufferAttribute: !0,
				setX: function(t, e) {
					return this.data.array[t * this.data.stride + this.offset] = e,
						this
				},
				setY: function(t, e) {
					return this.data.array[t * this.data.stride + this.offset + 1] = e,
						this
				},
				setZ: function(t, e) {
					return this.data.array[t * this.data.stride + this.offset + 2] = e,
						this
				},
				setW: function(t, e) {
					return this.data.array[t * this.data.stride + this.offset + 3] = e,
						this
				},
				getX: function(t) {
					return this.data.array[t * this.data.stride + this.offset]
				},
				getY: function(t) {
					return this.data.array[t * this.data.stride + this.offset + 1]
				},
				getZ: function(t) {
					return this.data.array[t * this.data.stride + this.offset + 2]
				},
				getW: function(t) {
					return this.data.array[t * this.data.stride + this.offset + 3]
				},
				setXY: function(t, e, n) {
					return t = t * this.data.stride + this.offset,
						this.data.array[t + 0] = e,
						this.data.array[t + 1] = n,
						this
				},
				setXYZ: function(t, e, n, i) {
					return t = t * this.data.stride + this.offset,
						this.data.array[t + 0] = e,
						this.data.array[t + 1] = n,
						this.data.array[t + 2] = i,
						this
				},
				setXYZW: function(t, e, n, i, r) {
					return t = t * this.data.stride + this.offset,
						this.data.array[t + 0] = e,
						this.data.array[t + 1] = n,
						this.data.array[t + 2] = i,
						this.data.array[t + 3] = r,
						this
				}
			}),
			Object.defineProperty(Qi.prototype, "needsUpdate", {
				set: function(t) {
					t === !0 && this.version++
				}
			}),
			Object.assign(Qi.prototype, {
				isInterleavedBuffer: !0,
				setArray: function(t) {
					if(Array.isArray(t))
						throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
					this.count = void 0 !== t ? t.length / this.stride : 0,
						this.array = t
				},
				setDynamic: function(t) {
					return this.dynamic = t,
						this
				},
				copy: function(t) {
					return this.array = new t.array.constructor(t.array),
						this.count = t.count,
						this.stride = t.stride,
						this.dynamic = t.dynamic,
						this
				},
				copyAt: function(t, e, n) {
					t *= this.stride,
						n *= e.stride;
					for(var i = 0, r = this.stride; i < r; i++)
						this.array[t + i] = e.array[n + i];
					return this
				},
				set: function(t, e) {
					return void 0 === e && (e = 0),
						this.array.set(t, e),
						this
				},
				clone: function() {
					return(new this.constructor).copy(this)
				},
				onUpload: function(t) {
					return this.onUploadCallback = t,
						this
				}
			}),
			Ji.prototype = Object.assign(Object.create(Qi.prototype), {
				constructor: Ji,
				isInstancedInterleavedBuffer: !0,
				copy: function(t) {
					return Qi.prototype.copy.call(this, t),
						this.meshPerAttribute = t.meshPerAttribute,
						this
				}
			}),
			Ki.prototype = Object.assign(Object.create(ft.prototype), {
				constructor: Ki,
				isInstancedBufferAttribute: !0,
				copy: function(t) {
					return ft.prototype.copy.call(this, t),
						this.meshPerAttribute = t.meshPerAttribute,
						this
				}
			}),
			Object.assign($i.prototype, {
				linePrecision: 1,
				set: function(t, e) {
					this.ray.set(t, e)
				},
				setFromCamera: function(t, e) {
					e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
						this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
						this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
				},
				intersectObject: function(t, e) {
					var n = [];
					return er(t, this, n, e),
						n.sort(tr),
						n
				},
				intersectObjects: function(t, e) {
					var n = [];
					if(Array.isArray(t) === !1)
						return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
							n;
					for(var i = 0, r = t.length; i < r; i++)
						er(t[i], this, n, e);
					return n.sort(tr),
						n
				}
			}),
			Object.assign(nr.prototype, {
				start: function() {
					this.startTime = ("undefined" == typeof performance ? Date : performance).now(),
						this.oldTime = this.startTime,
						this.elapsedTime = 0,
						this.running = !0
				},
				stop: function() {
					this.getElapsedTime(),
						this.running = !1
				},
				getElapsedTime: function() {
					return this.getDelta(),
						this.elapsedTime
				},
				getDelta: function() {
					var t = 0;
					if(this.autoStart && !this.running)
						return this.start(),
							0;
					if(this.running) {
						var e = ("undefined" == typeof performance ? Date : performance).now();
						t = (e - this.oldTime) / 1e3,
							this.oldTime = e,
							this.elapsedTime += t
					}
					return t
				}
			}),
			Object.assign(ir.prototype, {
				set: function(t, e, n) {
					return this.radius = t,
						this.phi = e,
						this.theta = n,
						this
				},
				clone: function() {
					return(new this.constructor).copy(this)
				},
				copy: function(t) {
					return this.radius = t.radius,
						this.phi = t.phi,
						this.theta = t.theta,
						this
				},
				makeSafe: function() {
					var t = 1e-6;
					return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)),
						this
				},
				setFromVector3: function(t) {
					return this.radius = t.length(),
						0 === this.radius ? (this.theta = 0,
							this.phi = 0) : (this.theta = Math.atan2(t.x, t.z),
							this.phi = Math.acos(xs.clamp(t.y / this.radius, -1, 1))),
						this
				}
			}),
			Object.assign(rr.prototype, {
				set: function(t, e, n) {
					return this.radius = t,
						this.theta = e,
						this.y = n,
						this
				},
				clone: function() {
					return(new this.constructor).copy(this)
				},
				copy: function(t) {
					return this.radius = t.radius,
						this.theta = t.theta,
						this.y = t.y,
						this
				},
				setFromVector3: function(t) {
					return this.radius = Math.sqrt(t.x * t.x + t.z * t.z),
						this.theta = Math.atan2(t.x, t.z),
						this.y = t.y,
						this
				}
			}),
			or.prototype = Object.create(At.prototype),
			or.prototype.constructor = or,
			or.prototype.createAnimation = function(t, e, n, i) {
				var r = {
					start: e,
					end: n,
					length: n - e + 1,
					fps: i,
					duration: (n - e) / i,
					lastFrame: 0,
					currentFrame: 0,
					active: !1,
					time: 0,
					direction: 1,
					weight: 1,
					directionBackwards: !1,
					mirroredLoop: !1
				};
				this.animationsMap[t] = r,
					this.animationsList.push(r)
			},
			or.prototype.autoCreateAnimations = function(t) {
				for(var e, n = /([a-z]+)_?(\d+)/i, i = {}, r = this.geometry, o = 0, a = r.morphTargets.length; o < a; o++) {
					var s = r.morphTargets[o],
						l = s.name.match(n);
					if(l && l.length > 1) {
						var c = l[1];
						i[c] || (i[c] = {
							start: 1 / 0,
							end: -(1 / 0)
						});
						var u = i[c];
						o < u.start && (u.start = o),
							o > u.end && (u.end = o),
							e || (e = c)
					}
				}
				for(var c in i) {
					var u = i[c];
					this.createAnimation(c, u.start, u.end, t)
				}
				this.firstAnimation = e
			},
			or.prototype.setAnimationDirectionForward = function(t) {
				var e = this.animationsMap[t];
				e && (e.direction = 1,
					e.directionBackwards = !1)
			},
			or.prototype.setAnimationDirectionBackward = function(t) {
				var e = this.animationsMap[t];
				e && (e.direction = -1,
					e.directionBackwards = !0)
			},
			or.prototype.setAnimationFPS = function(t, e) {
				var n = this.animationsMap[t];
				n && (n.fps = e,
					n.duration = (n.end - n.start) / n.fps)
			},
			or.prototype.setAnimationDuration = function(t, e) {
				var n = this.animationsMap[t];
				n && (n.duration = e,
					n.fps = (n.end - n.start) / n.duration)
			},
			or.prototype.setAnimationWeight = function(t, e) {
				var n = this.animationsMap[t];
				n && (n.weight = e)
			},
			or.prototype.setAnimationTime = function(t, e) {
				var n = this.animationsMap[t];
				n && (n.time = e)
			},
			or.prototype.getAnimationTime = function(t) {
				var e = 0,
					n = this.animationsMap[t];
				return n && (e = n.time),
					e
			},
			or.prototype.getAnimationDuration = function(t) {
				var e = -1,
					n = this.animationsMap[t];
				return n && (e = n.duration),
					e
			},
			or.prototype.playAnimation = function(t) {
				var e = this.animationsMap[t];
				e ? (e.time = 0,
					e.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + t + "] undefined in .playAnimation()")
			},
			or.prototype.stopAnimation = function(t) {
				var e = this.animationsMap[t];
				e && (e.active = !1)
			},
			or.prototype.update = function(t) {
				for(var e = 0, n = this.animationsList.length; e < n; e++) {
					var i = this.animationsList[e];
					if(i.active) {
						var r = i.duration / i.length;
						i.time += i.direction * t,
							i.mirroredLoop ? (i.time > i.duration || i.time < 0) && (i.direction *= -1,
								i.time > i.duration && (i.time = i.duration,
									i.directionBackwards = !0),
								i.time < 0 && (i.time = 0,
									i.directionBackwards = !1)) : (i.time = i.time % i.duration,
								i.time < 0 && (i.time += i.duration));
						var o = i.start + xs.clamp(Math.floor(i.time / r), 0, i.length - 1),
							a = i.weight;
						o !== i.currentFrame && (this.morphTargetInfluences[i.lastFrame] = 0,
							this.morphTargetInfluences[i.currentFrame] = 1 * a,
							this.morphTargetInfluences[o] = 0,
							i.lastFrame = i.currentFrame,
							i.currentFrame = o);
						var s = i.time % r / r;
						i.directionBackwards && (s = 1 - s),
							i.currentFrame !== i.lastFrame ? (this.morphTargetInfluences[i.currentFrame] = s * a,
								this.morphTargetInfluences[i.lastFrame] = (1 - s) * a) : this.morphTargetInfluences[i.currentFrame] = a
					}
				}
			},
			ar.prototype = Object.create(lt.prototype),
			ar.prototype.constructor = ar,
			ar.prototype.isImmediateRenderObject = !0,
			sr.prototype = Object.create(Se.prototype),
			sr.prototype.constructor = sr,
			sr.prototype.update = function() {
				var t = new l,
					e = new l,
					n = new et;
				return function() {
					var i = ["a", "b", "c"];
					this.object.updateMatrixWorld(!0),
						n.getNormalMatrix(this.object.matrixWorld);
					var r = this.object.matrixWorld,
						o = this.geometry.attributes.position,
						a = this.object.geometry;
					if(a && a.isGeometry)
						for(var s = a.vertices, l = a.faces, c = 0, u = 0, h = l.length; u < h; u++)
							for(var d = l[u], f = 0, p = d.vertexNormals.length; f < p; f++) {
								var m = s[d[i[f]]],
									v = d.vertexNormals[f];
								t.copy(m).applyMatrix4(r),
									e.copy(v).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t),
									o.setXYZ(c, t.x, t.y, t.z),
									c += 1,
									o.setXYZ(c, e.x, e.y, e.z),
									c += 1
							}
					else if(a && a.isBufferGeometry)
						for(var g = a.attributes.position, _ = a.attributes.normal, c = 0, f = 0, p = g.count; f < p; f++)
							t.set(g.getX(f), g.getY(f), g.getZ(f)).applyMatrix4(r),
							e.set(_.getX(f), _.getY(f), _.getZ(f)),
							e.applyMatrix3(n).normalize().multiplyScalar(this.size).add(t),
							o.setXYZ(c, t.x, t.y, t.z),
							c += 1,
							o.setXYZ(c, e.x, e.y, e.z),
							c += 1;
					o.needsUpdate = !0
				}
			}(),
			lr.prototype = Object.create(lt.prototype),
			lr.prototype.constructor = lr,
			lr.prototype.dispose = function() {
				this.cone.geometry.dispose(),
					this.cone.material.dispose()
			},
			lr.prototype.update = function() {
				var t = new l,
					e = new l;
				return function() {
					var n = this.light.distance ? this.light.distance : 1e3,
						i = n * Math.tan(this.light.angle);
					this.cone.scale.set(i, i, n),
						t.setFromMatrixPosition(this.light.matrixWorld),
						e.setFromMatrixPosition(this.light.target.matrixWorld),
						this.cone.lookAt(e.sub(t)),
						this.cone.material.color.copy(this.light.color)
				}
			}(),
			cr.prototype = Object.create(Se.prototype),
			cr.prototype.constructor = cr,
			cr.prototype.getBoneList = function(t) {
				var e = [];
				t && t.isBone && e.push(t);
				for(var n = 0; n < t.children.length; n++)
					e.push.apply(e, this.getBoneList(t.children[n]));
				return e
			},
			cr.prototype.update = function() {
				var t = new l,
					e = new c,
					n = new c;
				return function() {
					var i = this.geometry,
						r = i.getAttribute("position");
					n.getInverse(this.root.matrixWorld);
					for(var o = 0, a = 0; o < this.bones.length; o++) {
						var s = this.bones[o];
						s.parent && s.parent.isBone && (e.multiplyMatrices(n, s.matrixWorld),
							t.setFromMatrixPosition(e),
							r.setXYZ(a, t.x, t.y, t.z),
							e.multiplyMatrices(n, s.parent.matrixWorld),
							t.setFromMatrixPosition(e),
							r.setXYZ(a + 1, t.x, t.y, t.z),
							a += 2)
					}
					i.getAttribute("position").needsUpdate = !0
				}
			}(),
			ur.prototype = Object.create(At.prototype),
			ur.prototype.constructor = ur,
			ur.prototype.dispose = function() {
				this.geometry.dispose(),
					this.material.dispose()
			},
			ur.prototype.update = function() {
				this.material.color.copy(this.light.color)
			},
			hr.prototype = Object.create(lt.prototype),
			hr.prototype.constructor = hr,
			hr.prototype.dispose = function() {
				this.children[0].geometry.dispose(),
					this.children[0].material.dispose()
			},
			hr.prototype.update = function() {
				var t = this.children[0];
				t.material.color.copy(this.light.color);
				var e = .5 * this.light.width,
					n = .5 * this.light.height,
					i = t.geometry.attributes.position,
					r = i.array;
				r[0] = e,
					r[1] = -n,
					r[2] = 0,
					r[3] = e,
					r[4] = n,
					r[5] = 0,
					r[6] = -e,
					r[7] = n,
					r[8] = 0,
					r[9] = -e,
					r[10] = -n,
					r[11] = 0,
					r[12] = e,
					r[13] = -n,
					r[14] = 0,
					i.needsUpdate = !0
			},
			dr.prototype = Object.create(lt.prototype),
			dr.prototype.constructor = dr,
			dr.prototype.dispose = function() {
				this.children[0].geometry.dispose(),
					this.children[0].material.dispose()
			},
			dr.prototype.update = function() {
				var t = new l,
					e = new W,
					n = new W;
				return function() {
					var i = this.children[0],
						r = i.geometry.getAttribute("color");
					e.copy(this.light.color),
						n.copy(this.light.groundColor);
					for(var o = 0, a = r.count; o < a; o++) {
						var s = o < a / 2 ? e : n;
						r.setXYZ(o, s.r, s.g, s.b)
					}
					i.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate()),
						r.needsUpdate = !0
				}
			}(),
			fr.prototype = Object.create(Se.prototype),
			fr.prototype.constructor = fr,
			pr.prototype = Object.create(Se.prototype),
			pr.prototype.constructor = pr,
			mr.prototype = Object.create(Se.prototype),
			mr.prototype.constructor = mr,
			mr.prototype.update = function() {
				var t = new l,
					e = new l,
					n = new et;
				return function() {
					this.object.updateMatrixWorld(!0),
						n.getNormalMatrix(this.object.matrixWorld);
					for(var i = this.object.matrixWorld, r = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = o.faces, l = 0, c = 0, u = s.length; c < u; c++) {
						var h = s[c],
							d = h.normal;
						t.copy(a[h.a]).add(a[h.b]).add(a[h.c]).divideScalar(3).applyMatrix4(i),
							e.copy(d).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t),
							r.setXYZ(l, t.x, t.y, t.z),
							l += 1,
							r.setXYZ(l, e.x, e.y, e.z),
							l += 1
					}
					r.needsUpdate = !0
				}
			}(),
			vr.prototype = Object.create(lt.prototype),
			vr.prototype.constructor = vr,
			vr.prototype.dispose = function() {
				var t = this.children[0],
					e = this.children[1];
				t.geometry.dispose(),
					t.material.dispose(),
					e.geometry.dispose(),
					e.material.dispose()
			},
			vr.prototype.update = function() {
				var t = new l,
					e = new l,
					n = new l;
				return function() {
					t.setFromMatrixPosition(this.light.matrixWorld),
						e.setFromMatrixPosition(this.light.target.matrixWorld),
						n.subVectors(e, t);
					var i = this.children[0],
						r = this.children[1];
					i.lookAt(n),
						i.material.color.copy(this.light.color),
						r.lookAt(n),
						r.scale.z = n.length()
				}
			}(),
			gr.prototype = Object.create(Se.prototype),
			gr.prototype.constructor = gr,
			gr.prototype.update = function() {
				function t(t, o, a, s) {
					i.set(o, a, s).unproject(r);
					var l = n[t];
					if(void 0 !== l)
						for(var c = e.getAttribute("position"), u = 0, h = l.length; u < h; u++)
							c.setXYZ(l[u], i.x, i.y, i.z)
				}
				var e, n, i = new l,
					r = new Lt;
				return function() {
					e = this.geometry,
						n = this.pointMap;
					var i = 1,
						o = 1;
					r.projectionMatrix.copy(this.camera.projectionMatrix),
						t("c", 0, 0, -1),
						t("t", 0, 0, 1),
						t("n1", -i, -o, -1),
						t("n2", i, -o, -1),
						t("n3", -i, o, -1),
						t("n4", i, o, -1),
						t("f1", -i, -o, 1),
						t("f2", i, -o, 1),
						t("f3", -i, o, 1),
						t("f4", i, o, 1),
						t("u1", .7 * i, 1.1 * o, -1),
						t("u2", .7 * -i, 1.1 * o, -1),
						t("u3", 0, 2 * o, -1),
						t("cf1", -i, 0, 1),
						t("cf2", i, 0, 1),
						t("cf3", 0, -o, 1),
						t("cf4", 0, o, 1),
						t("cn1", -i, 0, -1),
						t("cn2", i, 0, -1),
						t("cn3", 0, -o, -1),
						t("cn4", 0, o, -1),
						e.getAttribute("position").needsUpdate = !0
				}
			}(),
			_r.prototype = Object.create(Se.prototype),
			_r.prototype.constructor = _r,
			_r.prototype.update = function() {
				var t = new $;
				return function(e) {
					if(void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
						void 0 !== this.object && t.setFromObject(this.object), !t.isEmpty()) {
						var n = t.min,
							i = t.max,
							r = this.geometry.attributes.position,
							o = r.array;
						o[0] = i.x,
							o[1] = i.y,
							o[2] = i.z,
							o[3] = n.x,
							o[4] = i.y,
							o[5] = i.z,
							o[6] = n.x,
							o[7] = n.y,
							o[8] = i.z,
							o[9] = i.x,
							o[10] = n.y,
							o[11] = i.z,
							o[12] = i.x,
							o[13] = i.y,
							o[14] = n.z,
							o[15] = n.x,
							o[16] = i.y,
							o[17] = n.z,
							o[18] = n.x,
							o[19] = n.y,
							o[20] = n.z,
							o[21] = i.x,
							o[22] = n.y,
							o[23] = n.z,
							r.needsUpdate = !0,
							this.geometry.computeBoundingSphere()
					}
				}
			}(),
			_r.prototype.setFromObject = function(t) {
				return this.object = t,
					this.update(),
					this
			};
		var eu, nu;
		yr.prototype = Object.create(lt.prototype),
			yr.prototype.constructor = yr,
			yr.prototype.setDirection = function() {
				var t, e = new l;
				return function(n) {
					n.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : n.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(n.z, 0, -n.x).normalize(),
						t = Math.acos(n.y),
						this.quaternion.setFromAxisAngle(e, t))
				}
			}(),
			yr.prototype.setLength = function(t, e, n) {
				void 0 === e && (e = .2 * t),
					void 0 === n && (n = .2 * e),
					this.line.scale.set(1, Math.max(0, t - e), 1),
					this.line.updateMatrix(),
					this.cone.scale.set(n, e, n),
					this.cone.position.y = t,
					this.cone.updateMatrix()
			},
			yr.prototype.setColor = function(t) {
				this.line.material.color.copy(t),
					this.cone.material.color.copy(t)
			},
			br.prototype = Object.create(Se.prototype),
			br.prototype.constructor = br;
		var iu = new l,
			ru = new xr,
			ou = new xr,
			au = new xr;
		wr.prototype = Object.create(xi.prototype),
			wr.prototype.constructor = wr,
			wr.prototype.getPoint = function(t) {
				var e = this.points,
					n = e.length;
				n < 2 && console.log("duh, you need at least 2 points");
				var i = (n - (this.closed ? 0 : 1)) * t,
					r = Math.floor(i),
					o = i - r;
				this.closed ? r += r > 0 ? 0 : (Math.floor(Math.abs(r) / e.length) + 1) * e.length : 0 === o && r === n - 1 && (r = n - 2,
					o = 1);
				var a, s, c, u;
				if(this.closed || r > 0 ? a = e[(r - 1) % n] : (iu.subVectors(e[0], e[1]).add(e[0]),
						a = iu),
					s = e[r % n],
					c = e[(r + 1) % n],
					this.closed || r + 2 < n ? u = e[(r + 2) % n] : (iu.subVectors(e[n - 1], e[n - 2]).add(e[n - 1]),
						u = iu),
					void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
					var h = "chordal" === this.type ? .5 : .25,
						d = Math.pow(a.distanceToSquared(s), h),
						f = Math.pow(s.distanceToSquared(c), h),
						p = Math.pow(c.distanceToSquared(u), h);
					f < 1e-4 && (f = 1),
						d < 1e-4 && (d = f),
						p < 1e-4 && (p = f),
						ru.initNonuniformCatmullRom(a.x, s.x, c.x, u.x, d, f, p),
						ou.initNonuniformCatmullRom(a.y, s.y, c.y, u.y, d, f, p),
						au.initNonuniformCatmullRom(a.z, s.z, c.z, u.z, d, f, p)
				} else if("catmullrom" === this.type) {
					var m = void 0 !== this.tension ? this.tension : .5;
					ru.initCatmullRom(a.x, s.x, c.x, u.x, m),
						ou.initCatmullRom(a.y, s.y, c.y, u.y, m),
						au.initCatmullRom(a.z, s.z, c.z, u.z, m)
				}
				return new l(ru.calc(o), ou.calc(o), au.calc(o))
			},
			Tr.prototype = Object.create(xi.prototype),
			Tr.prototype.constructor = Tr,
			Tr.prototype.getPoint = function(t) {
				var e = this.v0,
					n = this.v1,
					i = this.v2,
					r = this.v3;
				return new l(bi(t, e.x, n.x, i.x, r.x), bi(t, e.y, n.y, i.y, r.y), bi(t, e.z, n.z, i.z, r.z))
			},
			Mr.prototype = Object.create(xi.prototype),
			Mr.prototype.constructor = Mr,
			Mr.prototype.getPoint = function(t) {
				var e = this.v0,
					n = this.v1,
					i = this.v2;
				return new l(mi(t, e.x, n.x, i.x), mi(t, e.y, n.y, i.y), mi(t, e.z, n.z, i.z))
			},
			Er.prototype = Object.create(xi.prototype),
			Er.prototype.constructor = Er,
			Er.prototype.getPoint = function(t) {
				if(1 === t)
					return this.v2.clone();
				var e = new l;
				return e.subVectors(this.v2, this.v1),
					e.multiplyScalar(t),
					e.add(this.v1),
					e
			},
			Sr.prototype = Object.create(Mi.prototype),
			Sr.prototype.constructor = Sr;
		var su = {
				createMultiMaterialObject: function(t, e) {
					for(var n = new Re, i = 0, r = e.length; i < r; i++)
						n.add(new At(t, e[i]));
					return n
				},
				detach: function(t, e, n) {
					t.applyMatrix(e.matrixWorld),
						e.remove(t),
						n.add(t)
				},
				attach: function(t, e, n) {
					var i = new c;
					i.getInverse(n.matrixWorld),
						t.applyMatrix(i),
						e.remove(t),
						n.add(t)
				}
			},
			lu = 0,
			cu = 1;
		xi.create = function(t, e) {
				return console.log("THREE.Curve.create() has been deprecated"),
					t.prototype = Object.create(xi.prototype),
					t.prototype.constructor = t,
					t.prototype.getPoint = e,
					t
			},
			Yr.prototype = Object.create(wr.prototype),
			qr.prototype = Object.create(wr.prototype),
			Zr.prototype = Object.create(wr.prototype),
			Object.assign(Zr.prototype, {
				initFromArray: function(t) {
					console.error("THREE.Spline: .initFromArray() has been removed.")
				},
				getControlPointsArray: function(t) {
					console.error("THREE.Spline: .getControlPointsArray() has been removed.")
				},
				reparametrizeByArcLength: function(t) {
					console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
				}
			}),
			fr.prototype.setColors = function() {
				console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
			},
			Object.assign(Y.prototype, {
				center: function(t) {
					return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
						this.getCenter(t)
				},
				empty: function() {
					return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
						this.isEmpty()
				},
				isIntersectionBox: function(t) {
					return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
						this.intersectsBox(t)
				},
				size: function(t) {
					return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
						this.getSize(t)
				}
			}),
			Object.assign($.prototype, {
				center: function(t) {
					return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
						this.getCenter(t)
				},
				empty: function() {
					return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
						this.isEmpty()
				},
				isIntersectionBox: function(t) {
					return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
						this.intersectsBox(t)
				},
				isIntersectionSphere: function(t) {
					return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
						this.intersectsSphere(t)
				},
				size: function(t) {
					return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
						this.getSize(t)
				}
			}),
			ct.prototype.center = function(t) {
				return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),
					this.getCenter(t)
			},
			xs.random16 = function() {
				return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."),
					Math.random()
			},
			Object.assign(et.prototype, {
				flattenToArrayOffset: function(t, e) {
					return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
						this.toArray(t, e)
				},
				multiplyVector3: function(t) {
					return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
						t.applyMatrix3(this)
				},
				multiplyVector3Array: function(t) {
					return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."),
						this.applyToVector3Array(t)
				},
				applyToBuffer: function(t, e, n) {
					return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),
						this.applyToBufferAttribute(t)
				},
				applyToVector3Array: function(t, e, n) {
					console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
				}
			}),
			Object.assign(c.prototype, {
				extractPosition: function(t) {
					return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
						this.copyPosition(t)
				},
				flattenToArrayOffset: function(t, e) {
					return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
						this.toArray(t, e)
				},
				getPosition: function() {
					var t;
					return function() {
						return void 0 === t && (t = new l),
							console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
							t.setFromMatrixColumn(this, 3)
					}
				}(),
				setRotationFromQuaternion: function(t) {
					return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
						this.makeRotationFromQuaternion(t)
				},
				multiplyToArray: function() {
					console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
				},
				multiplyVector3: function(t) {
					return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
						t.applyMatrix4(this)
				},
				multiplyVector4: function(t) {
					return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
						t.applyMatrix4(this)
				},
				multiplyVector3Array: function(t) {
					return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."),
						this.applyToVector3Array(t)
				},
				rotateAxis: function(t) {
					console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
						t.transformDirection(this)
				},
				crossVector: function(t) {
					return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
						t.applyMatrix4(this)
				},
				translate: function() {
					console.error("THREE.Matrix4: .translate() has been removed.")
				},
				rotateX: function() {
					console.error("THREE.Matrix4: .rotateX() has been removed.")
				},
				rotateY: function() {
					console.error("THREE.Matrix4: .rotateY() has been removed.")
				},
				rotateZ: function() {
					console.error("THREE.Matrix4: .rotateZ() has been removed.")
				},
				rotateByAxis: function() {
					console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
				},
				applyToBuffer: function(t, e, n) {
					return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),
						this.applyToBufferAttribute(t)
				},
				applyToVector3Array: function(t, e, n) {
					console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
				},
				makeFrustum: function(t, e, n, i, r, o) {
					return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
						this.makePerspective(t, e, i, n, r, o)
				}
			}),
			nt.prototype.isIntersectionLine = function(t) {
				return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
					this.intersectsLine(t)
			},
			s.prototype.multiplyVector3 = function(t) {
				return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
					t.applyQuaternion(this)
			},
			Object.assign(ot.prototype, {
				isIntersectionBox: function(t) {
					return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
						this.intersectsBox(t)
				},
				isIntersectionPlane: function(t) {
					return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
						this.intersectsPlane(t)
				},
				isIntersectionSphere: function(t) {
					return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
						this.intersectsSphere(t)
				}
			}),
			Object.assign(Pi.prototype, {
				extrude: function(t) {
					return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
						new tn(this, t)
				},
				makeGeometry: function(t) {
					return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
						new hn(this, t)
				}
			}),
			Object.assign(n.prototype, {
				fromAttribute: function(t, e, n) {
					return console.error("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
						this.fromBufferAttribute(t, e, n)
				}
			}),
			Object.assign(l.prototype, {
				setEulerFromRotationMatrix: function() {
					console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
				},
				setEulerFromQuaternion: function() {
					console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
				},
				getPositionFromMatrix: function(t) {
					return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
						this.setFromMatrixPosition(t)
				},
				getScaleFromMatrix: function(t) {
					return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
						this.setFromMatrixScale(t)
				},
				getColumnFromMatrix: function(t, e) {
					return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
						this.setFromMatrixColumn(e, t)
				},
				applyProjection: function(t) {
					return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
						this.applyMatrix4(t)
				},
				fromAttribute: function(t, e, n) {
					return console.error("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
						this.fromBufferAttribute(t, e, n)
				}
			}),
			Object.assign(r.prototype, {
				fromAttribute: function(t, e, n) {
					return console.error("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
						this.fromBufferAttribute(t, e, n)
				}
			}),
			St.prototype.computeTangents = function() {
				console.warn("THREE.Geometry: .computeTangents() has been removed.")
			},
			Object.assign(lt.prototype, {
				getChildByName: function(t) {
					return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
						this.getObjectByName(t)
				},
				renderDepth: function() {
					console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
				},
				translate: function(t, e) {
					return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
						this.translateOnAxis(e, t)
				}
			}),
			Object.defineProperties(lt.prototype, {
				eulerOrder: {
					get: function() {
						return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
							this.rotation.order
					},
					set: function(t) {
						console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
							this.rotation.order = t
					}
				},
				useQuaternion: {
					get: function() {
						console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
					},
					set: function() {
						console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
					}
				}
			}),
			Object.defineProperties(be.prototype, {
				objects: {
					get: function() {
						return console.warn("THREE.LOD: .objects has been renamed to .levels."),
							this.levels
					}
				}
			}),
			Object.defineProperty(xe.prototype, "useVertexTexture", {
				get: function() {
					console.warn("THREE.Skeleton: useVertexTexture has been removed.")
				},
				set: function() {
					console.warn("THREE.Skeleton: useVertexTexture has been removed.")
				}
			}),
			Object.defineProperty(xi.prototype, "__arcLengthDivisions", {
				get: function() {
					return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
						this.arcLengthDivisions
				},
				set: function(t) {
					console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
						this.arcLengthDivisions = t
				}
			}),
			It.prototype.setLens = function(t, e) {
				console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
					void 0 !== e && (this.filmGauge = e),
					this.setFocalLength(t)
			},
			Object.defineProperties(Bn.prototype, {
				onlyShadow: {
					set: function() {
						console.warn("THREE.Light: .onlyShadow has been removed.")
					}
				},
				shadowCameraFov: {
					set: function(t) {
						console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
							this.shadow.camera.fov = t
					}
				},
				shadowCameraLeft: {
					set: function(t) {
						console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
							this.shadow.camera.left = t
					}
				},
				shadowCameraRight: {
					set: function(t) {
						console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
							this.shadow.camera.right = t
					}
				},
				shadowCameraTop: {
					set: function(t) {
						console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
							this.shadow.camera.top = t
					}
				},
				shadowCameraBottom: {
					set: function(t) {
						console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
							this.shadow.camera.bottom = t
					}
				},
				shadowCameraNear: {
					set: function(t) {
						console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
							this.shadow.camera.near = t
					}
				},
				shadowCameraFar: {
					set: function(t) {
						console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
							this.shadow.camera.far = t
					}
				},
				shadowCameraVisible: {
					set: function() {
						console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
					}
				},
				shadowBias: {
					set: function(t) {
						console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
							this.shadow.bias = t
					}
				},
				shadowDarkness: {
					set: function() {
						console.warn("THREE.Light: .shadowDarkness has been removed.")
					}
				},
				shadowMapWidth: {
					set: function(t) {
						console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
							this.shadow.mapSize.width = t
					}
				},
				shadowMapHeight: {
					set: function(t) {
						console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
							this.shadow.mapSize.height = t
					}
				}
			}),
			Object.defineProperties(ft.prototype, {
				length: {
					get: function() {
						return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
							this.array.length
					}
				}
			}),
			Object.assign(Xt.prototype, {
				addIndex: function(t) {
					console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
						this.setIndex(t)
				},
				addDrawCall: function(t, e, n) {
					void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
						console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
						this.addGroup(t, e)
				},
				clearDrawCalls: function() {
					console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
						this.clearGroups()
				},
				computeTangents: function() {
					console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
				},
				computeOffsets: function() {
					console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
				}
			}),
			Object.defineProperties(Xt.prototype, {
				drawcalls: {
					get: function() {
						return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
							this.groups
					}
				},
				offsets: {
					get: function() {
						return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
							this.groups
					}
				}
			}),
			Object.defineProperties(Yi.prototype, {
				dynamic: {
					set: function() {
						console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
					}
				},
				onUpdate: {
					value: function() {
						return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),
							this
					}
				}
			}),
			Object.defineProperties(Q.prototype, {
				wrapAround: {
					get: function() {
						console.warn("THREE.Material: .wrapAround has been removed.")
					},
					set: function() {
						console.warn("THREE.Material: .wrapAround has been removed.")
					}
				},
				wrapRGB: {
					get: function() {
						return console.warn("THREE.Material: .wrapRGB has been removed."),
							new W
					}
				}
			}),
			Object.defineProperties(Mn.prototype, {
				metal: {
					get: function() {
						return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
					},
					set: function() {
						console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
					}
				}
			}),
			Object.defineProperties(J.prototype, {
				derivatives: {
					get: function() {
						return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
							this.extensions.derivatives
					},
					set: function(t) {
						console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
							this.extensions.derivatives = t
					}
				}
			}),
			Object.assign(fe.prototype, {
				getCurrentRenderTarget: function() {
					return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
						this.getRenderTarget()
				},
				supportsFloatTextures: function() {
					return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
						this.extensions.get("OES_texture_float")
				},
				supportsHalfFloatTextures: function() {
					return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
						this.extensions.get("OES_texture_half_float")
				},
				supportsStandardDerivatives: function() {
					return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
						this.extensions.get("OES_standard_derivatives")
				},
				supportsCompressedTextureS3TC: function() {
					return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
						this.extensions.get("WEBGL_compressed_texture_s3tc")
				},
				supportsCompressedTexturePVRTC: function() {
					return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
						this.extensions.get("WEBGL_compressed_texture_pvrtc")
				},
				supportsBlendMinMax: function() {
					return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
						this.extensions.get("EXT_blend_minmax")
				},
				supportsVertexTextures: function() {
					return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
						this.capabilities.vertexTextures
				},
				supportsInstancedArrays: function() {
					return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
						this.extensions.get("ANGLE_instanced_arrays")
				},
				enableScissorTest: function(t) {
					console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
						this.setScissorTest(t)
				},
				initMaterial: function() {
					console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
				},
				addPrePlugin: function() {
					console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
				},
				addPostPlugin: function() {
					console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
				},
				updateShadowMap: function() {
					console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
				}
			}),
			Object.defineProperties(fe.prototype, {
				shadowMapEnabled: {
					get: function() {
						return this.shadowMap.enabled
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
							this.shadowMap.enabled = t
					}
				},
				shadowMapType: {
					get: function() {
						return this.shadowMap.type
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
							this.shadowMap.type = t
					}
				},
				shadowMapCullFace: {
					get: function() {
						return this.shadowMap.cullFace
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."),
							this.shadowMap.cullFace = t
					}
				}
			}),
			Object.defineProperties(rt.prototype, {
				cullFace: {
					get: function() {
						return this.renderReverseSided ? so : ao
					},
					set: function(t) {
						var e = t !== ao;
						console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + e + "."),
							this.renderReverseSided = e
					}
				}
			}),
			Object.defineProperties(o.prototype, {
				wrapS: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
							this.texture.wrapS
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
							this.texture.wrapS = t
					}
				},
				wrapT: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
							this.texture.wrapT
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
							this.texture.wrapT = t
					}
				},
				magFilter: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
							this.texture.magFilter
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
							this.texture.magFilter = t
					}
				},
				minFilter: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
							this.texture.minFilter
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
							this.texture.minFilter = t
					}
				},
				anisotropy: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
							this.texture.anisotropy
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
							this.texture.anisotropy = t
					}
				},
				offset: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
							this.texture.offset
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
							this.texture.offset = t
					}
				},
				repeat: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
							this.texture.repeat
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
							this.texture.repeat = t
					}
				},
				format: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
							this.texture.format
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
							this.texture.format = t
					}
				},
				type: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
							this.texture.type
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
							this.texture.type = t
					}
				},
				generateMipmaps: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
							this.texture.generateMipmaps
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
							this.texture.generateMipmaps = t
					}
				}
			}),
			zi.prototype.load = function(t) {
				console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
				var e = this,
					n = new Li;
				return n.load(t, function(t) {
						e.setBuffer(t)
					}),
					this
			},
			ki.prototype.getData = function() {
				return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
					this.getFrequencyData()
			};
		var uu = {
				merge: function(t, e, n) {
					console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
					var i;
					e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(),
							i = e.matrix,
							e = e.geometry),
						t.merge(e, i, n)
				},
				center: function(t) {
					return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),
						t.center()
				}
			},
			hu = {
				crossOrigin: void 0,
				loadTexture: function(t, e, n, i) {
					console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
					var r = new Dn;
					r.setCrossOrigin(this.crossOrigin);
					var o = r.load(t, n, void 0, i);
					return e && (o.mapping = e),
						o
				},
				loadTextureCube: function(t, e, n, i) {
					console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
					var r = new In;
					r.setCrossOrigin(this.crossOrigin);
					var o = r.load(t, n, void 0, i);
					return e && (o.mapping = e),
						o
				},
				loadCompressedTexture: function() {
					console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
				},
				loadCompressedTextureCube: function() {
					console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
				}
			};
		t.WebGLRenderTargetCube = a,
			t.WebGLRenderTarget = o,
			t.WebGLRenderer = fe,
			t.ShaderLib = Bc,
			t.UniformsLib = Os,
			t.UniformsUtils = Cs,
			t.ShaderChunk = Dc,
			t.FogExp2 = pe,
			t.Fog = me,
			t.Scene = ve,
			t.LensFlare = ge,
			t.Sprite = ye,
			t.LOD = be,
			t.SkinnedMesh = Te,
			t.Skeleton = xe,
			t.Bone = we,
			t.Mesh = At,
			t.LineSegments = Se,
			t.LineLoop = Xe,
			t.Line = Ee,
			t.Points = Pe,
			t.Group = Re,
			t.VideoTexture = Oe,
			t.DataTexture = u,
			t.CompressedTexture = Ce,
			t.CubeTexture = h,
			t.CanvasTexture = Le,
			t.DepthTexture = Ie,
			t.Texture = i,
			t.CompressedTextureLoader = On,
			t.DataTextureLoader = Cn,
			t.CubeTextureLoader = In,
			t.TextureLoader = Dn,
			t.ObjectLoader = ui,
			t.MaterialLoader = ai,
			t.BufferGeometryLoader = si,
			t.DefaultLoadingManager = Hc,
			t.LoadingManager = Pn,
			t.JSONLoader = ci,
			t.ImageLoader = Ln,
			t.FontLoader = Ci,
			t.FileLoader = Rn,
			t.Loader = li,
			t.Cache = Gc,
			t.AudioLoader = Li,
			t.SpotLightShadow = Nn,
			t.SpotLight = kn,
			t.PointLight = Un,
			t.RectAreaLight = Hn,
			t.HemisphereLight = Fn,
			t.DirectionalLightShadow = jn,
			t.DirectionalLight = Vn,
			t.AmbientLight = Gn,
			t.LightShadow = zn,
			t.Light = Bn,
			t.StereoCamera = Ii,
			t.PerspectiveCamera = It,
			t.OrthographicCamera = Dt,
			t.CubeCamera = Di,
			t.ArrayCamera = Bi,
			t.Camera = Lt,
			t.AudioListener = Fi,
			t.PositionalAudio = Ni,
			t.AudioContext = tu,
			t.AudioAnalyser = ki,
			t.Audio = zi,
			t.VectorKeyframeTrack = Jn,
			t.StringKeyframeTrack = ei,
			t.QuaternionKeyframeTrack = $n,
			t.NumberKeyframeTrack = ti,
			t.ColorKeyframeTrack = ii,
			t.BooleanKeyframeTrack = ni,
			t.PropertyMixer = Ui,
			t.PropertyBinding = Vi,
			t.KeyframeTrack = ri,
			t.AnimationUtils = Wc,
			t.AnimationObjectGroup = Gi,
			t.AnimationMixer = Wi,
			t.AnimationClip = oi,
			t.Uniform = Yi,
			t.InstancedBufferGeometry = qi,
			t.BufferGeometry = Xt,
			t.GeometryIdCount = Et,
			t.Geometry = St,
			t.InterleavedBufferAttribute = Zi,
			t.InstancedInterleavedBuffer = Ji,
			t.InterleavedBuffer = Qi,
			t.InstancedBufferAttribute = Ki,
			t.Face3 = ht,
			t.Object3D = lt,
			t.Raycaster = $i,
			t.Layers = st,
			t.EventDispatcher = e,
			t.Clock = nr,
			t.QuaternionLinearInterpolant = Kn,
			t.LinearInterpolant = qn,
			t.DiscreteInterpolant = Zn,
			t.CubicInterpolant = Yn,
			t.Interpolant = Wn,
			t.Triangle = ut,
			t.Math = xs,
			t.Spherical = ir,
			t.Cylindrical = rr,
			t.Plane = nt,
			t.Frustum = it,
			t.Sphere = tt,
			t.Ray = ot,
			t.Matrix4 = c,
			t.Matrix3 = et,
			t.Box3 = $,
			t.Box2 = Y,
			t.Line3 = ct,
			t.Euler = at,
			t.Vector4 = r,
			t.Vector3 = l,
			t.Vector2 = n,
			t.Quaternion = s,
			t.Color = W,
			t.MorphBlendMesh = or,
			t.ImmediateRenderObject = ar,
			t.VertexNormalsHelper = sr,
			t.SpotLightHelper = lr,
			t.SkeletonHelper = cr,
			t.PointLightHelper = ur,
			t.RectAreaLightHelper = hr,
			t.HemisphereLightHelper = dr,
			t.GridHelper = fr,
			t.PolarGridHelper = pr,
			t.FaceNormalsHelper = mr,
			t.DirectionalLightHelper = vr,
			t.CameraHelper = gr,
			t.BoxHelper = _r,
			t.ArrowHelper = yr,
			t.AxisHelper = br,
			t.CatmullRomCurve3 = wr,
			t.CubicBezierCurve3 = Tr,
			t.QuadraticBezierCurve3 = Mr,
			t.LineCurve3 = Er,
			t.ArcCurve = Sr,
			t.EllipseCurve = Mi,
			t.SplineCurve = Ei,
			t.CubicBezierCurve = Si,
			t.QuadraticBezierCurve = Xi,
			t.LineCurve = wi,
			t.Shape = Pi,
			t.Path = Ai,
			t.ShapePath = Ri,
			t.Font = Oi,
			t.CurvePath = Ti,
			t.Curve = xi,
			t.ShapeUtils = Uc,
			t.SceneUtils = su,
			t.WireframeGeometry = De,
			t.ParametricGeometry = Be,
			t.ParametricBufferGeometry = Fe,
			t.TetrahedronGeometry = ke,
			t.TetrahedronBufferGeometry = Ue,
			t.OctahedronGeometry = je,
			t.OctahedronBufferGeometry = Ve,
			t.IcosahedronGeometry = Ge,
			t.IcosahedronBufferGeometry = He,
			t.DodecahedronGeometry = We,
			t.DodecahedronBufferGeometry = Ye,
			t.PolyhedronGeometry = ze,
			t.PolyhedronBufferGeometry = Ne,
			t.TubeGeometry = qe,
			t.TubeBufferGeometry = Ze,
			t.TorusKnotGeometry = Qe,
			t.TorusKnotBufferGeometry = Je,
			t.TorusGeometry = Ke,
			t.TorusBufferGeometry = $e,
			t.TextGeometry = nn,
			t.TextBufferGeometry = rn,
			t.SphereGeometry = on,
			t.SphereBufferGeometry = an,
			t.RingGeometry = sn,
			t.RingBufferGeometry = ln,
			t.PlaneGeometry = Ot,
			t.PlaneBufferGeometry = Ct,
			t.LatheGeometry = cn,
			t.LatheBufferGeometry = un,
			t.ShapeGeometry = hn,
			t.ShapeBufferGeometry = dn,
			t.ExtrudeGeometry = tn,
			t.ExtrudeBufferGeometry = en,
			t.EdgesGeometry = fn,
			t.ConeGeometry = vn,
			t.ConeBufferGeometry = gn,
			t.CylinderGeometry = pn,
			t.CylinderBufferGeometry = mn,
			t.CircleGeometry = _n,
			t.CircleBufferGeometry = yn,
			t.BoxGeometry = Pt,
			t.BoxBufferGeometry = Rt,
			t.ShadowMaterial = bn,
			t.SpriteMaterial = _e,
			t.RawShaderMaterial = xn,
			t.ShaderMaterial = J,
			t.PointsMaterial = Ae,
			t.MeshPhysicalMaterial = Tn;
		t.MeshStandardMaterial = wn;
		t.MeshPhongMaterial = Mn,
			t.MeshToonMaterial = En,
			t.MeshNormalMaterial = Sn,
			t.MeshLambertMaterial = Xn,
			t.MeshDepthMaterial = K,
			t.MeshBasicMaterial = dt,
			t.LineDashedMaterial = An,
			t.LineBasicMaterial = Me,
			t.Material = Q,
			t.Float64BufferAttribute = wt,
			t.Float32BufferAttribute = xt,
			t.Uint32BufferAttribute = bt,
			t.Int32BufferAttribute = yt,
			t.Uint16BufferAttribute = _t,
			t.Int16BufferAttribute = gt,
			t.Uint8ClampedBufferAttribute = vt,
			t.Uint8BufferAttribute = mt,
			t.Int8BufferAttribute = pt,
			t.BufferAttribute = ft,
			t.REVISION = io,
			t.MOUSE = ro,
			t.CullFaceNone = oo,
			t.CullFaceBack = ao,
			t.CullFaceFront = so,
			t.CullFaceFrontBack = lo,
			t.FrontFaceDirectionCW = co,
			t.FrontFaceDirectionCCW = uo,
			t.BasicShadowMap = ho,
			t.PCFShadowMap = fo,
			t.PCFSoftShadowMap = po,
			t.FrontSide = mo,
			t.BackSide = vo,
			t.DoubleSide = go,
			t.FlatShading = _o,
			t.SmoothShading = yo,
			t.NoColors = bo,
			t.FaceColors = xo,
			t.VertexColors = wo,
			t.NoBlending = To,
			t.NormalBlending = Mo,
			t.AdditiveBlending = Eo,
			t.SubtractiveBlending = So,
			t.MultiplyBlending = Xo,
			t.CustomBlending = Ao,
			t.AddEquation = Po,
			t.SubtractEquation = Ro,
			t.ReverseSubtractEquation = Oo,
			t.MinEquation = Co,
			t.MaxEquation = Lo,
			t.ZeroFactor = Io,
			t.OneFactor = Do,
			t.SrcColorFactor = Bo,
			t.OneMinusSrcColorFactor = Fo,
			t.SrcAlphaFactor = zo,
			t.OneMinusSrcAlphaFactor = No,
			t.DstAlphaFactor = ko,
			t.OneMinusDstAlphaFactor = Uo,
			t.DstColorFactor = jo,
			t.OneMinusDstColorFactor = Vo,
			t.SrcAlphaSaturateFactor = Go,
			t.NeverDepth = Ho,
			t.AlwaysDepth = Wo,
			t.LessDepth = Yo,
			t.LessEqualDepth = qo,
			t.EqualDepth = Zo,
			t.GreaterEqualDepth = Qo,
			t.GreaterDepth = Jo,
			t.NotEqualDepth = Ko,
			t.MultiplyOperation = $o,
			t.MixOperation = ta,
			t.AddOperation = ea,
			t.NoToneMapping = na,
			t.LinearToneMapping = ia,
			t.ReinhardToneMapping = ra,
			t.Uncharted2ToneMapping = oa,
			t.CineonToneMapping = aa,
			t.UVMapping = sa,
			t.CubeReflectionMapping = la,
			t.CubeRefractionMapping = ca,
			t.EquirectangularReflectionMapping = ua,
			t.EquirectangularRefractionMapping = ha,
			t.SphericalReflectionMapping = da,
			t.CubeUVReflectionMapping = fa,
			t.CubeUVRefractionMapping = pa,
			t.RepeatWrapping = ma,
			t.ClampToEdgeWrapping = va,
			t.MirroredRepeatWrapping = ga,
			t.NearestFilter = _a,
			t.NearestMipMapNearestFilter = ya,
			t.NearestMipMapLinearFilter = ba,
			t.LinearFilter = xa,
			t.LinearMipMapNearestFilter = wa,
			t.LinearMipMapLinearFilter = Ta,
			t.UnsignedByteType = Ma,
			t.ByteType = Ea,
			t.ShortType = Sa,
			t.UnsignedShortType = Xa,
			t.IntType = Aa,
			t.UnsignedIntType = Pa,
			t.FloatType = Ra,
			t.HalfFloatType = Oa,
			t.UnsignedShort4444Type = Ca,
			t.UnsignedShort5551Type = La,
			t.UnsignedShort565Type = Ia,
			t.UnsignedInt248Type = Da,
			t.AlphaFormat = Ba,
			t.RGBFormat = Fa,
			t.RGBAFormat = za,
			t.LuminanceFormat = Na,
			t.LuminanceAlphaFormat = ka,
			t.RGBEFormat = Ua,
			t.DepthFormat = ja,
			t.DepthStencilFormat = Va,
			t.RGB_S3TC_DXT1_Format = Ga,
			t.RGBA_S3TC_DXT1_Format = Ha,
			t.RGBA_S3TC_DXT3_Format = Wa,
			t.RGBA_S3TC_DXT5_Format = Ya,
			t.RGB_PVRTC_4BPPV1_Format = qa,
			t.RGB_PVRTC_2BPPV1_Format = Za,
			t.RGBA_PVRTC_4BPPV1_Format = Qa,
			t.RGBA_PVRTC_2BPPV1_Format = Ja,
			t.RGB_ETC1_Format = Ka,
			t.LoopOnce = $a,
			t.LoopRepeat = ts,
			t.LoopPingPong = es,
			t.InterpolateDiscrete = ns,
			t.InterpolateLinear = is,
			t.InterpolateSmooth = rs,
			t.ZeroCurvatureEnding = os,
			t.ZeroSlopeEnding = as,
			t.WrapAroundEnding = ss,
			t.TrianglesDrawMode = ls,
			t.TriangleStripDrawMode = cs,
			t.TriangleFanDrawMode = us,
			t.LinearEncoding = hs,
			t.sRGBEncoding = ds,
			t.GammaEncoding = fs,
			t.RGBEEncoding = ps,
			t.LogLuvEncoding = ms,
			t.RGBM7Encoding = vs,
			t.RGBM16Encoding = gs,
			t.RGBDEncoding = _s,
			t.BasicDepthPacking = ys,
			t.RGBADepthPacking = bs,
			t.CubeGeometry = Pt,
			t.Face4 = Xr,
			t.LineStrip = lu,
			t.LinePieces = cu,
			t.MeshFaceMaterial = Ar,
			t.MultiMaterial = Pr,
			t.PointCloud = Rr,
			t.Particle = Or,
			t.ParticleSystem = Cr,
			t.PointCloudMaterial = Lr,
			t.ParticleBasicMaterial = Ir,
			t.ParticleSystemMaterial = Dr,
			t.Vertex = Br,
			t.DynamicBufferAttribute = Fr,
			t.Int8Attribute = zr,
			t.Uint8Attribute = Nr,
			t.Uint8ClampedAttribute = kr,
			t.Int16Attribute = Ur,
			t.Uint16Attribute = jr,
			t.Int32Attribute = Vr,
			t.Uint32Attribute = Gr,
			t.Float32Attribute = Hr,
			t.Float64Attribute = Wr,
			t.ClosedSplineCurve3 = Yr,
			t.SplineCurve3 = qr,
			t.Spline = Zr,
			t.BoundingBoxHelper = Qr,
			t.EdgesHelper = Jr,
			t.WireframeHelper = Kr,
			t.XHRLoader = $r,
			t.BinaryTextureLoader = to,
			t.GeometryUtils = uu,
			t.ImageUtils = hu,
			t.Projector = eo,
			t.CanvasRenderer = no,
			Object.defineProperty(t, "__esModule", {
				value: !0
			})
	})
}, function(t, e) {
	"use strict";
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var n = !!(location.search.indexOf("dev") > -1);
	e.default = {
		MODEL_SCLAE: .15,
		MOVE_SPEED: 4,
		CHANGE_SPEED_X: 20,
		CHANGE_SPEED_Y: 100,
		X_LIMIT: 500,
		Y_LIMIT: 2e3,
		SCREEN_WIDTH: n ? 375 : window.innerWidth,
		SCREEN_HEIGHT: n ? 667 : window.innerHeight,
		FOG_COLOR: 12956044,
		FLOOR_WIDTH: 7e3,
		FLOOR_DEPTH: 16e3,
		MOVE_STEP: 500,
		FLOOR_SEGMENTS: 20,
		FLOOR_YPOS: -500,
		FLOOR_THICKNESS: 300,
		SCENE_HEIGHT: 5e3,
		CAMERA_X: 0,
		CAMERA_Y: 1e3,
		CAMERA_Z: 5200,
		CAR_WIDTH: 3e3,
		CAR_HEIGHT: 1e4,
		CAR_COUNT: 0,
		AVATAR_X: 0,
		AVATAR_Y: 1e3,
		AVATAR_Z: 4150,
		BUILDING_COUNT: 8,
		BUILDING_DEPTH: 16e3,
		ENTER_DISTRICT: "onEnterDistrict",
		LEAVE_DISTRICT: "onLeaveDistrict",
		MEET_END: "onMeetEnd",
		TRY_OVERLOOK: "onTryToOverLook",
		TICKET_CLICK: "onTicketClick",
		SHARE_CLICK: "onShareClick",
		REPLAY_CLICK: "onReplayClick",
		WINDOW_RESIZE: "onWindowResize",
		BLACK_HOLE_WIDTH: 1e3,
		BLACK_HOLE_HEIGHT: 1e3,
		BLACK_HOLE_DEPTH: 1e3,
		ENTRY_RADIUS: 1e3,
		ENTRY_DISTANCE: 2e4,
		END_POSITION: -1e5
	}
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var o = n(12),
		a = r(o),
		s = n(10),
		l = i(s),
		c = n(13),
		u = (r(c), {
			buildingZ: -200,
			buildingX: -200
		}),
		h = {
			isAudioPlay: !0,
			status: 0,
			isDev: window.location.href.indexOf("?dev") > -1,
			isWeixin: a.thirdapp && "Weixin" === a.thirdapp.appname,
			isIOS: a.os.isIOS,
			isAndroid: a.os.isAndroid,
			osVersion: a.os.version,
			isTaobao: a.aliapp && "TB" === a.aliapp.appname,
			ended: !1,
			exploreCount: 0,
			entryCount: 0,
			lookingAround: !1,
			avatarPositionX: l.default.AVATAR_X,
			avatarPositionY: l.default.AVATAR_Y,
			expectedControlX: 0,
			expectedControlY: 0,
			orientationControlling: !0,
			moveSpeed: 0,
			acceleration: 0,
			buildingMap: {
				buildingA: [0, 13, 19],
				buildingB: [1, 15, 17, 20],
				buildingC: [2, 3],
				buildingD: [4, 16],
				buildingF: [5, 14, 23],
				buildingH: [6, 7, 12, 21],
				buildingJ: [8, 9, 10, 18, 22],
				buildingNY3: [11]
			},
			buildings: 
				[{
					name: "buildingA",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: 1200 + u.buildingX * Math.random(),y: 0,z: -4313 + u.buildingZ}
				}, {
					name: "buildingB",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: 1200 + u.buildingX * Math.random(),y: 0,z: -8423 + u.buildingZ}
				}, {
					name: "buildingC",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: 1200 + u.buildingX * Math.random(),y: 0,z: -1353 + u.buildingZ}
				}, {
					name: "buildingC",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: 1200 + u.buildingX * Math.random(),y: 0,z: -9903 + u.buildingZ}
				}, {
					name: "buildingD",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: 1200 + u.buildingX * Math.random(),y: 0,z: 456 + u.buildingZ}
				}, {
					name: "buildingF",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: 1200 + u.buildingX * Math.random(),y: 0,z: -2833 + u.buildingZ}
				}, {
					name: "buildingH",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: 1200 + u.buildingX * Math.random(),y: 0,z: 2593 + u.buildingZ}
				}, {
					name: "buildingH",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: 1200 + u.buildingX * Math.random(),y: 0,z: -6121 + u.buildingZ}
				}, {
					name: "buildingJ",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: 1200 + u.buildingX * Math.random(),y: 0,z: -12054 + u.buildingZ}
				}, {
					name: "buildingJ",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: 1200 + u.buildingX * Math.random(),y: 0,z: -7437 + u.buildingZ}
				}, {
					name: "buildingJ",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: 1200 + u.buildingX * Math.random(),y: 0,z: -11054 + u.buildingZ}
				}, {
					name: "buildingNY3",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: 1200 + u.buildingX * Math.random(),y: 0,z: 1607 + u.buildingZ}
				}, {
					name: "buildingH",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: -1200+ u.buildingX * Math.random(),y: 0,z: -10836 + u.buildingZ}
				}, {
					name: "buildingA",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: -1200+ u.buildingX * Math.random(),y: 0,z: -8725 + u.buildingZ}
				}, {
					name: "buildingF",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: -1200+ u.buildingX * Math.random(),y: 0,z: -7410 + u.buildingZ}
				}, {
					name: "buildingB",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: -1200+ u.buildingX * Math.random(),y: 0,z: -6752 + u.buildingZ}
				}, {
					name: "buildingD",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: -1200+ u.buildingX * Math.random(),y: 0,z: -5437 + u.buildingZ}
				}, {
					name: "buildingB",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: -1200+ u.buildingX * Math.random(),y: 0,z: -3957 + u.buildingZ}
				}, {
					name: "buildingJ",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: -1200+ u.buildingX * Math.random(),y: 0,z: -3135 + u.buildingZ}
				}, {
					name: "buildingA",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: -1200+ u.buildingX * Math.random(),y: 0,z: -1819 + u.buildingZ}
				}, {
					name: "buildingB",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: -1200+ u.buildingX * Math.random(),y: 0,z: -504 + u.buildingZ}
				}, {
					name: "buildingH",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: -1200+ u.buildingX * Math.random(),y: 0,z: 812 + u.buildingZ}
				}, {
					name: "buildingJ",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: -1200+ u.buildingX * Math.random(),y: 0,z: 2009 + u.buildingZ}
				}, {
					name: "buildingF",
					rotation: {x: 0,y: 0,z: 0},
					scale: {x: .15,y: .15,z: .15},
					position: {x: -1200+ u.buildingX * Math.random(),y: 0,z: 2949 + u.buildingZ}
				},
				],
			lightHelper: !1,
			lights: [{
				color: 14349553,
				intensity: 2.5,
				distance: 13680,
				angle: 1.1,
				penumbra: 0,
				decay: 0,
				position: {
					x: 0,
					y: 14632,
					z: 4864
				}
			}, {
				color: 14349553,
				intensity: 3.1,
				distance: 13680,
				angle: 1.1,
				penumbra: 0,
				decay: 0,
				position: {
					x: 0,
					y: -14632,
					z: 3300
				}
			}],
			leftRx: 0,
			leftRy: 0,
			leftRz: 0,
			rightRx: 0,
			rightRy: 0,
			rightRz: 0,
			billboard: {
				glowColor: 16777215
			},
			billboards: [
			/*
			{
				type: "billboard1",
				position: [0, 0, 0],
				rotation: [0, 0, 0],
				shininess: .1,
				scale: 1
			}
			billboards: [{
            type: "billboard1",
            position: [-1946, 1871, 406],
            rotation: [0, Math.PI / 2, 0],
            shininess: .1,
            scale: .7
        	}, {
				type: "billboard2",
				position: [-2175, -531, -1846],
				rotation: [0, Math.PI / 2, 0],
				shininess: .1,
				scale: .9
			}, {
				type: "billboard3",
				position: [1771, 2100, -6256],
				rotation: [0, -Math.PI / 2, 0],
				shininess: .1,
				scale: .7
			}, {
				type: "billboard4",
				position: [-2001, -890, -4641],
				rotation: [0, Math.PI / 2, 0],
				shininess: .1,
				scale: .9
			}, {
				type: "billboard5",
				position: [-1692, 0, -8089],
				rotation: [0, Math.PI / 2, 0],
				shininess: .1,
				scale: 1
			}, {
				type: "billboard6",
				position: [2100, -152, -4313],
				rotation: [0, -Math.PI / 2, 0],
				shininess: .1,
				scale: .6
			}, {
				type: "billboard7",
				position: [-1782, -860, -10860],
				rotation: [0, Math.PI / 2, 0],
				shininess: .1,
				scale: .8
			}, {
				type: "billboard8",
				position: [1906, 1667, 620],
				rotation: [0, -Math.PI / 2, 0],
				shininess: .1,
				scale: .6
			}, {
				type: "billboard9",
				position: [1880, -38, -1353],
				rotation: [0, -Math.PI / 2, 0],
				shininess: .1,
				scale: .7
			}, {
				type: "billboard10",
				position: [1786, -6, -9574],
				rotation: [0, -Math.PI / 2, 0],
				shininess: .1,
				scale: 1
			}*/],
			lanterns: [/*{
				position: [0, -2e3 - 2e3 * Math.random(), 0],
				rotation: [0, 0, 0]
			}, {
				position: [0, -2e3 - 2e3 * Math.random(), -2e3],
				rotation: [0, -Math.PI / 6, 0]
			}, {
				position: [0, -2e3 - 2e3 * Math.random(), -4e3],
				rotation: [0, -Math.PI / 3, 0]
			}, {
				position: [0, -2e3 - 2e3 * Math.random(), -8e3],
				rotation: [0, -Math.PI / 6, 0]
			}, {
				position: [0, -2e3 - 2e3 * Math.random(), -12e3],
				rotation: [0, 0, 0]
			}, {
				position: [0, -2e3 - 2e3 * Math.random(), -15e3],
				rotation: [0, -Math.PI / 5, 0]
			}*/]
		};
	h.isTaobao,
		e.default = h
}, function(t, e) {
	"undefined" == typeof window && (window = {
			ctrl: {},
			lib: {}
		}), !window.ctrl && (window.ctrl = {}), !window.lib && (window.lib = {}), ! function(t, e) {
			function n(t) {
				Object.defineProperty(this, "val", {
						value: t.toString(),
						enumerable: !0
					}),
					this.gt = function(t) {
						return n.compare(this, t) > 0
					},
					this.gte = function(t) {
						return n.compare(this, t) >= 0
					},
					this.lt = function(t) {
						return n.compare(this, t) < 0
					},
					this.lte = function(t) {
						return n.compare(this, t) <= 0
					},
					this.eq = function(t) {
						return 0 === n.compare(this, t)
					}
			}
			e.env = e.env || {},
				n.prototype.toString = function() {
					return this.val
				},
				n.prototype.valueOf = function() {
					for(var t = this.val.split("."), e = [], n = 0; n < t.length; n++) {
						var i = parseInt(t[n], 10);
						isNaN(i) && (i = 0);
						var r = i.toString();
						r.length < 5 && (r = Array(6 - r.length).join("0") + r),
							e.push(r),
							1 === e.length && e.push(".")
					}
					return parseFloat(e.join(""))
				},
				n.compare = function(t, e) {
					t = t.toString().split("."),
						e = e.toString().split(".");
					for(var n = 0; n < t.length || n < e.length; n++) {
						var i = parseInt(t[n], 10),
							r = parseInt(e[n], 10);
						if(window.isNaN(i) && (i = 0),
							window.isNaN(r) && (r = 0),
							r > i)
							return -1;
						if(i > r)
							return 1
					}
					return 0
				},
				e.version = function(t) {
					return new n(t)
				}
		}(window, window.lib || (window.lib = {})),
		function(t, e) {
			e.env = e.env || {};
			var n = t.location.search.replace(/^\?/, "");
			if(e.env.params = {},
				n)
				for(var i = n.split("&"), r = 0; r < i.length; r++) {
					i[r] = i[r].split("=");
					try {
						e.env.params[i[r][0]] = decodeURIComponent(i[r][1])
					} catch(t) {
						e.env.params[i[r][0]] = i[r][1]
					}
				}
		}(window, window.lib || (window.lib = {})),
		function(t, e) {
			e.env = e.env || {};
			var n, i = t.navigator.userAgent;
			if(n = i.match(/Windows\sPhone\s(?:OS\s)?([\d\.]+)/))
				e.env.os = {
					name: "Windows Phone",
					isWindowsPhone: !0,
					version: n[1]
				};
			else if(i.match(/Safari/) && (n = i.match(/Android[\s\/]([\d\.]+)/)))
				e.env.os = {
					version: n[1]
				},
				i.match(/Mobile\s+Safari/) ? (e.env.os.name = "Android",
					e.env.os.isAndroid = !0) : (e.env.os.name = "AndroidPad",
					e.env.os.isAndroidPad = !0);
			else if(n = i.match(/(iPhone|iPad|iPod)/)) {
				var r = n[1];
				(n = i.match(/OS ([\d_\.]+) like Mac OS X/)) && (e.env.os = {
					name: r,
					isIPhone: "iPhone" === r || "iPod" === r,
					isIPad: "iPad" === r,
					isIOS: !0,
					version: n[1].split("_").join(".")
				})
			}
			e.env.os || (e.env.os = {
					name: "unknown",
					version: "0.0.0"
				}),
				e.version && (e.env.os.version = e.version(e.env.os.version))
		}(window, window.lib || (window.lib = {})),
		function(t, e) {
			e.env = e.env || {};
			var n, i = t.navigator.userAgent;
			(n = i.match(/(?:UCWEB|UCBrowser\/)([\d\.]+)/)) ? e.env.browser = {
					name: "UC",
					isUC: !0,
					version: n[1]
				}: (n = i.match(/MQQBrowser\/([\d\.]+)/)) ? e.env.browser = {
					name: "QQ",
					isQQ: !0,
					version: n[1]
				} : (n = i.match(/(?:Firefox|FxiOS)\/([\d\.]+)/)) ? e.env.browser = {
					name: "Firefox",
					isFirefox: !0,
					version: n[1]
				} : (n = i.match(/MSIE\s([\d\.]+)/)) || (n = i.match(/IEMobile\/([\d\.]+)/)) ? (e.env.browser = {
						version: n[1]
					},
					i.match(/IEMobile/) ? (e.env.browser.name = "IEMobile",
						e.env.browser.isIEMobile = !0) : (e.env.browser.name = "IE",
						e.env.browser.isIE = !0),
					i.match(/Android|iPhone/) && (e.env.browser.isIELikeWebkit = !0)) : (n = i.match(/(?:Chrome|CriOS)\/([\d\.]+)/)) ? (e.env.browser = {
						name: "Chrome",
						isChrome: !0,
						version: n[1]
					},
					i.match(/Version\/[\d+\.]+\s*Chrome/) && (e.env.browser.name = "Chrome Webview",
						e.env.browser.isWebview = !0)) : i.match(/Safari/) && (n = i.match(/Android[\s\/]([\d\.]+)/)) ? e.env.browser = {
					name: "Android",
					isAndroid: !0,
					version: n[1]
				} : i.match(/iPhone|iPad|iPod/) && (i.match(/Safari/) && (n = i.match(/Version\/([\d\.]+)/)) ? e.env.browser = {
					name: "Safari",
					isSafari: !0,
					version: n[1]
				} : (n = i.match(/OS ([\d_\.]+) like Mac OS X/)) && (e.env.browser = {
					name: "iOS Webview",
					isWebview: !0,
					version: n[1].replace(/\_/g, ".")
				})),
				e.env.browser || (e.env.browser = {
					name: "unknown",
					version: "0.0.0"
				}),
				e.version && (e.env.browser.version = e.version(e.env.browser.version))
		}(window, window.lib || (window.lib = {})),
		function(t, e) {
			e.env = e.env || {};
			var n = t.navigator.userAgent;
			n.match(/Weibo/i) ? e.env.thirdapp = {
				appname: "Weibo",
				isWeibo: !0
			} : n.match(/MicroMessenger/i) ? e.env.thirdapp = {
				appname: "Weixin",
				isWeixin: !0
			} : e.env.thirdapp = !1
		}(window, window.lib || (window.lib = {})),
		function(t, e) {
			e.env = e.env || {};
			var n, i, r = t.navigator.userAgent;
			(i = r.match(/WindVane[\/\s]([\d\.\_]+)/)) && (n = i[1]);
			var o = !1,
				a = "",
				s = "",
				l = "",
				c = t._ua_popLayer || "",
				u = !1,
				h = "";
			(i = r.match(/AliApp\(([A-Z\-]+)\/([\d\.]+)\)/i)) && (o = !0,
				a = i[1],
				l = i[2],
				s = a.indexOf("-PD") > 0 ? e.env.os.isIOS ? "iPad" : e.env.os.isAndroid ? "AndroidPad" : e.env.os.name : e.env.os.name), !a && r.indexOf("TBIOS") > 0 && (a = "TB"),
				c && (i = c.match(/PopLayer\/([\d\.]+)/i)) && (u = !0,
					h = i[1]),
				o ? e.env.aliapp = {
					windvane: e.version(n || "0.0.0"),
					appname: a || "unkown",
					version: e.version(l || "0.0.0"),
					platform: s || e.env.os.name,
					poplayer: u || !1,
					poplayerVersion: e.version(h || "0.0.0")
				} : e.env.aliapp = !1,
				e.env.taobaoApp = e.env.aliapp
		}(window, window.lib || (window.lib = {})),
		t.exports = window.lib.env
}, function(t, e) {
	"undefined" == typeof window && (window = {
			ctrl: {},
			lib: {}
		}), !window.ctrl && (window.ctrl = {}), !window.lib && (window.lib = {}), ! function(t, e) {
			function n(t, e) {
				t = t.toString().split("."),
					e = e.toString().split(".");
				for(var n = 0; n < t.length || n < e.length; n++) {
					var i = parseInt(t[n], 10),
						r = parseInt(e[n], 10);
					if(window.isNaN(i) && (i = 0),
						window.isNaN(r) && (r = 0),
						i < r)
						return -1;
					if(i > r)
						return 1
				}
				return 0
			}
			var i = t.Promise,
				r = t.document,
				o = t.navigator.userAgent,
				a = /Windows\sPhone\s(?:OS\s)?[\d\.]+/i.test(o) || /Windows\sNT\s[\d\.]+/i.test(o),
				s = a && t.WindVane_Win_Private && t.WindVane_Win_Private.call,
				l = /iPhone|iPad|iPod/i.test(o),
				c = /Android/i.test(o),
				u = o.match(/WindVane[\/\s](\d+[._]\d+[._]\d+)/),
				h = Object.prototype.hasOwnProperty,
				d = e.windvane = t.WindVane || (t.WindVane = {}),
				f = (t.WindVane_Native,
					Math.floor(65536 * Math.random())),
				p = 1,
				m = [],
				v = 3,
				g = "hybrid",
				_ = "wv_hybrid",
				y = "iframe_",
				b = "param_",
				x = "chunk_",
				w = 6e5,
				T = 6e5,
				M = 6e4;
			u = u ? (u[1] || "0.0.0").replace(/\_/g, ".") : "0.0.0";
			var E = {
					isAvailable: 1 === n(u, "0"),
					call: function(t, e, n, r, o, a) {
						var s, l;
						"number" == typeof arguments[arguments.length - 1] && (a = arguments[arguments.length - 1]),
							"function" != typeof r && (r = null),
							"function" != typeof o && (o = null),
							i && (l = {},
								l.promise = new i(function(t, e) {
									l.resolve = t,
										l.reject = e
								})),
							s = S.getSid();
						var c = {
							success: r,
							failure: o,
							deferred: l
						};
						if(a > 0 && (c.timeout = setTimeout(function() {
								E.onFailure(s, {
									ret: "HY_TIMEOUT"
								})
							}, a)),
							S.registerCall(s, c),
							S.registerGC(s, a),
							E.isAvailable ? S.callMethod(t, e, n, s) : E.onFailure(s, {
								ret: "HY_NOT_IN_WINDVANE"
							}),
							l)
							return l.promise
					},
					fireEvent: function(t, e, n) {
						var i = r.createEvent("HTMLEvents");
						i.initEvent(t, !1, !0),
							i.param = S.parseData(e || S.getData(n)),
							r.dispatchEvent(i)
					},
					getParam: function(t) {
						return S.getParam(t)
					},
					setData: function(t, e) {
						S.setData(t, e)
					},
					onSuccess: function(t, e) {
						S.onComplete(t, e, "success")
					},
					onFailure: function(t, e) {
						S.onComplete(t, e, "failure")
					}
				},
				S = {
					params: {},
					chunks: {},
					calls: {},
					getSid: function() {
						return(f + p++) % 65536 + ""
					},
					buildParam: function(t) {
						return t && "object" == typeof t ? JSON.stringify(t) : t || ""
					},
					getParam: function(t) {
						return this.params[b + t] || ""
					},
					setParam: function(t, e) {
						this.params[b + t] = e
					},
					parseData: function(t) {
						var e;
						if(t && "string" == typeof t)
							try {
								e = JSON.parse(t)
							} catch(t) {
								e = {
									ret: ["WV_ERR::PARAM_PARSE_ERROR"]
								}
							}
						else
							e = t || {};
						return e
					},
					setData: function() {
						this.chunks[x + sid] = this.chunks[x + sid] || [],
							this.chunks[x + sid].push(chunk)
					},
					getData: function(t) {
						return this.chunks[x + t] ? this.chunks[x + t].join("") : ""
					},
					registerCall: function(t, e) {
						this.calls[t] = e
					},
					unregisterCall: function(t) {
						var e = {};
						return this.calls[t] && (e = this.calls[t],
								delete this.calls[t]),
							e
					},
					useIframe: function(t, e) {
						var n = y + t,
							i = m.pop();
						i || (i = r.createElement("iframe"),
								i.setAttribute("frameborder", "0"),
								i.style.cssText = "width:0;height:0;border:0;display:none;"),
							i.setAttribute("id", n),
							i.setAttribute("src", e),
							i.parentNode || setTimeout(function() {
								r.body.appendChild(i)
							}, 5)
					},
					retrieveIframe: function(t) {
						var e = y + t,
							n = r.querySelector("#" + e);
						m.length >= v ? r.body.removeChild(n) : m.indexOf(n) < 0 && m.push(n)
					},
					callMethod: function(e, n, i, r) {
						if(i = S.buildParam(i),
							a)
							s ? t.WindVane_Win_Private.call(e, n, r, i) : this.onComplete(r, {
								ret: "HY_NO_HANDLER_ON_WP"
							}, "failure");
						else {
							var o = g + "://" + e + ":" + r + "/" + n + "?" + i;
							if(l)
								this.setParam(r, i),
								this.useIframe(r, o);
							else if(c) {
								var u = _ + ":";
								window.prompt(o, u)
							} else
								this.onComplete(r, {
									ret: "HY_NOT_SUPPORT_DEVICE"
								}, "failure")
						}
					},
					registerGC: function(t, e) {
						var n = this,
							i = Math.max(e || 0, w),
							r = Math.max(e || 0, M),
							o = Math.max(e || 0, T);
						setTimeout(function() {
								n.unregisterCall(t)
							}, i),
							l ? setTimeout(function() {
								n.params[b + t] && delete n.params[b + t]
							}, r) : c && setTimeout(function() {
								n.chunks[x + t] && delete n.chunks[x + t]
							}, o)
					},
					onComplete: function(t, e, n) {
						var i = this.unregisterCall(t),
							r = i.success,
							o = i.failure,
							a = i.deferred,
							s = i.timeout;
						s && clearTimeout(s),
							e = e ? e : this.getData(t),
							e = this.parseData(e);
						var u = e.ret;
						"string" == typeof u && (e = e.value || e,
								e.ret || (e.ret = [u])),
							"success" === n ? (r && r(e),
								a && a.resolve(e)) : "failure" === n && (o && o(e),
								a && a.reject(e)),
							l ? (this.retrieveIframe(t),
								this.params[b + t] && delete this.params[b + t]) : c && this.chunks[x + t] && delete this.chunks[x + t]
					}
				};
			for(var X in E)
				h.call(d, X) || (d[X] = E[X])
		}(window, window.lib || (window.lib = {})),
		t.exports = window.lib.windvane
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function o() {
		return new Promise(function(t) {
			var e = new s.LoadingManager;
			e.onStart = function(t, e, n) {},
				e.onLoad = function() {
					t()
				},
				e.onProgress = function(t, e, n) {
					h.default.update(e / n * 100 >> 0)
				},
				e.onError = function(t) {};
			var n = {
					texture: s.TextureLoader,
					model: s.OBJLoader,
					mtl: s.MTLLoader
				},
				i = function(t) {
					var i = function(i) {
						if("model" === t && _.mtl[i])
							return "continue";
						var r = new n[t](e);
						r.setCrossOrigin && r.setCrossOrigin("anonymous");
						var o = void 0;
						"mtl" === t && (o = new n.model(e)),
							r.load(_[t][i], function(e) {
								y[t][i] = e,
									"mtl" === t && (o.setMaterials(e),
										o.load(_.model[i], function(e) {
											y.model[i] = e,
												f.default.buildingMap[i] && (f.default.buildingMap[i].forEach(function(t) {
														c.default.add(f.default.buildings[t])
													}),
													y[t][i] = null)
										}))
							})
					};
					for(var r in _[t]) {
						i(r)
					}
				};
			for(var r in n)
				i(r)
		})
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var a = n(9),
		s = r(a);
	n(15),
		n(16);
	var l = n(17),
		c = i(l),
		u = n(22),
		h = i(u),
		d = n(11),
		f = i(d),
		p = n(24),
		m = i(p),
		v = n(25),
		g = i(v),
		_ = {
			model: {
				buildingA: g.default.model["BuildingAa-low.obj"],
				buildingB: g.default.model["BuildingBa-low.obj"],
				buildingC: g.default.model["BuildingCa-low.obj"],
				buildingD: g.default.model["BuildingDa-low.obj"],
				buildingF: g.default.model["BuildingF-low.obj"],
				buildingH: g.default.model["BuildingHa-low.obj"],
				buildingJ: g.default.model["BuildingJ-low.obj"],
				buildingNY3: g.default.model["NY3-low.obj"],
				end: g.default.model["pyramid3.obj"],
				carp: g.default.model["CarpFinal.obj"],
				car: g.default.model["car.obj"],
				leftWing: g.default.model["left_kite.obj"],
				rightWing: g.default.model["right_kite.obj"],
				lantern: g.default.model["Lanterns.obj"]
			},
			audio: {
				rouet: m.default.music
			},
			mtl: {
				buildingA: g.default.mtl["BuildingAa-low.mtl"],
				buildingB: g.default.mtl["BuildingBa-low.mtl"],
				buildingC: g.default.mtl["BuildingCa-low.mtl"],
				buildingD: g.default.mtl["BuildingDa-low.mtl"],
				buildingF: g.default.mtl["BuildingF-low.mtl"],
				buildingH: g.default.mtl["BuildingHa-low.mtl"],
				buildingJ: g.default.mtl["BuildingJ-low.mtl"],
				buildingNY3: g.default.mtl["NY3-low.mtl"],
				end: g.default.mtl["pyramid3.mtl"],
				carp: g.default.mtl["CarpFinal.mtl"],
				car: g.default.mtl["dlochhea_lighting_centralStreetExports_v018_car_45.mtl"],
				leftWing: g.default.mtl["left_kite.mtl"],
				rightWing: g.default.mtl["right_kite.mtl"],
				lantern: g.default.mtl["Lanterns.mtl"]
			},
			texture: {
				logo: g.default.textures["entry.png"],
				blackhole: g.default.textures["blackhole.jpg"],
				billboard1: g.default.textures["billboard1.png"],
				billboard2: g.default.textures["billboard2.png"],
				billboard3: g.default.textures["billboard3.png"],
				billboard4: g.default.textures["billboard4.png"],
				billboard5: g.default.textures["billboard5.png"],
				billboard6: g.default.textures["billboard6.png"],
				billboard7: g.default.textures["billboard7.png"],
				billboard8: g.default.textures["billboard8.png"],
				billboard9: g.default.textures["billboard9.png"],
				billboard10: g.default.textures["billboard10.png"],
				fog: g.default.textures["fog.png"],
				sky: "./img/TB1Eg.RRVXXXXc9XVXXXXXXXXXX-1024-1024.jpg",
				sky2: "./img/TB1yM4lSXXXXXatXpXXXXXXXXXX-1024-1024.png"
			}
		},
		y = {
			texture: {},
			audio: {},
			model: {},
			mtl: {}
		};
	e.default = {
		init: o,
		urls: _,
		resources: y	
	}
}, function(t, e, n) {
	"use strict";

	function i(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var r = n(9),
		o = i(r);
	o.OBJLoader = function(t) {
			this.manager = void 0 !== t ? t : o.DefaultLoadingManager,
				this.materials = null,
				this.regexp = {
					vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
					normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
					uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
					face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
					face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
					face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
					face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
					object_pattern: /^[og]\s*(.+)?/,
					smoothing_pattern: /^s\s+(\d+|on|off)/,
					material_library_pattern: /^mtllib /,
					material_use_pattern: /^usemtl /
				}
		},
		o.OBJLoader.prototype = {
			constructor: o.OBJLoader,
			load: function(t, e, n, i) {
				var r = this,
					a = new o.FileLoader(r.manager);
				a.setPath(this.path),
					a.load(t, function(t) {
						e(r.parse(t))
					}, n, i)
			},
			setPath: function(t) {
				this.path = t
			},
			setMaterials: function(t) {
				this.materials = t
			},
			_createParserState: function() {
				var t = {
					objects: [],
					object: {},
					vertices: [],
					normals: [],
					uvs: [],
					materialLibraries: [],
					startObject: function(t, e) {
						if(this.object && this.object.fromDeclaration === !1)
							return this.object.name = t,
								void(this.object.fromDeclaration = e !== !1);
						var n = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
						if(this.object && "function" == typeof this.object._finalize && this.object._finalize(!0),
							this.object = {
								name: t || "",
								fromDeclaration: e !== !1,
								geometry: {
									vertices: [],
									normals: [],
									uvs: []
								},
								materials: [],
								smooth: !0,
								startMaterial: function(t, e) {
									var n = this._finalize(!1);
									n && (n.inherited || n.groupCount <= 0) && this.materials.splice(n.index, 1);
									var i = {
										index: this.materials.length,
										name: t || "",
										mtllib: Array.isArray(e) && e.length > 0 ? e[e.length - 1] : "",
										smooth: void 0 !== n ? n.smooth : this.smooth,
										groupStart: void 0 !== n ? n.groupEnd : 0,
										groupEnd: -1,
										groupCount: -1,
										inherited: !1,
										clone: function(t) {
											var e = {
												index: "number" == typeof t ? t : this.index,
												name: this.name,
												mtllib: this.mtllib,
												smooth: this.smooth,
												groupStart: 0,
												groupEnd: -1,
												groupCount: -1,
												inherited: !1
											};
											return e.clone = this.clone.bind(e),
												e
										}
									};
									return this.materials.push(i),
										i
								},
								currentMaterial: function() {
									if(this.materials.length > 0)
										return this.materials[this.materials.length - 1]
								},
								_finalize: function(t) {
									var e = this.currentMaterial();
									if(e && e.groupEnd === -1 && (e.groupEnd = this.geometry.vertices.length / 3,
											e.groupCount = e.groupEnd - e.groupStart,
											e.inherited = !1),
										t && this.materials.length > 1)
										for(var n = this.materials.length - 1; n >= 0; n--)
											this.materials[n].groupCount <= 0 && this.materials.splice(n, 1);
									return t && 0 === this.materials.length && this.materials.push({
											name: "",
											smooth: this.smooth
										}),
										e
								}
							},
							n && n.name && "function" == typeof n.clone) {
							var i = n.clone(0);
							i.inherited = !0,
								this.object.materials.push(i)
						}
						this.objects.push(this.object)
					},
					finalize: function() {
						this.object && "function" == typeof this.object._finalize && this.object._finalize(!0)
					},
					parseVertexIndex: function(t, e) {
						var n = parseInt(t, 10);
						return 3 * (n >= 0 ? n - 1 : n + e / 3)
					},
					parseNormalIndex: function(t, e) {
						var n = parseInt(t, 10);
						return 3 * (n >= 0 ? n - 1 : n + e / 3)
					},
					parseUVIndex: function(t, e) {
						var n = parseInt(t, 10);
						return 2 * (n >= 0 ? n - 1 : n + e / 2)
					},
					addVertex: function(t, e, n) {
						var i = this.vertices,
							r = this.object.geometry.vertices;
						r.push(i[t + 0]),
							r.push(i[t + 1]),
							r.push(i[t + 2]),
							r.push(i[e + 0]),
							r.push(i[e + 1]),
							r.push(i[e + 2]),
							r.push(i[n + 0]),
							r.push(i[n + 1]),
							r.push(i[n + 2])
					},
					addVertexLine: function(t) {
						var e = this.vertices,
							n = this.object.geometry.vertices;
						n.push(e[t + 0]),
							n.push(e[t + 1]),
							n.push(e[t + 2])
					},
					addNormal: function(t, e, n) {
						var i = this.normals,
							r = this.object.geometry.normals;
						r.push(i[t + 0]),
							r.push(i[t + 1]),
							r.push(i[t + 2]),
							r.push(i[e + 0]),
							r.push(i[e + 1]),
							r.push(i[e + 2]),
							r.push(i[n + 0]),
							r.push(i[n + 1]),
							r.push(i[n + 2])
					},
					addUV: function(t, e, n) {
						var i = this.uvs,
							r = this.object.geometry.uvs;
						r.push(i[t + 0]),
							r.push(i[t + 1]),
							r.push(i[e + 0]),
							r.push(i[e + 1]),
							r.push(i[n + 0]),
							r.push(i[n + 1])
					},
					addUVLine: function(t) {
						var e = this.uvs,
							n = this.object.geometry.uvs;
						n.push(e[t + 0]),
							n.push(e[t + 1])
					},
					addFace: function(t, e, n, i, r, o, a, s, l, c, u, h) {
						var d, f = this.vertices.length,
							p = this.parseVertexIndex(t, f),
							m = this.parseVertexIndex(e, f),
							v = this.parseVertexIndex(n, f);
						if(void 0 === i ? this.addVertex(p, m, v) : (d = this.parseVertexIndex(i, f),
								this.addVertex(p, m, d),
								this.addVertex(m, v, d)),
							void 0 !== r) {
							var g = this.uvs.length;
							p = this.parseUVIndex(r, g),
								m = this.parseUVIndex(o, g),
								v = this.parseUVIndex(a, g),
								void 0 === i ? this.addUV(p, m, v) : (d = this.parseUVIndex(s, g),
									this.addUV(p, m, d),
									this.addUV(m, v, d))
						}
						if(void 0 !== l) {
							var _ = this.normals.length;
							p = this.parseNormalIndex(l, _),
								m = l === c ? p : this.parseNormalIndex(c, _),
								v = l === u ? p : this.parseNormalIndex(u, _),
								void 0 === i ? this.addNormal(p, m, v) : (d = this.parseNormalIndex(h, _),
									this.addNormal(p, m, d),
									this.addNormal(m, v, d))
						}
					},
					addLineGeometry: function(t, e) {
						this.object.geometry.type = "Line";
						for(var n = this.vertices.length, i = this.uvs.length, r = 0, o = t.length; r < o; r++)
							this.addVertexLine(this.parseVertexIndex(t[r], n));
						for(var a = 0, o = e.length; a < o; a++)
							this.addUVLine(this.parseUVIndex(e[a], i))
					}
				};
				return t.startObject("", !1),
					t
			},
			parse: function(t) {
				var e = this._createParserState();
				t.indexOf("\r\n") !== -1 && (t = t.replace(/\r\n/g, "\n")),
					t.indexOf("\\\n") !== -1 && (t = t.replace(/\\\n/g, ""));
				for(var n = t.split("\n"), i = "", r = "", a = "", s = 0, l = [], c = "function" == typeof "".trimLeft, u = 0, h = n.length; u < h; u++)
					if(i = n[u],
						i = c ? i.trimLeft() : i.trim(),
						s = i.length,
						0 !== s && (r = i.charAt(0),
							"#" !== r))
						if("v" === r)
							if(a = i.charAt(1),
								" " === a && null !== (l = this.regexp.vertex_pattern.exec(i)))
								e.vertices.push(parseFloat(l[1]), parseFloat(l[2]), parseFloat(l[3]));
							else if("n" === a && null !== (l = this.regexp.normal_pattern.exec(i)))
					e.normals.push(parseFloat(l[1]), parseFloat(l[2]), parseFloat(l[3]));
				else {
					if("t" !== a || null === (l = this.regexp.uv_pattern.exec(i)))
						throw new Error("Unexpected vertex/normal/uv line: '" + i + "'");
					e.uvs.push(parseFloat(l[1]), parseFloat(l[2]))
				} else if("f" === r)
					if(null !== (l = this.regexp.face_vertex_uv_normal.exec(i)))
						e.addFace(l[1], l[4], l[7], l[10], l[2], l[5], l[8], l[11], l[3], l[6], l[9], l[12]);
					else if(null !== (l = this.regexp.face_vertex_uv.exec(i)))
					e.addFace(l[1], l[3], l[5], l[7], l[2], l[4], l[6], l[8]);
				else if(null !== (l = this.regexp.face_vertex_normal.exec(i)))
					e.addFace(l[1], l[3], l[5], l[7], void 0, void 0, void 0, void 0, l[2], l[4], l[6], l[8]);
				else {
					if(null === (l = this.regexp.face_vertex.exec(i)))
						throw new Error("Unexpected face line: '" + i + "'");
					e.addFace(l[1], l[2], l[3], l[4])
				} else if("l" === r) {
					var d = i.substring(1).trim().split(" "),
						f = [],
						p = [];
					if(i.indexOf("/") === -1)
						f = d;
					else
						for(var m = 0, v = d.length; m < v; m++) {
							var g = d[m].split("/");
							"" !== g[0] && f.push(g[0]),
								"" !== g[1] && p.push(g[1])
						}
					e.addLineGeometry(f, p)
				} else if(null !== (l = this.regexp.object_pattern.exec(i))) {
					var _ = (" " + l[0].substr(1).trim()).substr(1);
					e.startObject(_)
				} else if(this.regexp.material_use_pattern.test(i))
					e.object.startMaterial(i.substring(7).trim(), e.materialLibraries);
				else if(this.regexp.material_library_pattern.test(i))
					e.materialLibraries.push(i.substring(7).trim());
				else {
					if(null === (l = this.regexp.smoothing_pattern.exec(i))) {
						if("\0" === i)
							continue;
						throw new Error("Unexpected line: '" + i + "'")
					}
					var y = l[1].trim().toLowerCase();
					e.object.smooth = "1" === y || "on" === y;
					var b = e.object.currentMaterial();
					b && (b.smooth = e.object.smooth)
				}
				e.finalize();
				var x = new o.Group;
				x.materialLibraries = [].concat(e.materialLibraries);
				for(var u = 0, h = e.objects.length; u < h; u++) {
					var w = e.objects[u],
						T = w.geometry,
						M = w.materials,
						E = "Line" === T.type;
					if(0 !== T.vertices.length) {
						var S = new o.BufferGeometry;
						S.addAttribute("position", new o.BufferAttribute(new Float32Array(T.vertices), 3)),
							T.normals.length > 0 ? S.addAttribute("normal", new o.BufferAttribute(new Float32Array(T.normals), 3)) : S.computeVertexNormals(),
							T.uvs.length > 0 && S.addAttribute("uv", new o.BufferAttribute(new Float32Array(T.uvs), 2));
						for(var X = [], A = 0, P = M.length; A < P; A++) {
							var R = M[A],
								b = void 0;
							if(null !== this.materials && (b = this.materials.create(R.name),
									E && b && !(b instanceof o.LineBasicMaterial))) {
								var O = new o.LineBasicMaterial;
								O.copy(b),
									b = O
							}
							b || (b = E ? new o.LineBasicMaterial : new o.MeshPhongMaterial,
									b.name = R.name),
								b.shading = R.smooth ? o.SmoothShading : o.FlatShading,
								X.push(b)
						}
						var C;
						if(X.length > 1) {
							for(var A = 0, P = M.length; A < P; A++) {
								var R = M[A];
								S.addGroup(R.groupStart, R.groupCount, A)
							}
							C = E ? new o.LineSegments(S, X) : new o.Mesh(S, X)
						} else
							C = E ? new o.LineSegments(S, X[0]) : new o.Mesh(S, X[0]);
						C.name = w.name,
							x.add(C)
					}
				}
				return x
			}
		},
		e.default = o.OBJLoader
}, function(t, e, n) {
	"use strict";

	function i(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}
	var r = n(9),
		o = i(r);
	o.MTLLoader = function(t) {
			this.manager = void 0 !== t ? t : o.DefaultLoadingManager
		},
		o.MTLLoader.prototype = {
			constructor: o.MTLLoader,
			load: function(t, e, n, i) {
				var r = this,
					a = new o.FileLoader(this.manager);
				a.setPath(this.path),
					a.load(t, function(t) {
						e(r.parse(t))
					}, n, i)
			},
			setPath: function(t) {
				this.path = t
			},
			setTexturePath: function(t) {
				this.texturePath = t
			},
			setBaseUrl: function(t) {
				console.warn("THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead."),
					this.setTexturePath(t)
			},
			setCrossOrigin: function(t) {
				this.crossOrigin = t
			},
			setMaterialOptions: function(t) {
				this.materialOptions = t
			},
			parse: function(t) {
				for(var e = t.split("\n"), n = {}, i = /\s+/, r = {}, a = 0; a < e.length; a++) {
					var s = e[a];
					if(s = s.trim(),
						0 !== s.length && "#" !== s.charAt(0)) {
						var l = s.indexOf(" "),
							c = l >= 0 ? s.substring(0, l) : s;
						c = c.toLowerCase();
						var u = l >= 0 ? s.substring(l + 1) : "";
						if(u = u.trim(),
							"newmtl" === c)
							n = {
								name: u
							},
							r[u] = n;
						else if(n)
							if("ka" === c || "kd" === c || "ks" === c) {
								var h = u.split(i, 3);
								n[c] = [parseFloat(h[0]), parseFloat(h[1]), parseFloat(h[2])]
							} else
								n[c] = u
					}
				}
				var d = new o.MTLLoader.MaterialCreator(this.texturePath || this.path, this.materialOptions);
				return d.setCrossOrigin(this.crossOrigin),
					d.setManager(this.manager),
					d.setMaterials(r),
					d
			}
		},
		o.MTLLoader.MaterialCreator = function(t, e) {
			this.baseUrl = t || "",
				this.options = e,
				this.materialsInfo = {},
				this.materials = {},
				this.materialsArray = [],
				this.nameLookup = {},
				this.side = this.options && this.options.side ? this.options.side : o.FrontSide,
				this.wrap = this.options && this.options.wrap ? this.options.wrap : o.RepeatWrapping
		},
		o.MTLLoader.MaterialCreator.prototype = {
			constructor: o.MTLLoader.MaterialCreator,
			setCrossOrigin: function(t) {
				this.crossOrigin = t
			},
			setManager: function(t) {
				this.manager = t
			},
			setMaterials: function(t) {
				this.materialsInfo = this.convert(t),
					this.materials = {},
					this.materialsArray = [],
					this.nameLookup = {}
			},
			convert: function(t) {
				if(!this.options)
					return t;
				var e = {};
				for(var n in t) {
					var i = t[n],
						r = {};
					e[n] = r;
					for(var o in i) {
						var a = !0,
							s = i[o],
							l = o.toLowerCase();
						switch(l) {
							case "kd":
							case "ka":
							case "ks":
								this.options && this.options.normalizeRGB && (s = [s[0] / 255, s[1] / 255, s[2] / 255]),
									this.options && this.options.ignoreZeroRGBs && 0 === s[0] && 0 === s[1] && 0 === s[2] && (a = !1)
						}
						a && (r[l] = s)
					}
				}
				return e
			},
			preload: function() {
				for(var t in this.materialsInfo)
					this.create(t)
			},
			getIndex: function(t) {
				return this.nameLookup[t]
			},
			getAsArray: function() {
				var t = 0;
				for(var e in this.materialsInfo)
					this.materialsArray[t] = this.create(e),
					this.nameLookup[e] = t,
					t++;
				return this.materialsArray
			},
			create: function(t) {
				return void 0 === this.materials[t] && this.createMaterial_(t),
					this.materials[t]
			},
			createMaterial_: function(t) {
				function e(t, e) {
					return "string" != typeof e || "" === e ? "" : /^https?:\/\//i.test(e) ? e : t + e
				}

				function n(t, n) {
					if(!a[t]) {
						var r = i.getTextureParams(n, a),
							o = i.loadTexture(e(i.baseUrl, r.url));
						o.repeat.copy(r.scale),
							o.offset.copy(r.offset),
							o.wrapS = i.wrap,
							o.wrapT = i.wrap,
							a[t] = o
					}
				}
				var i = this,
					r = this.materialsInfo[t],
					a = {
						name: t,
						side: this.side
					};
				for(var s in r) {
					var l = r[s];
					if("" !== l)
						switch(s.toLowerCase()) {
							case "kd":
								a.color = (new o.Color).fromArray(l);
								break;
							case "ks":
								a.specular = (new o.Color).fromArray(l);
								break;
							case "map_kd":
								n("map", l);
								break;
							case "map_ks":
								n("specularMap", l);
								break;
							case "map_bump":
							case "bump":
								n("bumpMap", l);
								break;
							case "ns":
								a.shininess = parseFloat(l);
								break;
							case "d":
								l < 1 && (a.opacity = l,
									a.transparent = !0);
								break;
							case "Tr":
								l > 0 && (a.opacity = 1 - l,
									a.transparent = !0)
						}
				}
				return this.materials[t] = new o.MeshPhongMaterial(a),
					this.materials[t]
			},
			getTextureParams: function(t, e) {
				var n, i = {
						scale: new o.Vector2(1, 1),
						offset: new o.Vector2(0, 0)
					},
					r = t.split(/\s+/);
				return n = r.indexOf("-bm"),
					n >= 0 && (e.bumpScale = parseFloat(r[n + 1]),
						r.splice(n, 2)),
					n = r.indexOf("-s"),
					n >= 0 && (i.scale.set(parseFloat(r[n + 1]), parseFloat(r[n + 2])),
						r.splice(n, 4)),
					n = r.indexOf("-o"),
					n >= 0 && (i.offset.set(parseFloat(r[n + 1]), parseFloat(r[n + 2])),
						r.splice(n, 4)),
					i.url = r.join(" ").trim(),
					i
			},
			loadTexture: function(t, e, n, i, r) {
				var a, s = o.Loader.Handlers.get(t),
					l = void 0 !== this.manager ? this.manager : o.DefaultLoadingManager;
				return null === s && (s = new o.TextureLoader(l)),
					s.setCrossOrigin && s.setCrossOrigin(this.crossOrigin),
					a = s.load(t, n, i, r),
					void 0 !== e && (a.mapping = e),
					a
			}
		}
}, function(t, e, n) {
	"use strict";

	function i(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function r(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function o(t) {
		var e = new g.default(R).add(t, P);
		a(e)
	}

	function a(t) {
		A ? A.merge(t, O) : (A = t,
			A.clearGroups());
		var e = t.attributes.position.count;
		A.addGroup(O, e, P),
			O += e,
			P++
	}

	function s() {
		var t = void 0,
			e = [];
		return y.default.billboards.forEach(function(n, i) {
				var r = n.position,
					o = n.rotation,
					a = n.type,
					s = n.scale,
					l = n.shininess,
					c = new T.default(a, l, r),
					u = new E.Matrix4;
				u.makeRotationY(o[1]),
					u.elements[5] = s,
					u.elements[10] = s,
					u.setPosition({
						x: r[0],
						y: r[1],
						z: r[2]
					});
				var h = c.geometry;
				t ? t.merge(h, u, i) : t = h.applyMatrix(u),
					e.push(c.material)
			}),
			new E.Mesh(t, e)
	}

	function l() {
		var t = m.default.resources.model.lantern,
			e = new E.Group,
			n = .2;
		return y.default.lanterns.forEach(function(e) {
				var i = e.position,
					r = e.rotation,
					o = new E.Matrix4;
				o.makeRotationFromEuler(new E.Euler(r[0], r[1], r[2])),
					o.setPosition({
						x: i[0] / n,
						y: i[1] / n,
						z: i[2] / n
					});
				var s = t.children[1];
				a(s.geometry.clone().applyMatrix(o)),
					R.push(s.material)
			}),
			e
	}

	function c() {
		var t = new E.PlaneGeometry(S, S, 1),
			e = new E.MeshBasicMaterial({
				map: m.default.resources.texture.fog,
				transparent: !0
			}),
			n = new E.Mesh(t, e);
		return n.rotation.x = -Math.PI / 2,
			n.position.y = -4e3,
			n
	}

	function u() {
		var t = x.default.getScene(),
			e = new E.Group,
			n = new E.Mesh(A, R);
		n.scale.x = n.scale.y = n.scale.z = .15,
			C = s();
		var i = c();
		l(),
			e.add(n),
			e.add(C),
			e.add(i);
		var r = e.clone();
		r.position.z -= S,
			t.add(e),
			t.add(r),
			X.push(e),
			X.push(r)
	}

	function h(t, e) {
		C.material.forEach(function(t, n) {
			t.uniforms.uTime.value += e
		});
		for(var n = 0; n < X.length; n++) {
			var i = X[n];
			0 === y.default.status ? i.visible = !0 : i.visible = !1,
				i.position.z += t,
				i.position.z > S && (i.position.z -= 2 * S)
		}
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var d = n(10),
		f = r(d),
		p = n(14),
		m = r(p),
		v = n(18),
		g = r(v),
		_ = n(11),
		y = r(_),
		b = n(8),
		x = r(b),
		w = n(19),
		T = r(w),
		M = n(9),
		E = i(M),
		S = (f.default.BUILDING_COUNT,
			f.default.BUILDING_DEPTH),
		X = (f.default.TREE_COLS,
			f.default.FLOOR_WIDTH,
			f.default.FLOOR_DEPTH,
			f.default.MOVE_STEP,
			f.default.FLOOR_YPOS, []),
		A = void 0;
	E.BufferGeometry.prototype.merge = function(t, e) {
		if(t && t.isBufferGeometry) {
			void 0 === e && (e = 0);
			var n = this.attributes;
			for(var i in n)
				if(void 0 !== t.attributes[i]) {
					var r = n[i],
						o = r.array,
						a = t.attributes[i],
						s = a.array,
						l = a.itemSize,
						c = new Float32Array(r.array.length + s.length);
					c.set(o),
						c.set(s, r.array.length),
						r.array = c,
						r.count = r.array.length / l
				}
			return this
		}
	};
	var P = 0,
		R = [],
		O = 0,
		C = void 0;
	e.default = {
		add: o,
		init: u,
		update: h
	}
}, function(t, e, n) {
	"use strict";

	function i(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function r(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function o(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var a = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		s = n(14),
		l = r(s),
		c = n(9),
		u = i(c),
		h = function() {
			function t(e) {
				o(this, t),
					this.materials = e
			}
			return a(t, [{
					key: "flip",
					value: function(t, e) {
						var n = e.clone();
						n.elements[5] = -n.elements[5];
						var i = t.clone();
						return i.applyMatrix(n),
							i.computeVertexNormals(),
							i
					}
				}, {
					key: "add",
					value: function(t, e) {
						var n = l.default.resources.model[t.name].clone(),
							i = n.children[0];
						this.materials[e] = i.material,
							i.material.side = u.DoubleSide,
							t.rotation && i.matrix.makeRotationY(t.rotation.y),
							t.position && i.matrix.setPosition(new u.Vector3(t.position.x / .15, t.position.y / .15, t.position.z / .15));
						var r = this.flip(i.geometry, i.matrix),
							o = i.geometry.clone().applyMatrix(i.matrix);
						return o.merge(r),
							o
					}
				}]),
				t
		}();
	e.default = h
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function o(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var a = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		s = n(9),
		l = r(s),
		c = n(14),
		u = i(c),
		h = n(11),
		d = (i(h),
			n(8)),
		f = i(d),
		p = function() {
			function t(e, i, r) {
				o(this, t);
				var a = u.default.resources.texture[e],
					s = a.image,
					c = 5 * s.width,
					h = 5 * s.height,
					d = new l.PlaneGeometry(c, h),
					p = new l.ShaderMaterial({
						uniforms: {
							uTime: {
								type: "f",
								value: 0
							},
							shininess: {
								type: "f",
								value: i
							},
							glowColor: {
								type: "c",
								value: new l.Color(16777215)
							},
							viewVector: {
								type: "v3",
								value: f.default.getCamera().position
							},
							image: {
								type: "t",
								value: a
							},
							z: {
								type: "f",
								value: r[2]
							}
						},
						vertexShader: n(20),
						fragmentShader: n(21),
						side: l.FrontSide,
						transparent: !0
					});
				return new l.Mesh(d, p)
			}
			return a(t, [{
					key: "update",
					value: function(t, e, n) {}
				}]),
				t
		}();
	e.default = p
}, function(t, e) {
	t.exports = "#define GLSLIFY 1\n// https://stackoverflow.com/questions/42820017/apply-a-glow-effect-onto-a-three-textgeometry-object-in-three-js\nuniform vec3 viewVector;\nuniform float uTime;\nuniform float z;\nuniform float shininess;\nvarying float intensity;\nvarying vec2 vUv; \n\nvoid main() {\n\tvUv = uv;\n\n  vec3 vNormal = normalize( normalMatrix * normal );\n\tvec3 vNormel = normalize( normalMatrix * viewVector );\n\tintensity = pow( 10.0 - dot(vNormal, vNormel), 0.0 + shininess * sin((uTime + z * 0.2) * 0.005));\n\t\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n"
}, function(t, e) {
	t.exports = "#define GLSLIFY 1\nuniform vec3 glowColor;\nvarying float intensity;\nuniform sampler2D image;\nvarying vec2 vUv;\n\nvoid main() {\n\tvec3 glow = glowColor * intensity;\n\tvec4 color = texture2D(image, vUv);\n\n\tif(color.a - 0.1 < 0.0) {\n\t\tdiscard;\n\t}\n\n  gl_FragColor = vec4(color.rgb * glow, 1.0 );\n}\n"
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		u.innerText = "  " + t + "%",
			h.style.webkitTransform = "translateX(-" + (100 - t) + "%)",
			d.style.webkitTransform = "translateX(-" + (100 - t) + "%)",
			100 === t && l.default.isWeixin && (f.src = "../img/TB1.BJhSXXXXXbYXXXXXXXXXXXX-240-80.png",
				setTimeout(function() {
					o()
				}, 1500))
	}

	function o() {
		document.querySelector(".loading-bar-container").style.visibility = "hidden",
			u.style.visibility = "hidden",
			f.classList.add("animate")
	}

	function a() {
		c.classList.add("fade")
	}
	Object.defineProperty(e, "__esModule", {
			value: !0
		}),
		n(23);
	var s = n(11),
		l = i(s),
		c = document.querySelector("#loading"),
		u = document.querySelector(".loading-text"),
		h = document.querySelector(".loading-content-fullfilled"),
		d = document.querySelector(".loading-ball-container"),
		f = document.querySelector(".loading-wx-tap");
	e.default = {
		update: r,
		end: a
	}
}, function(t, e) {}, function(t, e) {
	"use strict";

	function n(t, e, n) {
		return e in t ? Object.defineProperty(t, e, {
				value: n,
				enumerable: !0,
				configurable: !0,
				writable: !0
			}) : t[e] = n,
			t
	}

	function i(t, e) {
		for(var n in t)
			if("object" === r(t[n]))
				e[n] || (e[n] = t[n].forEach ? [] : {}),
				i(t[n], e[n]);
			else {
				var o = t[n];
				o && (e[n] = t[n])
			}
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
			return typeof t
		} :
		function(t) {
			return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
		},
		o = n({
			saleLink: "https://detail.tmall.com/item.htm?id=549912705079",
			downGradeLink: "https://detail.tmall.com/item.htm?id=549912705079",
			music: "./video/Times Change.mp3",
			share: {
				shareTitle: "",
				shareText: "",
				sharePic: "",
				shareUrl: ""
			},
			someOtherKey: "",
			panoVideos: {
				east: "./video/east.mp4",
				west: "./video/west.mp4",
				south: "./video/south.mp4",
				north: "./video/north.mp4"
			},
			normalVideos: {
				east: "./video/TB1vIXqQXXXXXcyXXXXXXXXXXXX.mp4",
				west: "./video/TB1vIXqQXXXXXcyXXXXXXXXXXXX.mp4",
				south: "./video/TB1vIXqQXXXXXcyXXXXXXXXXXXX.mp4",
				north: "./video/TB1vIXqQXXXXXcyXXXXXXXXXXXX.mp4"
			}
		}, "downGradeLink", "");
	if(window.pageData) {
		var a = window.pageData;
		i(a, o)
	}
	e.default = o
}, function(t, e) {
	"use strict";
	Object.defineProperty(e, "__esModule", {
			value: !0
		}),
		e.default = {
			model: {
				"car.obj": "./model/TB1suYHRVXXXXbKXFXXXXXXXXXX.obj",
				"left_kite.obj": "./model/TB1YRDrRVXXXXboXVXXXXXXXXXX.obj",
				"right_kite.obj": "./model/TB1D82dRVXXXXXtapXXXXXXXXXX.obj",
				"BuildingD.obj": "./model/TB14nbQRVXXXXaKXpXXXXXXXXXX.obj",
				"BuildingF.obj": "./model/TB1ezbKRVXXXXcPXpXXXXXXXXXX.obj",
				"BuildingH.obj": "./model/TB1NB_JRVXXXXc4XpXXXXXXXXXX.obj",
				"NY3.obj": "./model/TB1PgDZRVXXXXbDXXXXXXXXXXXX.obj",
				"BuildingB.obj": "./model/TB1fjfVRVXXXXcmXXXXXXXXXXXX.obj",
				"BuildingC.obj": "./model/TB1HPLHRVXXXXXRXFXXXXXXXXXX.obj",
				"dlochhea_lighting_centralStreetExports_v018_Carp_body_0.obj": "./model/TB1z8jNRVXXXXazXpXXXXXXXXXX.obj",
				"BuildingA.obj": "./model/TB1p5vFRVXXXXa6XFXXXXXXXXXX.obj",
				"BuildingJ.obj": "./model/TB1AsbWRVXXXXcyXXXXXXXXXXXX.obj",
				"pyramid3.obj": "./model/TB1UpbCRVXXXXa6aXXXXXXXXXXX.obj",
				"BuildingDa.obj": "./model/TB1.1P7RVXXXXX4XVXXXXXXXXXX.obj",
				"BuildingHa.obj": "./model/TB1kloeRVXXXXcfXpXXXXXXXXXX.obj",
				"BuildingBa.obj": "./model/TB1injBRVXXXXaNapXXXXXXXXXX.obj",
				"BuildingCa.obj": "./model/TB1QxcxRVXXXXaVXXXXXXXXXXXX.obj",
				"BuildingAa.obj": "./model/TB1URIaRVXXXXbQXFXXXXXXXXXX.obj",
				"BuildingA2a.obj": "./model/TB1ptrNRVXXXXXBaXXXXXXXXXXX.obj",
				"Billboards.obj": "./model/TB1vewwRVXXXXa.XXXXXXXXXXXX.obj",
				"Fog.obj": "./model/TB1V57nRVXXXXXHXFXXXXXXXXXX.obj",
				"Lanterns.obj": "./model/TB1TOATRVXXXXayXVXXXXXXXXXX.obj",
				".BuildingAa.obj.swp": "",
				".BuildingAa-low.obj.swp": "",				
				".Lanterns.obj.swp": "",
				"Bridge.obj": "./model/TB1KjwxRVXXXXapXFXXXXXXXXXX.obj",
				"Carp.obj": "./model/TB1ckgvRVXXXXaNXFXXXXXXXXXX.obj",
				"CarpFinal.obj": "./model/TB1dIkCRVXXXXa_XFXXXXXXXXXX.obj",	
				/*
				"BuildingAa-low.obj": "./model/TB1iB8qSXXXXXXkXVXXXXXXXXXX.obj",
				"BuildingBa-low.obj": "./model/TB1.ElCSXXXXXX6XFXXXXXXXXXX.obj",		
				"BuildingCa-low.obj": "./model/TB1HbXXSXXXXXblaXXXXXXXXXXX.obj",
				"BuildingDa-low.obj": "./model/TB17NhQSXXXXXXHXpXXXXXXXXXX.obj",
				"BuildingF-low.obj": "./model/TB1nCpQSXXXXXbDXXXXXXXXXXXX.obj",
				"BuildingHa-low.obj": "./model/TB178xTSXXXXXcsXXXXXXXXXXXX.obj",
				"BuildingJ-low.obj": "./model/TB1HW8jSXXXXXblXVXXXXXXXXXX.obj",				
				"NY3-low.obj": "./model/TB1tmV2SXXXXXXmXXXXXXXXXXXX.obj"
				*/
				"BuildingAa-low.obj": "./model/ayd_X01_stone1.obj",
				"BuildingBa-low.obj": "./model/ayd_X01_stone1.obj",		
				"BuildingCa-low.obj": "./model/ayd_X01_stone1.obj",
				"BuildingDa-low.obj": "./model/ayd_X01_stone1.obj",
				"BuildingF-low.obj": "./model/ayd_X01_stone1.obj",
				"BuildingHa-low.obj": "./model/ayd_X01_stone1.obj",
				"BuildingJ-low.obj": "./model/ayd_X01_stone1.obj",				
				"NY3-low.obj": "./model/ayd_X20_tree4.obj"
			},
			mtl: {
				"BuildingJ.mtl": "./model/TB1hlRnSXXXXXbSXXXXXXXXXXXX.mtl",
				"right_kite.mtl": "./model/TB16akMRVXXXXaBaXXXXXXXXXXX.mtl",
				"BuildingA.mtl": "./model/TB1.AfyRVXXXXXmXVXXXXXXXXXX.mtl",
				"BuildingC.mtl": "./model/TB1.AfyRVXXXXXmXVXXXXXXXXXX.mtl",
				"BuildingD.mtl": "./model/TB1.AfyRVXXXXXmXVXXXXXXXXXX.mtl",
				"BuildingB.mtl": "./model/TB1.AfyRVXXXXXmXVXXXXXXXXXX.mtl",
				"BuildingF.mtl": "./model/TB1eBc0RVXXXXXpXVXXXXXXXXXX.mtl",
				"NY3.mtl": "./model/TB1g1ZHRVXXXXcEaXXXXXXXXXXX.mtl",
				"left_kite.mtl": "./model/TB16akMRVXXXXaBaXXXXXXXXXXX.mtl",
				"dlochhea_lighting_centralStreetExports_v018_car_45.mtl": "./model/TB1HisIRVXXXXcaaXXXXXXXXXXX.mtl",
				"BuildingH.mtl": "./model/TB1.AfyRVXXXXXmXVXXXXXXXXXX.mtl",
				"dlochhea_lighting_centralStreetExports_v018_Carp_body_0.mtl": "./model/TB1HisIRVXXXXcaaXXXXXXXXXXX.mtl",
				"pyramid3.mtl": "./model/TB1Zy3IRVXXXXcIaXXXXXXXXXXX.mtl",
				"BuildingHa.mtl": "./model/TB1emIFRVXXXXXUapXXXXXXXXXX.mtl",
				"BuildingDa.mtl": "./model/TB1jbcHRVXXXXbxaXXXXXXXXXXX.mtl",
				"BuildingCa.mtl": "./model/TB1emIFRVXXXXXUapXXXXXXXXXX.mtl",
				"BuildingA2a.mtl": "./model/TB1emIFRVXXXXXUapXXXXXXXXXX.mtl",
				"BuildingBa.mtl": "./model/TB1emIFRVXXXXXUapXXXXXXXXXX.mtl",
				"BuildingAa.mtl": "./model/TB1emIFRVXXXXXUapXXXXXXXXXX.mtl",
				".left_kite.mtl.swp": "",
				"Billboards.mtl": "./model/TB1emIFRVXXXXXUapXXXXXXXXXX.mtl",
				"Fog.mtl": "./model/TB1SVXXSXXXXXcgXpXXXXXXXXXX.mtl",
				".right_kite.mtl.swp": "",
				"Lanterns.mtl": "./model/TB1WjttSXXXXXapXXXXXXXXXXXX.mtl",
				".Lanterns.mtl.swp": "",
				"Bridge.mtl": "./model/TB1SVXXSXXXXXcgXpXXXXXXXXXX.mtl",
				".BuildingF.mtl.swp": "",
				"Carp.mtl": "./model/TB1SVXXSXXXXXcgXpXXXXXXXXXX.mtl",
				"CarpFinal.mtl": "./model/TB1x9cSRVXXXXbdXpXXXXXXXXXX.mtl",
				".CarpFinal.mtl.swp": "",
				".BuildingJ-low.mtl.swp": "",
				".BuildingAa-low.mtl.swp": "",
				".BuildingAa.mtl.swp": "",
				".NY3-low.mtl.swp": "",	
				/*
				"BuildingAa-low.mtl": "./model/TB19mNXSXXXXXamaXXXXXXXXXXX.mtl",
				"BuildingBa-low.mtl": "./model/TB1nppkSXXXXXaKXVXXXXXXXXXX.mtl",
				"BuildingCa-low.mtl": "./model/TB1c_tqSXXXXXXMXVXXXXXXXXXX.mtl",				
				"BuildingDa-low.mtl": "./model/TB17ONdSXXXXXcXXVXXXXXXXXXX.mtl",		
				"BuildingF-low.mtl": "./model/TB1DzBuSXXXXXbEXFXXXXXXXXXX.mtl",
				"BuildingHa-low.mtl": "./model/TB17_dQSXXXXXcTXXXXXXXXXXXX.mtl",
				"BuildingJ-low.mtl": "./model/TB1voXRSXXXXXbJXXXXXXXXXXXX.mtl",
				"NY3-low.mtl": "./model/TB1oHRVSXXXXXbgXXXXXXXXXXXX.mtl"
				*/
				"BuildingAa-low.mtl": "./model/ayd_X01_stone1.mtl",
				"BuildingBa-low.mtl": "./model/ayd_X01_stone1.mtl",
				"BuildingCa-low.mtl": "./model/ayd_X01_stone1.mtl",				
				"BuildingDa-low.mtl": "./model/ayd_X01_stone1.mtl",		
				"BuildingF-low.mtl": "./model/ayd_X01_stone1.mtl",
				"BuildingHa-low.mtl": "./model/ayd_X01_stone1.mtl",
				"BuildingJ-low.mtl": "./model/ayd_X01_stone1.mtl",
				"NY3-low.mtl": "./model/ayd_X20_tree4.mtl"
			},
			textures: {
				"z_fish.jpg": "./img/TB1hHr6RVXXXXb4apXXXXXXXXXX-512-512.jpg",
				"anabuildingd_spec.jpg": "./img/TB1pChjSXXXXXb3XXXXXXXXXXXX-1024-1024.jpg",
				"ny3_col_spec.jpg": "./img/TB1U1JbSXXXXXbWXpXXXXXXXXXX-1024-1024.jpg",
				"ny3_top.jpg": "./img/TB18_A4RVXXXXcLXFXXXXXXXXXX-1024-1024.jpg",
				"buildingj_spec.jpg": "./img/TB1APEZRVXXXXc.XFXXXXXXXXXX-1024-1024.jpg",
				"kite_blue.jpg": "./img/TB1CoRnSXXXXXbnXXXXXXXXXXXX-512-512.jpg",
				"AnaBuildingA_Spec.jpg": "./img/TB1zQ8uSXXXXXXRXXXXXXXXXXXX-1024-1024.jpg",
				"f_top.jpg": "./img/TB1kfQ0RVXXXXbCXFXXXXXXXXXX-1024-1024.jpg",
				"AnaBuildingH_NRM.jpg": "./img/TB1OvZHRVXXXXXyapXXXXXXXXXX-1024-1024.jpg",
				"AnaBuildingB_NRM.jpg": "./img/TB1tbRoSXXXXXcaXXXXXXXXXXXX-1024-1024.jpg",
				"buildingF_COL_AO.jpg": "./img/TB1M57_RVXXXXXJXFXXXXXXXXXX-1024-1024.jpg",
				"AIB1_COL_AO.jpg": "./img/TB1pwlcSXXXXXa1XpXXXXXXXXXX-1024-1024.jpg",
				"AnaBuilding_B_spec.jpg": "./img/TB1zjxoSXXXXXaDXXXXXXXXXXXX-1024-1024.jpg",
				"AnaBuildingH_spec.jpg": "./img/TB1W7.KRVXXXXcaaXXXXXXXXXXX-1024-1024.jpg",
				"AnaBuildingA_col_ao.jpg": "./img/TB1YIUKRVXXXXcqaXXXXXXXXXXX-1024-1024.jpg",
				"h2_top.jpg": "./img/TB13Mw9RVXXXXXwXFXXXXXXXXXX-1024-1024.jpg",
				"AnaBuildingA_NRM.jpg": "./img/TB1dAUHRVXXXXc_aXXXXXXXXXXX-1024-1024.jpg",
				"h1_top.jpg": "./img/TB1POsTRVXXXXbYXVXXXXXXXXXX-1024-1024.jpg",
				"AnaBuildingD_NRM.jpg": "./img/TB1YJNXSXXXXXcGXpXXXXXXXXXX-1024-1024.jpg",
				"d_top.jpg": "./img/TB1D4c1RVXXXXXVXVXXXXXXXXXX-1024-1024.jpg",
				"c_top.jpg": "./img/TB1Yp74RVXXXXc_XFXXXXXXXXXX-1024-1024.jpg",
				"a_top.jpg": "./img/TB1aj7VRVXXXXaKXVXXXXXXXXXX-1024-1024.jpg",
				"ny3_col_ao.jpg": "./img/TB10XpaSXXXXXcKXpXXXXXXXXXX-1024-1024.jpg",
				"AIB1_MSK.jpg": "./img/TB1gdDYRVXXXXbQXXXXXXXXXXXX-1024-1024.jpg",
				"AIB1_NRM.jpg": "./img/TB16GHhRVXXXXceaXXXXXXXXXXX-1024-1024.jpg",
				"A2bShape_ss.jpg": "./img/TB1XkprSXXXXXaVXXXXXXXXXXXX-1024-1024.jpg",
				"AnaBuildingC_NRM.jpg": "./img/TB1nmg8RVXXXXabXFXXXXXXXXXX-1024-1024.jpg",
				"b_top.jpg": "./img/TB12UhnSXXXXXb.XXXXXXXXXXXX-1024-1024.jpg",
				"AnaBuildingB_col_ao.jpg": "./img/TB1OowGRVXXXXXaapXXXXXXXXXX-1024-1024.jpg",
				"AnaBuildingD_col_ao.jpg": "./img/TB13Ag1RVXXXXXNXVXXXXXXXXXX-1024-1024.jpg",
				"AnaBuildingJ_col_ao.jpg": "./img/TB1mRtvSXXXXXXNXXXXXXXXXXXX-1024-1024.jpg",
				"CbShape_ss.jpg": "./img/TB1fEQ_RVXXXXXqXFXXXXXXXXXX-1024-1024.jpg",
				"DbShape_ss.jpg": "./img/TB1TwcWRVXXXXbtXVXXXXXXXXXX-1024-1024.jpg",
				"AnaBuildingH_col_ao.jpg": "./img/TB1eSQERVXXXXXfapXXXXXXXXXX-1024-1024.jpg",
				"AbShape_ss.jpg": "./img/TB1on7MRVXXXXX7aXXXXXXXXXXX-1024-1024.jpg",
				"BbShape_ss.jpg": "./img/TB1ywQPRVXXXXXmaXXXXXXXXXXX-1024-1024.jpg",
				"A2aShape_ss.jpg": "./img/TB17xg9RVXXXXaaXFXXXXXXXXXX-1024-1024.jpg",
				"BaShape_ss.jpg": "./img/TB1NrE_RVXXXXb5XpXXXXXXXXXX-1024-1024.jpg",
				"CaShape_ss.jpg": "./img/TB1e6k1RVXXXXXKXVXXXXXXXXXX-1024-1024.jpg",
				"HaShape_ss.jpg": "./img/TB1xARjSXXXXXcSXXXXXXXXXXXX-1024-1024.jpg",
				"j_top.jpg": "./img/TB1Ghw.RVXXXXczXpXXXXXXXXXX-1024-1024.jpg",
				"ESA_Skies.jpg": "./img/TB1fFZURVXXXXcCXVXXXXXXXXXX-1280-1280.jpg",
				"z_bridge.jpg": "./img/TB1nm8xSXXXXXXfXXXXXXXXXXXX-1024-1024.jpg",
				"AnaBuildingC_col_ao.jpg": "./img/TB12oVrSXXXXXakXXXXXXXXXXXX-1024-1024.jpg",
				"AnaBuildingJ_NRM.jpg": "./img/TB12ewJRVXXXXa1aXXXXXXXXXXX-1024-1024.jpg",
				"z_car.jpg": "./img/TB1XSJcSXXXXXbOXpXXXXXXXXXX-512-512.jpg",
				"DaShape_ss.jpg": "./img/TB136wVRVXXXXbIXVXXXXXXXXXX-1024-1024.jpg",
				"buildingF_NRM.jpg": "./img/TB18MdhSXXXXXXVXpXXXXXXXXXX-1024-1024.jpg",
				"Gate_01.jpg": "./img/TB1AKPxRVXXXXXqXVXXXXXXXXXX-2048-2048.jpg",
				"z_mbridge.jpg": "./img/TB1pKxvSXXXXXXUXXXXXXXXXXXX-1024-1024.jpg",
				"HbShape_ss.jpg": "./img/TB1NzxXSXXXXXbWXpXXXXXXXXXX-1024-1024.jpg",
				"AaShape_ss.jpg": "./img/TB1gHpoSXXXXXbjXXXXXXXXXXXX-1024-1024.jpg",
				"gate_tex_s5.jpg": "./img/TB1B5w9RVXXXXXrXFXXXXXXXXXX-512-512.jpg",
				"billboards.jpg": "./img/TB1dHgTRVXXXXalXXXXXXXXXXXX-1748-232.jpg",
				"billboard2.png": "./img/TB1z8ZYRVXXXXXeXXXXXXXXXXXX-512-678.png",
				"billboard9.png": "./img/TB1nygcRVXXXXXRaXXXXXXXXXXX-500-588.png",
				"billboard1.png": "./img/TB1BD7jRVXXXXajXVXXXXXXXXXX-500-664.png",
				"billboard5.png": "./img/TB1nhEnRVXXXXcYXFXXXXXXXXXX-500-375.png",
				"billboard8.png": "./img/TB1crQiRVXXXXcbXVXXXXXXXXXX-500-729.png",
				"billboard3.png": "./img/TB1hFL3RVXXXXarapXXXXXXXXXX-500-747.png",
				"billboard4.png": "./img/TB18mshRVXXXXcyXVXXXXXXXXXX-500-746.png",
				"billboard6.png": "./img/TB1XGcdRVXXXXX_aXXXXXXXXXXX-500-665.png",
				"billboard7.png": "./img/TB1at29RVXXXXXaapXXXXXXXXXX-500-729.png",
				"blackhole.jpg": "./img/TB1rvxeSXXXXXXwXpXXXXXXXXXX-1188-788.jpg",
				"billboard10.png": "./img/TB1TcwERVXXXXapXpXXXXXXXXXX-700-343.png",
				"entry.png": "./img/TB1pcw0RVXXXXb3XFXXXXXXXXXX-149-150.png",
				"fog.png": "./img/TB1f_FbSXXXXXX7XpXXXXXXXXXX-750-1077.png",
				"z_bridge_ss.jpg": "./img/TB1G4sWRVXXXXbhXVXXXXXXXXXX-1024-1024.jpg",
				"fishalpha_02_720.png": "./img/TB1fIXaSXXXXXbsXpXXXXXXXXXX-720-720.png",
				"fishdif_02_720.png": "./img/TB1kJXjSXXXXXXaXpXXXXXXXXXX-720-720.png",
				"fishspec_02_720.png": "./img/TB1x4VjSXXXXXcpXXXXXXXXXXXX-720-720.png",
				"fishdif_02_720.jpg": "./img/TB1IkIKRVXXXXbzXFXXXXXXXXXX-720-720.jpg",
				"lanterns.jpg": "./img/TB1wsJXSXXXXXc9XpXXXXXXXXXX-64-64.jpg"
			}
		}
}, function(t, e, n) {
	var i, r;
	(function(o) {
		/*!
		 * VERSION: 1.19.1
		 * DATE: 2017-01-17
		 * UPDATES AND DOCS AT: http://greensock.com
		 * 
		 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
		 *
		 * @license Copyright (c) 2008-2017, GreenSock. All rights reserved.
		 * This work is subject to the terms at http://greensock.com/standard-license or for
		 * Club GreenSock members, the software agreement that was issued with your membership.
		 * 
		 * @author: Jack Doyle, jack@greensock.com
		 **/
		var a = "undefined" != typeof t && t.exports && "undefined" != typeof o ? o : this || window;
		(a._gsQueue || (a._gsQueue = [])).push(function() {
				"use strict";
				a._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, n) {
						var i = function(t) {
								var e, n = [],
									i = t.length;
								for(e = 0; e !== i; n.push(t[e++]))
								;
								return n
							},
							r = function(t, e, n) {
								var i, r, o = t.cycle;
								for(i in o)
									r = o[i],
									t[i] = "function" == typeof r ? r(n, e[n]) : r[n % r.length];
								delete t.cycle
							},
							o = function(t, e, i) {
								n.call(this, t, e, i),
									this._cycle = 0,
									this._yoyo = this.vars.yoyo === !0,
									this._repeat = this.vars.repeat || 0,
									this._repeatDelay = this.vars.repeatDelay || 0,
									this._dirty = !0,
									this.render = o.prototype.render
							},
							a = 1e-10,
							s = n._internals,
							l = s.isSelector,
							c = s.isArray,
							u = o.prototype = n.to({}, .1, {}),
							h = [];
						o.version = "1.19.1",
							u.constructor = o,
							u.kill()._gc = !1,
							o.killTweensOf = o.killDelayedCallsTo = n.killTweensOf,
							o.getTweensOf = n.getTweensOf,
							o.lagSmoothing = n.lagSmoothing,
							o.ticker = n.ticker,
							o.render = n.render,
							u.invalidate = function() {
								return this._yoyo = this.vars.yoyo === !0,
									this._repeat = this.vars.repeat || 0,
									this._repeatDelay = this.vars.repeatDelay || 0,
									this._uncache(!0),
									n.prototype.invalidate.call(this)
							},
							u.updateTo = function(t, e) {
								var i, r = this.ratio,
									o = this.vars.immediateRender || t.immediateRender;
								e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time,
									this._uncache(!1),
									this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
								for(i in t)
									this.vars[i] = t[i];
								if(this._initted || o)
									if(e)
										this._initted = !1,
										o && this.render(0, !0, !0);
									else if(this._gc && this._enabled(!0, !1),
									this._notifyPluginsOfEnabled && this._firstPT && n._onPluginEvent("_onDisable", this),
									this._time / this._duration > .998) {
									var a = this._totalTime;
									this.render(0, !0, !1),
										this._initted = !1,
										this.render(a, !0, !1)
								} else if(this._initted = !1,
									this._init(),
									this._time > 0 || o)
									for(var s, l = 1 / (1 - r), c = this._firstPT; c;)
										s = c.s + c.c,
										c.c *= l,
										c.s = s - c.c,
										c = c._next;
								return this
							},
							u.render = function(t, e, n) {
								this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
								var i, r, o, l, c, u, h, d, f = this._dirty ? this.totalDuration() : this._totalDuration,
									p = this._time,
									m = this._totalTime,
									v = this._cycle,
									g = this._duration,
									_ = this._rawPrevTime;
								if(t >= f - 1e-7 && t >= 0 ? (this._totalTime = f,
										this._cycle = this._repeat,
										this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0,
											this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = g,
											this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1),
										this._reversed || (i = !0,
											r = "onComplete",
											n = n || this._timeline.autoRemoveChildren),
										0 === g && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (t = 0),
											(_ < 0 || t <= 0 && t >= -1e-7 || _ === a && "isPause" !== this.data) && _ !== t && (n = !0,
												_ > a && (r = "onReverseComplete")),
											this._rawPrevTime = d = !e || t || _ === t ? t : a)) : t < 1e-7 ? (this._totalTime = this._time = this._cycle = 0,
										this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0,
										(0 !== m || 0 === g && _ > 0) && (r = "onReverseComplete",
											i = this._reversed),
										t < 0 && (this._active = !1,
											0 === g && (this._initted || !this.vars.lazy || n) && (_ >= 0 && (n = !0),
												this._rawPrevTime = d = !e || t || _ === t ? t : a)),
										this._initted || (n = !0)) : (this._totalTime = this._time = t,
										0 !== this._repeat && (l = g + this._repeatDelay,
											this._cycle = this._totalTime / l >> 0,
											0 !== this._cycle && this._cycle === this._totalTime / l && m <= t && this._cycle--,
											this._time = this._totalTime - this._cycle * l,
											this._yoyo && 0 !== (1 & this._cycle) && (this._time = g - this._time),
											this._time > g ? this._time = g : this._time < 0 && (this._time = 0)),
										this._easeType ? (c = this._time / g,
											u = this._easeType,
											h = this._easePower,
											(1 === u || 3 === u && c >= .5) && (c = 1 - c),
											3 === u && (c *= 2),
											1 === h ? c *= c : 2 === h ? c *= c * c : 3 === h ? c *= c * c * c : 4 === h && (c *= c * c * c * c),
											1 === u ? this.ratio = 1 - c : 2 === u ? this.ratio = c : this._time / g < .5 ? this.ratio = c / 2 : this.ratio = 1 - c / 2) : this.ratio = this._ease.getRatio(this._time / g)),
									p === this._time && !n && v === this._cycle)
									return void(m !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate")));
								if(!this._initted) {
									if(this._init(), !this._initted || this._gc)
										return;
									if(!n && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration))
										return this._time = p,
											this._totalTime = m,
											this._rawPrevTime = _,
											this._cycle = v,
											s.lazyTweens.push(this),
											void(this._lazy = [t, e]);
									this._time && !i ? this.ratio = this._ease.getRatio(this._time / g) : i && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
								}
								for(this._lazy !== !1 && (this._lazy = !1),
									this._active || !this._paused && this._time !== p && t >= 0 && (this._active = !0),
									0 === m && (2 === this._initted && t > 0 && this._init(),
										this._startAt && (t >= 0 ? this._startAt.render(t, e, n) : r || (r = "_dummyGS")),
										this.vars.onStart && (0 === this._totalTime && 0 !== g || e || this._callback("onStart"))),
									o = this._firstPT; o;)
									o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s,
									o = o._next;
								this._onUpdate && (t < 0 && this._startAt && this._startTime && this._startAt.render(t, e, n),
										e || (this._totalTime !== m || r) && this._callback("onUpdate")),
									this._cycle !== v && (e || this._gc || this.vars.onRepeat && this._callback("onRepeat")),
									r && (this._gc && !n || (t < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, e, n),
										i && (this._timeline.autoRemoveChildren && this._enabled(!1, !1),
											this._active = !1), !e && this.vars[r] && this._callback(r),
										0 === g && this._rawPrevTime === a && d !== a && (this._rawPrevTime = 0)))
							},
							o.to = function(t, e, n) {
								return new o(t, e, n)
							},
							o.from = function(t, e, n) {
								return n.runBackwards = !0,
									n.immediateRender = 0 != n.immediateRender,
									new o(t, e, n)
							},
							o.fromTo = function(t, e, n, i) {
								return i.startAt = n,
									i.immediateRender = 0 != i.immediateRender && 0 != n.immediateRender,
									new o(t, e, i)
							},
							o.staggerTo = o.allTo = function(t, e, a, s, u, d, f) {
								s = s || 0;
								var p, m, v, g, _ = 0,
									y = [],
									b = function() {
										a.onComplete && a.onComplete.apply(a.onCompleteScope || this, arguments),
											u.apply(f || a.callbackScope || this, d || h)
									},
									x = a.cycle,
									w = a.startAt && a.startAt.cycle;
								for(c(t) || ("string" == typeof t && (t = n.selector(t) || t),
										l(t) && (t = i(t))),
									t = t || [],
									s < 0 && (t = i(t),
										t.reverse(),
										s *= -1),
									p = t.length - 1,
									v = 0; v <= p; v++) {
									m = {};
									for(g in a)
										m[g] = a[g];
									if(x && (r(m, t, v),
											null != m.duration && (e = m.duration,
												delete m.duration)),
										w) {
										w = m.startAt = {};
										for(g in a.startAt)
											w[g] = a.startAt[g];
										r(m.startAt, t, v)
									}
									m.delay = _ + (m.delay || 0),
										v === p && u && (m.onComplete = b),
										y[v] = new o(t[v], e, m),
										_ += s
								}
								return y
							},
							o.staggerFrom = o.allFrom = function(t, e, n, i, r, a, s) {
								return n.runBackwards = !0,
									n.immediateRender = 0 != n.immediateRender,
									o.staggerTo(t, e, n, i, r, a, s)
							},
							o.staggerFromTo = o.allFromTo = function(t, e, n, i, r, a, s, l) {
								return i.startAt = n,
									i.immediateRender = 0 != i.immediateRender && 0 != n.immediateRender,
									o.staggerTo(t, e, i, r, a, s, l)
							},
							o.delayedCall = function(t, e, n, i, r) {
								return new o(e, 0, {
									delay: t,
									onComplete: e,
									onCompleteParams: n,
									callbackScope: i,
									onReverseComplete: e,
									onReverseCompleteParams: n,
									immediateRender: !1,
									useFrames: r,
									overwrite: 0
								})
							},
							o.set = function(t, e) {
								return new o(t, 0, e)
							},
							o.isTweening = function(t) {
								return n.getTweensOf(t, !0).length > 0
							};
						var d = function(t, e) {
								for(var i = [], r = 0, o = t._first; o;)
									o instanceof n ? i[r++] = o : (e && (i[r++] = o),
										i = i.concat(d(o, e)),
										r = i.length),
									o = o._next;
								return i
							},
							f = o.getAllTweens = function(e) {
								return d(t._rootTimeline, e).concat(d(t._rootFramesTimeline, e))
							};
						o.killAll = function(t, n, i, r) {
								null == n && (n = !0),
									null == i && (i = !0);
								var o, a, s, l = f(0 != r),
									c = l.length,
									u = n && i && r;
								for(s = 0; s < c; s++)
									a = l[s],
									(u || a instanceof e || (o = a.target === a.vars.onComplete) && i || n && !o) && (t ? a.totalTime(a._reversed ? 0 : a.totalDuration()) : a._enabled(!1, !1))
							},
							o.killChildTweensOf = function(t, e) {
								if(null != t) {
									var r, a, u, h, d, f = s.tweenLookup;
									if("string" == typeof t && (t = n.selector(t) || t),
										l(t) && (t = i(t)),
										c(t))
										for(h = t.length; --h > -1;)
											o.killChildTweensOf(t[h], e);
									else {
										r = [];
										for(u in f)
											for(a = f[u].target.parentNode; a;)
												a === t && (r = r.concat(f[u].tweens)),
												a = a.parentNode;
										for(d = r.length,
											h = 0; h < d; h++)
											e && r[h].totalTime(r[h].totalDuration()),
											r[h]._enabled(!1, !1)
									}
								}
							};
						var p = function(t, n, i, r) {
							n = n !== !1,
								i = i !== !1,
								r = r !== !1;
							for(var o, a, s = f(r), l = n && i && r, c = s.length; --c > -1;)
								a = s[c],
								(l || a instanceof e || (o = a.target === a.vars.onComplete) && i || n && !o) && a.paused(t)
						};
						return o.pauseAll = function(t, e, n) {
								p(!0, t, e, n)
							},
							o.resumeAll = function(t, e, n) {
								p(!1, t, e, n)
							},
							o.globalTimeScale = function(e) {
								var i = t._rootTimeline,
									r = n.ticker.time;
								return arguments.length ? (e = e || a,
									i._startTime = r - (r - i._startTime) * i._timeScale / e,
									i = t._rootFramesTimeline,
									r = n.ticker.frame,
									i._startTime = r - (r - i._startTime) * i._timeScale / e,
									i._timeScale = t._rootTimeline._timeScale = e,
									e) : i._timeScale
							},
							u.progress = function(t, e) {
								return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
							},
							u.totalProgress = function(t, e) {
								return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
							},
							u.time = function(t, e) {
								return arguments.length ? (this._dirty && this.totalDuration(),
									t > this._duration && (t = this._duration),
									this._yoyo && 0 !== (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)),
									this.totalTime(t, e)) : this._time
							},
							u.duration = function(e) {
								return arguments.length ? t.prototype.duration.call(this, e) : this._duration
							},
							u.totalDuration = function(t) {
								return arguments.length ? this._repeat === -1 ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat,
										this._dirty = !1),
									this._totalDuration)
							},
							u.repeat = function(t) {
								return arguments.length ? (this._repeat = t,
									this._uncache(!0)) : this._repeat
							},
							u.repeatDelay = function(t) {
								return arguments.length ? (this._repeatDelay = t,
									this._uncache(!0)) : this._repeatDelay
							},
							u.yoyo = function(t) {
								return arguments.length ? (this._yoyo = t,
									this) : this._yoyo
							},
							o
					}, !0),
					a._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, n) {
						var i = function(t) {
								e.call(this, t),
									this._labels = {},
									this.autoRemoveChildren = this.vars.autoRemoveChildren === !0,
									this.smoothChildTiming = this.vars.smoothChildTiming === !0,
									this._sortChildren = !0,
									this._onUpdate = this.vars.onUpdate;
								var n, i, r = this.vars;
								for(i in r)
									n = r[i],
									c(n) && n.join("").indexOf("{self}") !== -1 && (r[i] = this._swapSelfInParams(n));
								c(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger)
							},
							r = 1e-10,
							o = n._internals,
							s = i._internals = {},
							l = o.isSelector,
							c = o.isArray,
							u = o.lazyTweens,
							h = o.lazyRender,
							d = a._gsDefine.globals,
							f = function(t) {
								var e, n = {};
								for(e in t)
									n[e] = t[e];
								return n
							},
							p = function(t, e, n) {
								var i, r, o = t.cycle;
								for(i in o)
									r = o[i],
									t[i] = "function" == typeof r ? r(n, e[n]) : r[n % r.length];
								delete t.cycle
							},
							m = s.pauseCallback = function() {},
							v = function(t) {
								var e, n = [],
									i = t.length;
								for(e = 0; e !== i; n.push(t[e++]))
								;
								return n
							},
							g = i.prototype = new e;
						return i.version = "1.19.1",
							g.constructor = i,
							g.kill()._gc = g._forcingPlayhead = g._hasPause = !1,
							g.to = function(t, e, i, r) {
								var o = i.repeat && d.TweenMax || n;
								return e ? this.add(new o(t, e, i), r) : this.set(t, i, r)
							},
							g.from = function(t, e, i, r) {
								return this.add((i.repeat && d.TweenMax || n).from(t, e, i), r)
							},
							g.fromTo = function(t, e, i, r, o) {
								var a = r.repeat && d.TweenMax || n;
								return e ? this.add(a.fromTo(t, e, i, r), o) : this.set(t, r, o)
							},
							g.staggerTo = function(t, e, r, o, a, s, c, u) {
								var h, d, m = new i({
										onComplete: s,
										onCompleteParams: c,
										callbackScope: u,
										smoothChildTiming: this.smoothChildTiming
									}),
									g = r.cycle;
								for("string" == typeof t && (t = n.selector(t) || t),
									t = t || [],
									l(t) && (t = v(t)),
									o = o || 0,
									o < 0 && (t = v(t),
										t.reverse(),
										o *= -1),
									d = 0; d < t.length; d++)
									h = f(r),
									h.startAt && (h.startAt = f(h.startAt),
										h.startAt.cycle && p(h.startAt, t, d)),
									g && (p(h, t, d),
										null != h.duration && (e = h.duration,
											delete h.duration)),
									m.to(t[d], e, h, d * o);
								return this.add(m, a)
							},
							g.staggerFrom = function(t, e, n, i, r, o, a, s) {
								return n.immediateRender = 0 != n.immediateRender,
									n.runBackwards = !0,
									this.staggerTo(t, e, n, i, r, o, a, s)
							},
							g.staggerFromTo = function(t, e, n, i, r, o, a, s, l) {
								return i.startAt = n,
									i.immediateRender = 0 != i.immediateRender && 0 != n.immediateRender,
									this.staggerTo(t, e, i, r, o, a, s, l)
							},
							g.call = function(t, e, i, r) {
								return this.add(n.delayedCall(0, t, e, i), r)
							},
							g.set = function(t, e, i) {
								return i = this._parseTimeOrLabel(i, 0, !0),
									null == e.immediateRender && (e.immediateRender = i === this._time && !this._paused),
									this.add(new n(t, 0, e), i)
							},
							i.exportRoot = function(t, e) {
								t = t || {},
									null == t.smoothChildTiming && (t.smoothChildTiming = !0);
								var r, o, a = new i(t),
									s = a._timeline;
								for(null == e && (e = !0),
									s._remove(a, !0),
									a._startTime = 0,
									a._rawPrevTime = a._time = a._totalTime = s._time,
									r = s._first; r;)
									o = r._next,
									e && r instanceof n && r.target === r.vars.onComplete || a.add(r, r._startTime - r._delay),
									r = o;
								return s.add(a, 0),
									a
							},
							g.add = function(r, o, a, s) {
								var l, u, h, d, f, p;
								if("number" != typeof o && (o = this._parseTimeOrLabel(o, 0, !0, r)), !(r instanceof t)) {
									if(r instanceof Array || r && r.push && c(r)) {
										for(a = a || "normal",
											s = s || 0,
											l = o,
											u = r.length,
											h = 0; h < u; h++)
											c(d = r[h]) && (d = new i({
												tweens: d
											})),
											this.add(d, l),
											"string" != typeof d && "function" != typeof d && ("sequence" === a ? l = d._startTime + d.totalDuration() / d._timeScale : "start" === a && (d._startTime -= d.delay())),
											l += s;
										return this._uncache(!0)
									}
									if("string" == typeof r)
										return this.addLabel(r, o);
									if("function" != typeof r)
										throw "Cannot add " + r + " into the timeline; it is not a tween, timeline, function, or string.";
									r = n.delayedCall(0, r)
								}
								if(e.prototype.add.call(this, r, o),
									(this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
									for(f = this,
										p = f.rawTime() > r._startTime; f._timeline;)
										p && f._timeline.smoothChildTiming ? f.totalTime(f._totalTime, !0) : f._gc && f._enabled(!0, !1),
										f = f._timeline;
								return this
							},
							g.remove = function(e) {
								if(e instanceof t) {
									this._remove(e, !1);
									var n = e._timeline = e.vars.useFrames ? t._rootFramesTimeline : t._rootTimeline;
									return e._startTime = (e._paused ? e._pauseTime : n._time) - (e._reversed ? e.totalDuration() - e._totalTime : e._totalTime) / e._timeScale,
										this
								}
								if(e instanceof Array || e && e.push && c(e)) {
									for(var i = e.length; --i > -1;)
										this.remove(e[i]);
									return this
								}
								return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e)
							},
							g._remove = function(t, n) {
								e.prototype._remove.call(this, t, n);
								var i = this._last;
								return i ? this._time > this.duration() && (this._time = this._duration,
										this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0,
									this
							},
							g.append = function(t, e) {
								return this.add(t, this._parseTimeOrLabel(null, e, !0, t))
							},
							g.insert = g.insertMultiple = function(t, e, n, i) {
								return this.add(t, e || 0, n, i)
							},
							g.appendMultiple = function(t, e, n, i) {
								return this.add(t, this._parseTimeOrLabel(null, e, !0, t), n, i)
							},
							g.addLabel = function(t, e) {
								return this._labels[t] = this._parseTimeOrLabel(e),
									this
							},
							g.addPause = function(t, e, i, r) {
								var o = n.delayedCall(0, m, i, r || this);
								return o.vars.onComplete = o.vars.onReverseComplete = e,
									o.data = "isPause",
									this._hasPause = !0,
									this.add(o, t)
							},
							g.removeLabel = function(t) {
								return delete this._labels[t],
									this
							},
							g.getLabelTime = function(t) {
								return null != this._labels[t] ? this._labels[t] : -1
							},
							g._parseTimeOrLabel = function(e, n, i, r) {
								var o;
								if(r instanceof t && r.timeline === this)
									this.remove(r);
								else if(r && (r instanceof Array || r.push && c(r)))
									for(o = r.length; --o > -1;)
										r[o] instanceof t && r[o].timeline === this && this.remove(r[o]);
								if("string" == typeof n)
									return this._parseTimeOrLabel(n, i && "number" == typeof e && null == this._labels[n] ? e - this.duration() : 0, i);
								if(n = n || 0,
									"string" != typeof e || !isNaN(e) && null == this._labels[e])
									null == e && (e = this.duration());
								else {
									if(o = e.indexOf("="),
										o === -1)
										return null == this._labels[e] ? i ? this._labels[e] = this.duration() + n : n : this._labels[e] + n;
									n = parseInt(e.charAt(o - 1) + "1", 10) * Number(e.substr(o + 1)),
										e = o > 1 ? this._parseTimeOrLabel(e.substr(0, o - 1), 0, i) : this.duration()
								}
								return Number(e) + n
							},
							g.seek = function(t, e) {
								return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), e !== !1)
							},
							g.stop = function() {
								return this.paused(!0)
							},
							g.gotoAndPlay = function(t, e) {
								return this.play(t, e)
							},
							g.gotoAndStop = function(t, e) {
								return this.pause(t, e)
							},
							g.render = function(t, e, n) {
								this._gc && this._enabled(!0, !1);
								var i, o, a, s, l, c, d, f = this._dirty ? this.totalDuration() : this._totalDuration,
									p = this._time,
									m = this._startTime,
									v = this._timeScale,
									g = this._paused;
								if(t >= f - 1e-7 && t >= 0)
									this._totalTime = this._time = f,
									this._reversed || this._hasPausedChild() || (o = !0,
										s = "onComplete",
										l = !!this._timeline.autoRemoveChildren,
										0 === this._duration && (t <= 0 && t >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === r) && this._rawPrevTime !== t && this._first && (l = !0,
											this._rawPrevTime > r && (s = "onReverseComplete"))),
									this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r,
									t = f + 1e-4;
								else if(t < 1e-7)
									if(this._totalTime = this._time = 0,
										(0 !== p || 0 === this._duration && this._rawPrevTime !== r && (this._rawPrevTime > 0 || t < 0 && this._rawPrevTime >= 0)) && (s = "onReverseComplete",
											o = this._reversed),
										t < 0)
										this._active = !1,
										this._timeline.autoRemoveChildren && this._reversed ? (l = o = !0,
											s = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (l = !0),
										this._rawPrevTime = t;
									else {
										if(this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r,
											0 === t && o)
											for(i = this._first; i && 0 === i._startTime;)
												i._duration || (o = !1),
												i = i._next;
										t = 0,
											this._initted || (l = !0)
									}
								else {
									if(this._hasPause && !this._forcingPlayhead && !e) {
										if(t >= p)
											for(i = this._first; i && i._startTime <= t && !c;)
												i._duration || "isPause" !== i.data || i.ratio || 0 === i._startTime && 0 === this._rawPrevTime || (c = i),
												i = i._next;
										else
											for(i = this._last; i && i._startTime >= t && !c;)
												i._duration || "isPause" === i.data && i._rawPrevTime > 0 && (c = i),
												i = i._prev;
										c && (this._time = t = c._startTime,
											this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
									}
									this._totalTime = this._time = this._rawPrevTime = t
								}
								if(this._time !== p && this._first || n || l || c) {
									if(this._initted || (this._initted = !0),
										this._active || !this._paused && this._time !== p && t > 0 && (this._active = !0),
										0 === p && this.vars.onStart && (0 === this._time && this._duration || e || this._callback("onStart")),
										d = this._time,
										d >= p)
										for(i = this._first; i && (a = i._next,
												d === this._time && (!this._paused || g));)
											(i._active || i._startTime <= d && !i._paused && !i._gc) && (c === i && this.pause(),
												i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (t - i._startTime) * i._timeScale, e, n) : i.render((t - i._startTime) * i._timeScale, e, n)),
											i = a;
									else
										for(i = this._last; i && (a = i._prev,
												d === this._time && (!this._paused || g));) {
											if(i._active || i._startTime <= p && !i._paused && !i._gc) {
												if(c === i) {
													for(c = i._prev; c && c.endTime() > this._time;)
														c.render(c._reversed ? c.totalDuration() - (t - c._startTime) * c._timeScale : (t - c._startTime) * c._timeScale, e, n),
														c = c._prev;
													c = null,
														this.pause()
												}
												i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (t - i._startTime) * i._timeScale, e, n) : i.render((t - i._startTime) * i._timeScale, e, n)
											}
											i = a
										}
									this._onUpdate && (e || (u.length && h(),
											this._callback("onUpdate"))),
										s && (this._gc || m !== this._startTime && v === this._timeScale || (0 === this._time || f >= this.totalDuration()) && (o && (u.length && h(),
											this._timeline.autoRemoveChildren && this._enabled(!1, !1),
											this._active = !1), !e && this.vars[s] && this._callback(s)))
								}
							},
							g._hasPausedChild = function() {
								for(var t = this._first; t;) {
									if(t._paused || t instanceof i && t._hasPausedChild())
										return !0;
									t = t._next
								}
								return !1
							},
							g.getChildren = function(t, e, i, r) {
								r = r || -9999999999;
								for(var o = [], a = this._first, s = 0; a;)
									a._startTime < r || (a instanceof n ? e !== !1 && (o[s++] = a) : (i !== !1 && (o[s++] = a),
										t !== !1 && (o = o.concat(a.getChildren(!0, e, i)),
											s = o.length))),
									a = a._next;
								return o
							},
							g.getTweensOf = function(t, e) {
								var i, r, o = this._gc,
									a = [],
									s = 0;
								for(o && this._enabled(!0, !0),
									i = n.getTweensOf(t),
									r = i.length; --r > -1;)
									(i[r].timeline === this || e && this._contains(i[r])) && (a[s++] = i[r]);
								return o && this._enabled(!1, !0),
									a
							},
							g.recent = function() {
								return this._recent
							},
							g._contains = function(t) {
								for(var e = t.timeline; e;) {
									if(e === this)
										return !0;
									e = e.timeline
								}
								return !1
							},
							g.shiftChildren = function(t, e, n) {
								n = n || 0;
								for(var i, r = this._first, o = this._labels; r;)
									r._startTime >= n && (r._startTime += t),
									r = r._next;
								if(e)
									for(i in o)
										o[i] >= n && (o[i] += t);
								return this._uncache(!0)
							},
							g._kill = function(t, e) {
								if(!t && !e)
									return this._enabled(!1, !1);
								for(var n = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), i = n.length, r = !1; --i > -1;)
									n[i]._kill(t, e) && (r = !0);
								return r
							},
							g.clear = function(t) {
								var e = this.getChildren(!1, !0, !0),
									n = e.length;
								for(this._time = this._totalTime = 0; --n > -1;)
									e[n]._enabled(!1, !1);
								return t !== !1 && (this._labels = {}),
									this._uncache(!0)
							},
							g.invalidate = function() {
								for(var e = this._first; e;)
									e.invalidate(),
									e = e._next;
								return t.prototype.invalidate.call(this)
							},
							g._enabled = function(t, n) {
								if(t === this._gc)
									for(var i = this._first; i;)
										i._enabled(t, !0),
										i = i._next;
								return e.prototype._enabled.call(this, t, n)
							},
							g.totalTime = function(e, n, i) {
								this._forcingPlayhead = !0;
								var r = t.prototype.totalTime.apply(this, arguments);
								return this._forcingPlayhead = !1,
									r
							},
							g.duration = function(t) {
								return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t),
									this) : (this._dirty && this.totalDuration(),
									this._duration)
							},
							g.totalDuration = function(t) {
								if(!arguments.length) {
									if(this._dirty) {
										for(var e, n, i = 0, r = this._last, o = 999999999999; r;)
											e = r._prev,
											r._dirty && r.totalDuration(),
											r._startTime > o && this._sortChildren && !r._paused ? this.add(r, r._startTime - r._delay) : o = r._startTime,
											r._startTime < 0 && !r._paused && (i -= r._startTime,
												this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale),
												this.shiftChildren(-r._startTime, !1, -9999999999),
												o = 0),
											n = r._startTime + r._totalDuration / r._timeScale,
											n > i && (i = n),
											r = e;
										this._duration = this._totalDuration = i,
											this._dirty = !1
									}
									return this._totalDuration
								}
								return t && this.totalDuration() ? this.timeScale(this._totalDuration / t) : this
							},
							g.paused = function(e) {
								if(!e)
									for(var n = this._first, i = this._time; n;)
										n._startTime === i && "isPause" === n.data && (n._rawPrevTime = 0),
										n = n._next;
								return t.prototype.paused.apply(this, arguments)
							},
							g.usesFrames = function() {
								for(var e = this._timeline; e._timeline;)
									e = e._timeline;
								return e === t._rootFramesTimeline
							},
							g.rawTime = function(t) {
								return t && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(t) - this._startTime) * this._timeScale
							},
							i
					}, !0),
					a._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(t, e, n) {
						var i = function(e) {
								t.call(this, e),
									this._repeat = this.vars.repeat || 0,
									this._repeatDelay = this.vars.repeatDelay || 0,
									this._cycle = 0,
									this._yoyo = this.vars.yoyo === !0,
									this._dirty = !0
							},
							r = 1e-10,
							o = e._internals,
							s = o.lazyTweens,
							l = o.lazyRender,
							c = a._gsDefine.globals,
							u = new n(null, null, 1, 0),
							h = i.prototype = new t;
						return h.constructor = i,
							h.kill()._gc = !1,
							i.version = "1.19.1",
							h.invalidate = function() {
								return this._yoyo = this.vars.yoyo === !0,
									this._repeat = this.vars.repeat || 0,
									this._repeatDelay = this.vars.repeatDelay || 0,
									this._uncache(!0),
									t.prototype.invalidate.call(this)
							},
							h.addCallback = function(t, n, i, r) {
								return this.add(e.delayedCall(0, t, i, r), n)
							},
							h.removeCallback = function(t, e) {
								if(t)
									if(null == e)
										this._kill(null, t);
									else
										for(var n = this.getTweensOf(t, !1), i = n.length, r = this._parseTimeOrLabel(e); --i > -1;)
											n[i]._startTime === r && n[i]._enabled(!1, !1);
								return this
							},
							h.removePause = function(e) {
								return this.removeCallback(t._internals.pauseCallback, e)
							},
							h.tweenTo = function(t, n) {
								n = n || {};
								var i, r, o, a = {
										ease: u,
										useFrames: this.usesFrames(),
										immediateRender: !1
									},
									s = n.repeat && c.TweenMax || e;
								for(r in n)
									a[r] = n[r];
								return a.time = this._parseTimeOrLabel(t),
									i = Math.abs(Number(a.time) - this._time) / this._timeScale || .001,
									o = new s(this, i, a),
									a.onStart = function() {
										o.target.paused(!0),
											o.vars.time !== o.target.time() && i === o.duration() && o.duration(Math.abs(o.vars.time - o.target.time()) / o.target._timeScale),
											n.onStart && n.onStart.apply(n.onStartScope || n.callbackScope || o, n.onStartParams || [])
									},
									o
							},
							h.tweenFromTo = function(t, e, n) {
								n = n || {},
									t = this._parseTimeOrLabel(t),
									n.startAt = {
										onComplete: this.seek,
										onCompleteParams: [t],
										callbackScope: this
									},
									n.immediateRender = n.immediateRender !== !1;
								var i = this.tweenTo(e, n);
								return i.duration(Math.abs(i.vars.time - t) / this._timeScale || .001)
							},
							h.render = function(t, e, n) {
								this._gc && this._enabled(!0, !1);
								var i, o, a, c, u, h, d, f, p = this._dirty ? this.totalDuration() : this._totalDuration,
									m = this._duration,
									v = this._time,
									g = this._totalTime,
									_ = this._startTime,
									y = this._timeScale,
									b = this._rawPrevTime,
									x = this._paused,
									w = this._cycle;
								if(t >= p - 1e-7 && t >= 0)
									this._locked || (this._totalTime = p,
										this._cycle = this._repeat),
									this._reversed || this._hasPausedChild() || (o = !0,
										c = "onComplete",
										u = !!this._timeline.autoRemoveChildren,
										0 === this._duration && (t <= 0 && t >= -1e-7 || b < 0 || b === r) && b !== t && this._first && (u = !0,
											b > r && (c = "onReverseComplete"))),
									this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r,
									this._yoyo && 0 !== (1 & this._cycle) ? this._time = t = 0 : (this._time = m,
										t = m + 1e-4);
								else if(t < 1e-7)
									if(this._locked || (this._totalTime = this._cycle = 0),
										this._time = 0,
										(0 !== v || 0 === m && b !== r && (b > 0 || t < 0 && b >= 0) && !this._locked) && (c = "onReverseComplete",
											o = this._reversed),
										t < 0)
										this._active = !1,
										this._timeline.autoRemoveChildren && this._reversed ? (u = o = !0,
											c = "onReverseComplete") : b >= 0 && this._first && (u = !0),
										this._rawPrevTime = t;
									else {
										if(this._rawPrevTime = m || !e || t || this._rawPrevTime === t ? t : r,
											0 === t && o)
											for(i = this._first; i && 0 === i._startTime;)
												i._duration || (o = !1),
												i = i._next;
										t = 0,
											this._initted || (u = !0)
									}
								else if(0 === m && b < 0 && (u = !0),
									this._time = this._rawPrevTime = t,
									this._locked || (this._totalTime = t,
										0 !== this._repeat && (h = m + this._repeatDelay,
											this._cycle = this._totalTime / h >> 0,
											0 !== this._cycle && this._cycle === this._totalTime / h && g <= t && this._cycle--,
											this._time = this._totalTime - this._cycle * h,
											this._yoyo && 0 !== (1 & this._cycle) && (this._time = m - this._time),
											this._time > m ? (this._time = m,
												t = m + 1e-4) : this._time < 0 ? this._time = t = 0 : t = this._time)),
									this._hasPause && !this._forcingPlayhead && !e && t < m) {
									if(t = this._time,
										t >= v || this._repeat && w !== this._cycle)
										for(i = this._first; i && i._startTime <= t && !d;)
											i._duration || "isPause" !== i.data || i.ratio || 0 === i._startTime && 0 === this._rawPrevTime || (d = i),
											i = i._next;
									else
										for(i = this._last; i && i._startTime >= t && !d;)
											i._duration || "isPause" === i.data && i._rawPrevTime > 0 && (d = i),
											i = i._prev;
									d && (this._time = t = d._startTime,
										this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
								}
								if(this._cycle !== w && !this._locked) {
									var T = this._yoyo && 0 !== (1 & w),
										M = T === (this._yoyo && 0 !== (1 & this._cycle)),
										E = this._totalTime,
										S = this._cycle,
										X = this._rawPrevTime,
										A = this._time;
									if(this._totalTime = w * m,
										this._cycle < w ? T = !T : this._totalTime += m,
										this._time = v,
										this._rawPrevTime = 0 === m ? b - 1e-4 : b,
										this._cycle = w,
										this._locked = !0,
										v = T ? 0 : m,
										this.render(v, e, 0 === m),
										e || this._gc || this.vars.onRepeat && (this._cycle = S,
											this._locked = !1,
											this._callback("onRepeat")),
										v !== this._time)
										return;
									if(M && (this._cycle = w,
											this._locked = !0,
											v = T ? m + 1e-4 : -1e-4,
											this.render(v, !0, !1)),
										this._locked = !1,
										this._paused && !x)
										return;
									this._time = A,
										this._totalTime = E,
										this._cycle = S,
										this._rawPrevTime = X
								}
								if(!(this._time !== v && this._first || n || u || d))
									return void(g !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate")));
								if(this._initted || (this._initted = !0),
									this._active || !this._paused && this._totalTime !== g && t > 0 && (this._active = !0),
									0 === g && this.vars.onStart && (0 === this._totalTime && this._totalDuration || e || this._callback("onStart")),
									f = this._time,
									f >= v)
									for(i = this._first; i && (a = i._next,
											f === this._time && (!this._paused || x));)
										(i._active || i._startTime <= this._time && !i._paused && !i._gc) && (d === i && this.pause(),
											i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (t - i._startTime) * i._timeScale, e, n) : i.render((t - i._startTime) * i._timeScale, e, n)),
										i = a;
								else
									for(i = this._last; i && (a = i._prev,
											f === this._time && (!this._paused || x));) {
										if(i._active || i._startTime <= v && !i._paused && !i._gc) {
											if(d === i) {
												for(d = i._prev; d && d.endTime() > this._time;)
													d.render(d._reversed ? d.totalDuration() - (t - d._startTime) * d._timeScale : (t - d._startTime) * d._timeScale, e, n),
													d = d._prev;
												d = null,
													this.pause()
											}
											i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (t - i._startTime) * i._timeScale, e, n) : i.render((t - i._startTime) * i._timeScale, e, n)
										}
										i = a
									}
								this._onUpdate && (e || (s.length && l(),
										this._callback("onUpdate"))),
									c && (this._locked || this._gc || _ !== this._startTime && y === this._timeScale || (0 === this._time || p >= this.totalDuration()) && (o && (s.length && l(),
										this._timeline.autoRemoveChildren && this._enabled(!1, !1),
										this._active = !1), !e && this.vars[c] && this._callback(c)))
							},
							h.getActive = function(t, e, n) {
								null == t && (t = !0),
									null == e && (e = !0),
									null == n && (n = !1);
								var i, r, o = [],
									a = this.getChildren(t, e, n),
									s = 0,
									l = a.length;
								for(i = 0; i < l; i++)
									r = a[i],
									r.isActive() && (o[s++] = r);
								return o
							},
							h.getLabelAfter = function(t) {
								t || 0 !== t && (t = this._time);
								var e, n = this.getLabelsArray(),
									i = n.length;
								for(e = 0; e < i; e++)
									if(n[e].time > t)
										return n[e].name;
								return null
							},
							h.getLabelBefore = function(t) {
								null == t && (t = this._time);
								for(var e = this.getLabelsArray(), n = e.length; --n > -1;)
									if(e[n].time < t)
										return e[n].name;
								return null
							},
							h.getLabelsArray = function() {
								var t, e = [],
									n = 0;
								for(t in this._labels)
									e[n++] = {
										time: this._labels[t],
										name: t
									};
								return e.sort(function(t, e) {
										return t.time - e.time
									}),
									e
							},
							h.invalidate = function() {
								return this._locked = !1,
									t.prototype.invalidate.call(this)
							},
							h.progress = function(t, e) {
								return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
							},
							h.totalProgress = function(t, e) {
								return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
							},
							h.totalDuration = function(e) {
								return arguments.length ? this._repeat !== -1 && e ? this.timeScale(this.totalDuration() / e) : this : (this._dirty && (t.prototype.totalDuration.call(this),
										this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat),
									this._totalDuration)
							},
							h.time = function(t, e) {
								return arguments.length ? (this._dirty && this.totalDuration(),
									t > this._duration && (t = this._duration),
									this._yoyo && 0 !== (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)),
									this.totalTime(t, e)) : this._time
							},
							h.repeat = function(t) {
								return arguments.length ? (this._repeat = t,
									this._uncache(!0)) : this._repeat
							},
							h.repeatDelay = function(t) {
								return arguments.length ? (this._repeatDelay = t,
									this._uncache(!0)) : this._repeatDelay
							},
							h.yoyo = function(t) {
								return arguments.length ? (this._yoyo = t,
									this) : this._yoyo
							},
							h.currentLabel = function(t) {
								return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8)
							},
							i
					}, !0),
					function() {
						var t = 180 / Math.PI,
							e = [],
							n = [],
							i = [],
							r = {},
							o = a._gsDefine.globals,
							s = function(t, e, n, i) {
								n === i && (n = i - (i - e) / 1e6),
									t === e && (e = t + (n - t) / 1e6),
									this.a = t,
									this.b = e,
									this.c = n,
									this.d = i,
									this.da = i - t,
									this.ca = n - t,
									this.ba = e - t
							},
							l = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
							c = function(t, e, n, i) {
								var r = {
										a: t
									},
									o = {},
									a = {},
									s = {
										c: i
									},
									l = (t + e) / 2,
									c = (e + n) / 2,
									u = (n + i) / 2,
									h = (l + c) / 2,
									d = (c + u) / 2,
									f = (d - h) / 8;
								return r.b = l + (t - l) / 4,
									o.b = h + f,
									r.c = o.a = (r.b + o.b) / 2,
									o.c = a.a = (h + d) / 2,
									a.b = d - f,
									s.b = u + (i - u) / 4,
									a.c = s.a = (a.b + s.b) / 2, [r, o, a, s]
							},
							u = function(t, r, o, a, s) {
								var l, u, h, d, f, p, m, v, g, _, y, b, x, w = t.length - 1,
									T = 0,
									M = t[0].a;
								for(l = 0; l < w; l++)
									f = t[T],
									u = f.a,
									h = f.d,
									d = t[T + 1].d,
									s ? (y = e[l],
										b = n[l],
										x = (b + y) * r * .25 / (a ? .5 : i[l] || .5),
										p = h - (h - u) * (a ? .5 * r : 0 !== y ? x / y : 0),
										m = h + (d - h) * (a ? .5 * r : 0 !== b ? x / b : 0),
										v = h - (p + ((m - p) * (3 * y / (y + b) + .5) / 4 || 0))) : (p = h - (h - u) * r * .5,
										m = h + (d - h) * r * .5,
										v = h - (p + m) / 2),
									p += v,
									m += v,
									f.c = g = p,
									0 !== l ? f.b = M : f.b = M = f.a + .6 * (f.c - f.a),
									f.da = h - u,
									f.ca = g - u,
									f.ba = M - u,
									o ? (_ = c(u, M, g, h),
										t.splice(T, 1, _[0], _[1], _[2], _[3]),
										T += 4) : T++,
									M = m;
								f = t[T],
									f.b = M,
									f.c = M + .4 * (f.d - M),
									f.da = f.d - f.a,
									f.ca = f.c - f.a,
									f.ba = M - f.a,
									o && (_ = c(f.a, M, f.c, f.d),
										t.splice(T, 1, _[0], _[1], _[2], _[3]))
							},
							h = function(t, i, r, o) {
								var a, l, c, u, h, d, f = [];
								if(o)
									for(t = [o].concat(t),
										l = t.length; --l > -1;)
										"string" == typeof(d = t[l][i]) && "=" === d.charAt(1) && (t[l][i] = o[i] + Number(d.charAt(0) + d.substr(2)));
								if(a = t.length - 2,
									a < 0)
									return f[0] = new s(t[0][i], 0, 0, t[a < -1 ? 0 : 1][i]),
										f;
								for(l = 0; l < a; l++)
									c = t[l][i],
									u = t[l + 1][i],
									f[l] = new s(c, 0, 0, u),
									r && (h = t[l + 2][i],
										e[l] = (e[l] || 0) + (u - c) * (u - c),
										n[l] = (n[l] || 0) + (h - u) * (h - u));
								return f[l] = new s(t[l][i], 0, 0, t[l + 1][i]),
									f
							},
							d = function(t, o, a, s, c, d) {
								var f, p, m, v, g, _, y, b, x = {},
									w = [],
									T = d || t[0];
								c = "string" == typeof c ? "," + c + "," : l,
									null == o && (o = 1);
								for(p in t[0])
									w.push(p);
								if(t.length > 1) {
									for(b = t[t.length - 1],
										y = !0,
										f = w.length; --f > -1;)
										if(p = w[f],
											Math.abs(T[p] - b[p]) > .05) {
											y = !1;
											break
										}
									y && (t = t.concat(),
										d && t.unshift(d),
										t.push(t[1]),
										d = t[t.length - 3])
								}
								for(e.length = n.length = i.length = 0,
									f = w.length; --f > -1;)
									p = w[f],
									r[p] = c.indexOf("," + p + ",") !== -1,
									x[p] = h(t, p, r[p], d);
								for(f = e.length; --f > -1;)
									e[f] = Math.sqrt(e[f]),
									n[f] = Math.sqrt(n[f]);
								if(!s) {
									for(f = w.length; --f > -1;)
										if(r[p])
											for(m = x[w[f]],
												_ = m.length - 1,
												v = 0; v < _; v++)
												g = m[v + 1].da / n[v] + m[v].da / e[v] || 0,
												i[v] = (i[v] || 0) + g * g;
									for(f = i.length; --f > -1;)
										i[f] = Math.sqrt(i[f])
								}
								for(f = w.length,
									v = a ? 4 : 1; --f > -1;)
									p = w[f],
									m = x[p],
									u(m, o, a, s, r[p]),
									y && (m.splice(0, v),
										m.splice(m.length - v, v));
								return x
							},
							f = function(t, e, n) {
								e = e || "soft";
								var i, r, o, a, l, c, u, h, d, f, p, m = {},
									v = "cubic" === e ? 3 : 2,
									g = "soft" === e,
									_ = [];
								if(g && n && (t = [n].concat(t)),
									null == t || t.length < v + 1)
									throw "invalid Bezier data";
								for(d in t[0])
									_.push(d);
								for(c = _.length; --c > -1;) {
									for(d = _[c],
										m[d] = l = [],
										f = 0,
										h = t.length,
										u = 0; u < h; u++)
										i = null == n ? t[u][d] : "string" == typeof(p = t[u][d]) && "=" === p.charAt(1) ? n[d] + Number(p.charAt(0) + p.substr(2)) : Number(p),
										g && u > 1 && u < h - 1 && (l[f++] = (i + l[f - 2]) / 2),
										l[f++] = i;
									for(h = f - v + 1,
										f = 0,
										u = 0; u < h; u += v)
										i = l[u],
										r = l[u + 1],
										o = l[u + 2],
										a = 2 === v ? 0 : l[u + 3],
										l[f++] = p = 3 === v ? new s(i, r, o, a) : new s(i, (2 * r + i) / 3, (2 * r + o) / 3, o);
									l.length = f
								}
								return m
							},
							p = function(t, e, n) {
								for(var i, r, o, a, s, l, c, u, h, d, f, p = 1 / n, m = t.length; --m > -1;)
									for(d = t[m],
										o = d.a,
										a = d.d - o,
										s = d.c - o,
										l = d.b - o,
										i = r = 0,
										u = 1; u <= n; u++)
										c = p * u,
										h = 1 - c,
										i = r - (r = (c * c * a + 3 * h * (c * s + h * l)) * c),
										f = m * n + u - 1,
										e[f] = (e[f] || 0) + i * i
							},
							m = function(t, e) {
								e = e >> 0 || 6;
								var n, i, r, o, a = [],
									s = [],
									l = 0,
									c = 0,
									u = e - 1,
									h = [],
									d = [];
								for(n in t)
									p(t[n], a, e);
								for(r = a.length,
									i = 0; i < r; i++)
									l += Math.sqrt(a[i]),
									o = i % e,
									d[o] = l,
									o === u && (c += l,
										o = i / e >> 0,
										h[o] = d,
										s[o] = c,
										l = 0,
										d = []);
								return {
									length: c,
									lengths: s,
									segments: h
								}
							},
							v = a._gsDefine.plugin({
								propName: "bezier",
								priority: -1,
								version: "1.3.7",
								API: 2,
								global: !0,
								init: function(t, e, n) {
									this._target = t,
										e instanceof Array && (e = {
											values: e
										}),
										this._func = {},
										this._mod = {},
										this._props = [],
										this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
									var i, r, o, a, s, l = e.values || [],
										c = {},
										u = l[0],
										h = e.autoRotate || n.vars.orientToBezier;
									this._autoRotate = h ? h instanceof Array ? h : [
										["x", "y", "rotation", h === !0 ? 0 : Number(h) || 0]
									] : null;
									for(i in u)
										this._props.push(i);
									for(o = this._props.length; --o > -1;)
										i = this._props[o],
										this._overwriteProps.push(i),
										r = this._func[i] = "function" == typeof t[i],
										c[i] = r ? t[i.indexOf("set") || "function" != typeof t["get" + i.substr(3)] ? i : "get" + i.substr(3)]() : parseFloat(t[i]),
										s || c[i] !== l[0][i] && (s = c);
									if(this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? d(l, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, s) : f(l, e.type, c),
										this._segCount = this._beziers[i].length,
										this._timeRes) {
										var p = m(this._beziers, this._timeRes);
										this._length = p.length,
											this._lengths = p.lengths,
											this._segments = p.segments,
											this._l1 = this._li = this._s1 = this._si = 0,
											this._l2 = this._lengths[0],
											this._curSeg = this._segments[0],
											this._s2 = this._curSeg[0],
											this._prec = 1 / this._curSeg.length
									}
									if(h = this._autoRotate)
										for(this._initialRotations = [],
											h[0] instanceof Array || (this._autoRotate = h = [h]),
											o = h.length; --o > -1;) {
											for(a = 0; a < 3; a++)
												i = h[o][a],
												this._func[i] = "function" == typeof t[i] && t[i.indexOf("set") || "function" != typeof t["get" + i.substr(3)] ? i : "get" + i.substr(3)];
											i = h[o][2],
												this._initialRotations[o] = (this._func[i] ? this._func[i].call(this._target) : this._target[i]) || 0,
												this._overwriteProps.push(i)
										}
									return this._startRatio = n.vars.runBackwards ? 1 : 0, !0
								},
								set: function(e) {
									var n, i, r, o, a, s, l, c, u, h, d = this._segCount,
										f = this._func,
										p = this._target,
										m = e !== this._startRatio;
									if(this._timeRes) {
										if(u = this._lengths,
											h = this._curSeg,
											e *= this._length,
											r = this._li,
											e > this._l2 && r < d - 1) {
											for(c = d - 1; r < c && (this._l2 = u[++r]) <= e;)
											;
											this._l1 = u[r - 1],
												this._li = r,
												this._curSeg = h = this._segments[r],
												this._s2 = h[this._s1 = this._si = 0]
										} else if(e < this._l1 && r > 0) {
											for(; r > 0 && (this._l1 = u[--r]) >= e;)
											;
											0 === r && e < this._l1 ? this._l1 = 0 : r++,
												this._l2 = u[r],
												this._li = r,
												this._curSeg = h = this._segments[r],
												this._s1 = h[(this._si = h.length - 1) - 1] || 0,
												this._s2 = h[this._si]
										}
										if(n = r,
											e -= this._l1,
											r = this._si,
											e > this._s2 && r < h.length - 1) {
											for(c = h.length - 1; r < c && (this._s2 = h[++r]) <= e;)
											;
											this._s1 = h[r - 1],
												this._si = r
										} else if(e < this._s1 && r > 0) {
											for(; r > 0 && (this._s1 = h[--r]) >= e;)
											;
											0 === r && e < this._s1 ? this._s1 = 0 : r++,
												this._s2 = h[r],
												this._si = r
										}
										s = (r + (e - this._s1) / (this._s2 - this._s1)) * this._prec || 0
									} else
										n = e < 0 ? 0 : e >= 1 ? d - 1 : d * e >> 0,
										s = (e - n * (1 / d)) * d;
									for(i = 1 - s,
										r = this._props.length; --r > -1;)
										o = this._props[r],
										a = this._beziers[o][n],
										l = (s * s * a.da + 3 * i * (s * a.ca + i * a.ba)) * s + a.a,
										this._mod[o] && (l = this._mod[o](l, p)),
										f[o] ? p[o](l) : p[o] = l;
									if(this._autoRotate) {
										var v, g, _, y, b, x, w, T = this._autoRotate;
										for(r = T.length; --r > -1;)
											o = T[r][2],
											x = T[r][3] || 0,
											w = T[r][4] === !0 ? 1 : t,
											a = this._beziers[T[r][0]],
											v = this._beziers[T[r][1]],
											a && v && (a = a[n],
												v = v[n],
												g = a.a + (a.b - a.a) * s,
												y = a.b + (a.c - a.b) * s,
												g += (y - g) * s,
												y += (a.c + (a.d - a.c) * s - y) * s,
												_ = v.a + (v.b - v.a) * s,
												b = v.b + (v.c - v.b) * s,
												_ += (b - _) * s,
												b += (v.c + (v.d - v.c) * s - b) * s,
												l = m ? Math.atan2(b - _, y - g) * w + x : this._initialRotations[r],
												this._mod[o] && (l = this._mod[o](l, p)),
												f[o] ? p[o](l) : p[o] = l)
									}
								}
							}),
							g = v.prototype;
						v.bezierThrough = d,
							v.cubicToQuadratic = c,
							v._autoCSS = !0,
							v.quadraticToCubic = function(t, e, n) {
								return new s(t, (2 * e + t) / 3, (2 * e + n) / 3, n)
							},
							v._cssRegister = function() {
								var t = o.CSSPlugin;
								if(t) {
									var e = t._internals,
										n = e._parseToProxy,
										i = e._setPluginRatio,
										r = e.CSSPropTween;
									e._registerComplexSpecialProp("bezier", {
										parser: function(t, e, o, a, s, l) {
											e instanceof Array && (e = {
													values: e
												}),
												l = new v;
											var c, u, h, d = e.values,
												f = d.length - 1,
												p = [],
												m = {};
											if(f < 0)
												return s;
											for(c = 0; c <= f; c++)
												h = n(t, d[c], a, s, l, f !== c),
												p[c] = h.end;
											for(u in e)
												m[u] = e[u];
											return m.values = p,
												s = new r(t, "bezier", 0, 0, h.pt, 2),
												s.data = h,
												s.plugin = l,
												s.setRatio = i,
												0 === m.autoRotate && (m.autoRotate = !0), !m.autoRotate || m.autoRotate instanceof Array || (c = m.autoRotate === !0 ? 0 : Number(m.autoRotate),
													m.autoRotate = null != h.end.left ? [
														["left", "top", "rotation", c, !1]
													] : null != h.end.x && [
														["x", "y", "rotation", c, !1]
													]),
												m.autoRotate && (a._transform || a._enableTransforms(!1),
													h.autoRotate = a._target._gsTransform,
													h.proxy.rotation = h.autoRotate.rotation || 0,
													a._overwriteProps.push("rotation")),
												l._onInitTween(h.proxy, m, a._tween),
												s
										}
									})
								}
							},
							g._mod = function(t) {
								for(var e, n = this._overwriteProps, i = n.length; --i > -1;)
									e = t[n[i]],
									e && "function" == typeof e && (this._mod[n[i]] = e)
							},
							g._kill = function(t) {
								var e, n, i = this._props;
								for(e in this._beziers)
									if(e in t)
										for(delete this._beziers[e],
											delete this._func[e],
											n = i.length; --n > -1;)
											i[n] === e && i.splice(n, 1);
								if(i = this._autoRotate)
									for(n = i.length; --n > -1;)
										t[i[n][2]] && i.splice(n, 1);
								return this._super._kill.call(this, t)
							}
					}(),
					a._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(t, e) {
						var n, i, r, o, s = function() {
								t.call(this, "css"),
									this._overwriteProps.length = 0,
									this.setRatio = s.prototype.setRatio
							},
							l = a._gsDefine.globals,
							c = {},
							u = s.prototype = new t("css");
						u.constructor = s,
							s.version = "1.19.1",
							s.API = 2,
							s.defaultTransformPerspective = 0,
							s.defaultSkewType = "compensated",
							s.defaultSmoothOrigin = !0,
							u = "px",
							s.suffixMap = {
								top: u,
								right: u,
								bottom: u,
								left: u,
								width: u,
								height: u,
								fontSize: u,
								padding: u,
								margin: u,
								perspective: u,
								lineHeight: ""
							};
						var h, d, f, p, m, v, g, _, y = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
							b = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
							x = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
							w = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
							T = /(?:\d|\-|\+|=|#|\.)*/g,
							M = /opacity *= *([^)]*)/i,
							E = /opacity:([^;]*)/i,
							S = /alpha\(opacity *=.+?\)/i,
							X = /^(rgb|hsl)/,
							A = /([A-Z])/g,
							P = /-([a-z])/gi,
							R = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
							O = function(t, e) {
								return e.toUpperCase()
							},
							C = /(?:Left|Right|Width)/i,
							L = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
							I = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
							D = /,(?=[^\)]*(?:\(|$))/gi,
							B = /[\s,\(]/i,
							F = Math.PI / 180,
							z = 180 / Math.PI,
							N = {},
							k = {
								style: {}
							},
							U = a.document || {
								createElement: function() {
									return k
								}
							},
							j = function(t, e) {
								return U.createElementNS ? U.createElementNS(e || "http://www.w3.org/1999/xhtml", t) : U.createElement(t)
							},
							V = j("div"),
							G = j("img"),
							H = s._internals = {
								_specialProps: c
							},
							W = (a.navigator || {}).userAgent || "",
							Y = function() {
								var t = W.indexOf("Android"),
									e = j("a");
								return f = W.indexOf("Safari") !== -1 && W.indexOf("Chrome") === -1 && (t === -1 || parseFloat(W.substr(t + 8, 2)) > 3),
									m = f && parseFloat(W.substr(W.indexOf("Version/") + 8, 2)) < 6,
									p = W.indexOf("Firefox") !== -1,
									(/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(W) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(W)) && (v = parseFloat(RegExp.$1)), !!e && (e.style.cssText = "top:1px;opacity:.55;",
										/^0.55/.test(e.style.opacity))
							}(),
							q = function(t) {
								return M.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
							},
							Z = function(t) {
								a.console && console.log(t)
							},
							Q = "",
							J = "",
							K = function(t, e) {
								e = e || V;
								var n, i, r = e.style;
								if(void 0 !== r[t])
									return t;
								for(t = t.charAt(0).toUpperCase() + t.substr(1),
									n = ["O", "Moz", "ms", "Ms", "Webkit"],
									i = 5; --i > -1 && void 0 === r[n[i] + t];)
								;
								return i >= 0 ? (J = 3 === i ? "ms" : n[i],
									Q = "-" + J.toLowerCase() + "-",
									J + t) : null
							},
							$ = U.defaultView ? U.defaultView.getComputedStyle : function() {},
							tt = s.getStyle = function(t, e, n, i, r) {
								var o;
								return Y || "opacity" !== e ? (!i && t.style[e] ? o = t.style[e] : (n = n || $(t)) ? o = n[e] || n.getPropertyValue(e) || n.getPropertyValue(e.replace(A, "-$1").toLowerCase()) : t.currentStyle && (o = t.currentStyle[e]),
									null == r || o && "none" !== o && "auto" !== o && "auto auto" !== o ? o : r) : q(t)
							},
							et = H.convertToPixels = function(t, n, i, r, o) {
								if("px" === r || !r)
									return i;
								if("auto" === r || !i)
									return 0;
								var a, l, c, u = C.test(n),
									h = t,
									d = V.style,
									f = i < 0,
									p = 1 === i;
								if(f && (i = -i),
									p && (i *= 100),
									"%" === r && n.indexOf("border") !== -1)
									a = i / 100 * (u ? t.clientWidth : t.clientHeight);
								else {
									if(d.cssText = "border:0 solid red;position:" + tt(t, "position") + ";line-height:0;",
										"%" !== r && h.appendChild && "v" !== r.charAt(0) && "rem" !== r)
										d[u ? "borderLeftWidth" : "borderTopWidth"] = i + r;
									else {
										if(h = t.parentNode || U.body,
											l = h._gsCache,
											c = e.ticker.frame,
											l && u && l.time === c)
											return l.width * i / 100;
										d[u ? "width" : "height"] = i + r
									}
									h.appendChild(V),
										a = parseFloat(V[u ? "offsetWidth" : "offsetHeight"]),
										h.removeChild(V),
										u && "%" === r && s.cacheWidths !== !1 && (l = h._gsCache = h._gsCache || {},
											l.time = c,
											l.width = a / i * 100),
										0 !== a || o || (a = et(t, n, i, r, !0))
								}
								return p && (a /= 100),
									f ? -a : a
							},
							nt = H.calculateOffset = function(t, e, n) {
								if("absolute" !== tt(t, "position", n))
									return 0;
								var i = "left" === e ? "Left" : "Top",
									r = tt(t, "margin" + i, n);
								return t["offset" + i] - (et(t, e, parseFloat(r), r.replace(T, "")) || 0)
							},
							it = function(t, e) {
								var n, i, r, o = {};
								if(e = e || $(t, null))
									if(n = e.length)
										for(; --n > -1;)
											r = e[n],
											r.indexOf("-transform") !== -1 && Rt !== r || (o[r.replace(P, O)] = e.getPropertyValue(r));
									else
										for(n in e)
											n.indexOf("Transform") !== -1 && Pt !== n || (o[n] = e[n]);
								else if(e = t.currentStyle || t.style)
									for(n in e)
										"string" == typeof n && void 0 === o[n] && (o[n.replace(P, O)] = e[n]);
								return Y || (o.opacity = q(t)),
									i = Gt(t, e, !1),
									o.rotation = i.rotation,
									o.skewX = i.skewX,
									o.scaleX = i.scaleX,
									o.scaleY = i.scaleY,
									o.x = i.x,
									o.y = i.y,
									Ct && (o.z = i.z,
										o.rotationX = i.rotationX,
										o.rotationY = i.rotationY,
										o.scaleZ = i.scaleZ),
									o.filters && delete o.filters,
									o
							},
							rt = function(t, e, n, i, r) {
								var o, a, s, l = {},
									c = t.style;
								for(a in n)
									"cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (o = n[a]) || r && r[a]) && a.indexOf("Origin") === -1 && ("number" != typeof o && "string" != typeof o || (l[a] = "auto" !== o || "left" !== a && "top" !== a ? "" !== o && "auto" !== o && "none" !== o || "string" != typeof e[a] || "" === e[a].replace(w, "") ? o : 0 : nt(t, a),
										void 0 !== c[a] && (s = new yt(c, a, c[a], s))));
								if(i)
									for(a in i)
										"className" !== a && (l[a] = i[a]);
								return {
									difs: l,
									firstMPT: s
								}
							},
							ot = {
								width: ["Left", "Right"],
								height: ["Top", "Bottom"]
							},
							at = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
							st = function(t, e, n) {
								if("svg" === (t.nodeName + "").toLowerCase())
									return(n || $(t))[e] || 0;
								if(t.getCTM && Ut(t))
									return t.getBBox()[e] || 0;
								var i = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
									r = ot[e],
									o = r.length;
								for(n = n || $(t, null); --o > -1;)
									i -= parseFloat(tt(t, "padding" + r[o], n, !0)) || 0,
									i -= parseFloat(tt(t, "border" + r[o] + "Width", n, !0)) || 0;
								return i
							},
							lt = function(t, e) {
								if("contain" === t || "auto" === t || "auto auto" === t)
									return t + " ";
								null != t && "" !== t || (t = "0 0");
								var n, i = t.split(" "),
									r = t.indexOf("left") !== -1 ? "0%" : t.indexOf("right") !== -1 ? "100%" : i[0],
									o = t.indexOf("top") !== -1 ? "0%" : t.indexOf("bottom") !== -1 ? "100%" : i[1];
								if(i.length > 3 && !e) {
									for(i = t.split(", ").join(",").split(","),
										t = [],
										n = 0; n < i.length; n++)
										t.push(lt(i[n]));
									return t.join(",")
								}
								return null == o ? o = "center" === r ? "50%" : "0" : "center" === o && (o = "50%"),
									("center" === r || isNaN(parseFloat(r)) && (r + "").indexOf("=") === -1) && (r = "50%"),
									t = r + " " + o + (i.length > 2 ? " " + i[2] : ""),
									e && (e.oxp = r.indexOf("%") !== -1,
										e.oyp = o.indexOf("%") !== -1,
										e.oxr = "=" === r.charAt(1),
										e.oyr = "=" === o.charAt(1),
										e.ox = parseFloat(r.replace(w, "")),
										e.oy = parseFloat(o.replace(w, "")),
										e.v = t),
									e || t
							},
							ct = function(t, e) {
								return "function" == typeof t && (t = t(_, g)),
									"string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) || 0
							},
							ut = function(t, e) {
								return "function" == typeof t && (t = t(_, g)),
									null == t ? e : "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t) || 0
							},
							ht = function(t, e, n, i) {
								var r, o, a, s, l, c = 1e-6;
								return "function" == typeof t && (t = t(_, g)),
									null == t ? s = e : "number" == typeof t ? s = t : (r = 360,
										o = t.split("_"),
										l = "=" === t.charAt(1),
										a = (l ? parseInt(t.charAt(0) + "1", 10) * parseFloat(o[0].substr(2)) : parseFloat(o[0])) * (t.indexOf("rad") === -1 ? 1 : z) - (l ? 0 : e),
										o.length && (i && (i[n] = e + a),
											t.indexOf("short") !== -1 && (a %= r,
												a !== a % (r / 2) && (a = a < 0 ? a + r : a - r)),
											t.indexOf("_cw") !== -1 && a < 0 ? a = (a + 9999999999 * r) % r - (a / r | 0) * r : t.indexOf("ccw") !== -1 && a > 0 && (a = (a - 9999999999 * r) % r - (a / r | 0) * r)),
										s = e + a),
									s < c && s > -c && (s = 0),
									s
							},
							dt = {
								aqua: [0, 255, 255],
								lime: [0, 255, 0],
								silver: [192, 192, 192],
								black: [0, 0, 0],
								maroon: [128, 0, 0],
								teal: [0, 128, 128],
								blue: [0, 0, 255],
								navy: [0, 0, 128],
								white: [255, 255, 255],
								fuchsia: [255, 0, 255],
								olive: [128, 128, 0],
								yellow: [255, 255, 0],
								orange: [255, 165, 0],
								gray: [128, 128, 128],
								purple: [128, 0, 128],
								green: [0, 128, 0],
								red: [255, 0, 0],
								pink: [255, 192, 203],
								cyan: [0, 255, 255],
								transparent: [255, 255, 255, 0]
							},
							ft = function(t, e, n) {
								return t = t < 0 ? t + 1 : t > 1 ? t - 1 : t,
									255 * (6 * t < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) + .5 | 0
							},
							pt = s.parseColor = function(t, e) {
								var n, i, r, o, a, s, l, c, u, h, d;
								if(t)
									if("number" == typeof t)
										n = [t >> 16, t >> 8 & 255, 255 & t];
									else {
										if("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)),
											dt[t])
											n = dt[t];
										else if("#" === t.charAt(0))
											4 === t.length && (i = t.charAt(1),
												r = t.charAt(2),
												o = t.charAt(3),
												t = "#" + i + i + r + r + o + o),
											t = parseInt(t.substr(1), 16),
											n = [t >> 16, t >> 8 & 255, 255 & t];
										else if("hsl" === t.substr(0, 3))
											if(n = d = t.match(y),
												e) {
												if(t.indexOf("=") !== -1)
													return t.match(b)
											} else
												a = Number(n[0]) % 360 / 360,
												s = Number(n[1]) / 100,
												l = Number(n[2]) / 100,
												r = l <= .5 ? l * (s + 1) : l + s - l * s,
												i = 2 * l - r,
												n.length > 3 && (n[3] = Number(t[3])),
												n[0] = ft(a + 1 / 3, i, r),
												n[1] = ft(a, i, r),
												n[2] = ft(a - 1 / 3, i, r);
										else
											n = t.match(y) || dt.transparent;
										n[0] = Number(n[0]),
											n[1] = Number(n[1]),
											n[2] = Number(n[2]),
											n.length > 3 && (n[3] = Number(n[3]))
									}
								else
									n = dt.black;
								return e && !d && (i = n[0] / 255,
										r = n[1] / 255,
										o = n[2] / 255,
										c = Math.max(i, r, o),
										u = Math.min(i, r, o),
										l = (c + u) / 2,
										c === u ? a = s = 0 : (h = c - u,
											s = l > .5 ? h / (2 - c - u) : h / (c + u),
											a = c === i ? (r - o) / h + (r < o ? 6 : 0) : c === r ? (o - i) / h + 2 : (i - r) / h + 4,
											a *= 60),
										n[0] = a + .5 | 0,
										n[1] = 100 * s + .5 | 0,
										n[2] = 100 * l + .5 | 0),
									n
							},
							mt = function(t, e) {
								var n, i, r, o = t.match(vt) || [],
									a = 0,
									s = o.length ? "" : t;
								for(n = 0; n < o.length; n++)
									i = o[n],
									r = t.substr(a, t.indexOf(i, a) - a),
									a += r.length + i.length,
									i = pt(i, e),
									3 === i.length && i.push(1),
									s += r + (e ? "hsla(" + i[0] + "," + i[1] + "%," + i[2] + "%," + i[3] : "rgba(" + i.join(",")) + ")";
								return s + t.substr(a)
							},
							vt = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
						for(u in dt)
							vt += "|" + u + "\\b";
						vt = new RegExp(vt + ")", "gi"),
							s.colorStringFilter = function(t) {
								var e, n = t[0] + t[1];
								vt.test(n) && (e = n.indexOf("hsl(") !== -1 || n.indexOf("hsla(") !== -1,
										t[0] = mt(t[0], e),
										t[1] = mt(t[1], e)),
									vt.lastIndex = 0
							},
							e.defaultStringFilter || (e.defaultStringFilter = s.colorStringFilter);
						var gt = function(t, e, n, i) {
								if(null == t)
									return function(t) {
										return t
									};
								var r, o = e ? (t.match(vt) || [""])[0] : "",
									a = t.split(o).join("").match(x) || [],
									s = t.substr(0, t.indexOf(a[0])),
									l = ")" === t.charAt(t.length - 1) ? ")" : "",
									c = t.indexOf(" ") !== -1 ? " " : ",",
									u = a.length,
									h = u > 0 ? a[0].replace(y, "") : "";
								return u ? r = e ? function(t) {
										var e, d, f, p;
										if("number" == typeof t)
											t += h;
										else if(i && D.test(t)) {
											for(p = t.replace(D, "|").split("|"),
												f = 0; f < p.length; f++)
												p[f] = r(p[f]);
											return p.join(",")
										}
										if(e = (t.match(vt) || [o])[0],
											d = t.split(e).join("").match(x) || [],
											f = d.length,
											u > f--)
											for(; ++f < u;)
												d[f] = n ? d[(f - 1) / 2 | 0] : a[f];
										return s + d.join(c) + c + e + l + (t.indexOf("inset") !== -1 ? " inset" : "")
									} :
									function(t) {
										var e, o, d;
										if("number" == typeof t)
											t += h;
										else if(i && D.test(t)) {
											for(o = t.replace(D, "|").split("|"),
												d = 0; d < o.length; d++)
												o[d] = r(o[d]);
											return o.join(",")
										}
										if(e = t.match(x) || [],
											d = e.length,
											u > d--)
											for(; ++d < u;)
												e[d] = n ? e[(d - 1) / 2 | 0] : a[d];
										return s + e.join(c) + l
									} :
									function(t) {
										return t
									}
							},
							_t = function(t) {
								return t = t.split(","),
									function(e, n, i, r, o, a, s) {
										var l, c = (n + "").split(" ");
										for(s = {},
											l = 0; l < 4; l++)
											s[t[l]] = c[l] = c[l] || c[(l - 1) / 2 >> 0];
										return r.parse(e, s, o, a)
									}
							},
							yt = (H._setPluginRatio = function(t) {
									this.plugin.setRatio(t);
									for(var e, n, i, r, o, a = this.data, s = a.proxy, l = a.firstMPT, c = 1e-6; l;)
										e = s[l.v],
										l.r ? e = Math.round(e) : e < c && e > -c && (e = 0),
										l.t[l.p] = e,
										l = l._next;
									if(a.autoRotate && (a.autoRotate.rotation = a.mod ? a.mod(s.rotation, this.t) : s.rotation),
										1 === t || 0 === t)
										for(l = a.firstMPT,
											o = 1 === t ? "e" : "b"; l;) {
											if(n = l.t,
												n.type) {
												if(1 === n.type) {
													for(r = n.xs0 + n.s + n.xs1,
														i = 1; i < n.l; i++)
														r += n["xn" + i] + n["xs" + (i + 1)];
													n[o] = r
												}
											} else
												n[o] = n.s + n.xs0;
											l = l._next
										}
								},
								function(t, e, n, i, r) {
									this.t = t,
										this.p = e,
										this.v = n,
										this.r = r,
										i && (i._prev = this,
											this._next = i)
								}
							),
							bt = (H._parseToProxy = function(t, e, n, i, r, o) {
									var a, s, l, c, u, h = i,
										d = {},
										f = {},
										p = n._transform,
										m = N;
									for(n._transform = null,
										N = e,
										i = u = n.parse(t, e, i, r),
										N = m,
										o && (n._transform = p,
											h && (h._prev = null,
												h._prev && (h._prev._next = null))); i && i !== h;) {
										if(i.type <= 1 && (s = i.p,
												f[s] = i.s + i.c,
												d[s] = i.s,
												o || (c = new yt(i, "s", s, c, i.r),
													i.c = 0),
												1 === i.type))
											for(a = i.l; --a > 0;)
												l = "xn" + a,
												s = i.p + "_" + l,
												f[s] = i.data[l],
												d[s] = i[l],
												o || (c = new yt(i, l, s, c, i.rxp[l]));
										i = i._next
									}
									return {
										proxy: d,
										end: f,
										firstMPT: c,
										pt: u
									}
								},
								H.CSSPropTween = function(t, e, i, r, a, s, l, c, u, h, d) {
									this.t = t,
										this.p = e,
										this.s = i,
										this.c = r,
										this.n = l || e,
										t instanceof bt || o.push(this.n),
										this.r = c,
										this.type = s || 0,
										u && (this.pr = u,
											n = !0),
										this.b = void 0 === h ? i : h,
										this.e = void 0 === d ? i + r : d,
										a && (this._next = a,
											a._prev = this)
								}
							),
							xt = function(t, e, n, i, r, o) {
								var a = new bt(t, e, n, i - n, r, -1, o);
								return a.b = n,
									a.e = a.xs0 = i,
									a
							},
							wt = s.parseComplex = function(t, e, n, i, r, o, a, l, c, u) {
								n = n || o || "",
									"function" == typeof i && (i = i(_, g)),
									a = new bt(t, e, 0, 0, a, u ? 2 : 1, null, !1, l, n, i),
									i += "",
									r && vt.test(i + n) && (i = [n, i],
										s.colorStringFilter(i),
										n = i[0],
										i = i[1]);
								var d, f, p, m, v, x, w, T, M, E, S, X, A, P = n.split(", ").join(",").split(" "),
									R = i.split(", ").join(",").split(" "),
									O = P.length,
									C = h !== !1;
								for(i.indexOf(",") === -1 && n.indexOf(",") === -1 || (P = P.join(" ").replace(D, ", ").split(" "),
										R = R.join(" ").replace(D, ", ").split(" "),
										O = P.length),
									O !== R.length && (P = (o || "").split(" "),
										O = P.length),
									a.plugin = c,
									a.setRatio = u,
									vt.lastIndex = 0,
									d = 0; d < O; d++)
									if(m = P[d],
										v = R[d],
										T = parseFloat(m),
										T || 0 === T)
										a.appendXtra("", T, ct(v, T), v.replace(b, ""), C && v.indexOf("px") !== -1, !0);
									else if(r && vt.test(m))
									X = v.indexOf(")") + 1,
									X = ")" + (X ? v.substr(X) : ""),
									A = v.indexOf("hsl") !== -1 && Y,
									m = pt(m, A),
									v = pt(v, A),
									M = m.length + v.length > 6,
									M && !Y && 0 === v[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent",
										a.e = a.e.split(R[d]).join("transparent")) : (Y || (M = !1),
										A ? a.appendXtra(M ? "hsla(" : "hsl(", m[0], ct(v[0], m[0]), ",", !1, !0).appendXtra("", m[1], ct(v[1], m[1]), "%,", !1).appendXtra("", m[2], ct(v[2], m[2]), M ? "%," : "%" + X, !1) : a.appendXtra(M ? "rgba(" : "rgb(", m[0], v[0] - m[0], ",", !0, !0).appendXtra("", m[1], v[1] - m[1], ",", !0).appendXtra("", m[2], v[2] - m[2], M ? "," : X, !0),
										M && (m = m.length < 4 ? 1 : m[3],
											a.appendXtra("", m, (v.length < 4 ? 1 : v[3]) - m, X, !1))),
									vt.lastIndex = 0;
								else if(x = m.match(y)) {
									if(w = v.match(b), !w || w.length !== x.length)
										return a;
									for(p = 0,
										f = 0; f < x.length; f++)
										S = x[f],
										E = m.indexOf(S, p),
										a.appendXtra(m.substr(p, E - p), Number(S), ct(w[f], S), "", C && "px" === m.substr(E + S.length, 2), 0 === f),
										p = E + S.length;
									a["xs" + a.l] += m.substr(p)
								} else
									a["xs" + a.l] += a.l || a["xs" + a.l] ? " " + v : v;
								if(i.indexOf("=") !== -1 && a.data) {
									for(X = a.xs0 + a.data.s,
										d = 1; d < a.l; d++)
										X += a["xs" + d] + a.data["xn" + d];
									a.e = X + a["xs" + d]
								}
								return a.l || (a.type = -1,
										a.xs0 = a.e),
									a.xfirst || a
							},
							Tt = 9;
						for(u = bt.prototype,
							u.l = u.pr = 0; --Tt > 0;)
							u["xn" + Tt] = 0,
							u["xs" + Tt] = "";
						u.xs0 = "",
							u._next = u._prev = u.xfirst = u.data = u.plugin = u.setRatio = u.rxp = null,
							u.appendXtra = function(t, e, n, i, r, o) {
								var a = this,
									s = a.l;
								return a["xs" + s] += o && (s || a["xs" + s]) ? " " + t : t || "",
									n || 0 === s || a.plugin ? (a.l++,
										a.type = a.setRatio ? 2 : 1,
										a["xs" + a.l] = i || "",
										s > 0 ? (a.data["xn" + s] = e + n,
											a.rxp["xn" + s] = r,
											a["xn" + s] = e,
											a.plugin || (a.xfirst = new bt(a, "xn" + s, e, n, a.xfirst || a, 0, a.n, r, a.pr),
												a.xfirst.xs0 = 0),
											a) : (a.data = {
												s: e + n
											},
											a.rxp = {},
											a.s = e,
											a.c = n,
											a.r = r,
											a)) : (a["xs" + s] += e + (i || ""),
										a)
							};
						var Mt = function(t, e) {
								e = e || {},
									this.p = e.prefix ? K(t) || t : t,
									c[t] = c[this.p] = this,
									this.format = e.formatter || gt(e.defaultValue, e.color, e.collapsible, e.multi),
									e.parser && (this.parse = e.parser),
									this.clrs = e.color,
									this.multi = e.multi,
									this.keyword = e.keyword,
									this.dflt = e.defaultValue,
									this.pr = e.priority || 0
							},
							Et = H._registerComplexSpecialProp = function(t, e, n) {
								"object" != typeof e && (e = {
									parser: n
								});
								var i, r, o = t.split(","),
									a = e.defaultValue;
								for(n = n || [a],
									i = 0; i < o.length; i++)
									e.prefix = 0 === i && e.prefix,
									e.defaultValue = n[i] || a,
									r = new Mt(o[i], e)
							},
							St = H._registerPluginProp = function(t) {
								if(!c[t]) {
									var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
									Et(t, {
										parser: function(t, n, i, r, o, a, s) {
											var u = l.com.greensock.plugins[e];
											return u ? (u._cssRegister(),
												c[i].parse(t, n, i, r, o, a, s)) : (Z("Error: " + e + " js file not loaded."),
												o)
										}
									})
								}
							};
						u = Mt.prototype,
							u.parseComplex = function(t, e, n, i, r, o) {
								var a, s, l, c, u, h, d = this.keyword;
								if(this.multi && (D.test(n) || D.test(e) ? (s = e.replace(D, "|").split("|"),
										l = n.replace(D, "|").split("|")) : d && (s = [e],
										l = [n])),
									l) {
									for(c = l.length > s.length ? l.length : s.length,
										a = 0; a < c; a++)
										e = s[a] = s[a] || this.dflt,
										n = l[a] = l[a] || this.dflt,
										d && (u = e.indexOf(d),
											h = n.indexOf(d),
											u !== h && (h === -1 ? s[a] = s[a].split(d).join("") : u === -1 && (s[a] += " " + d)));
									e = s.join(", "),
										n = l.join(", ")
								}
								return wt(t, this.p, e, n, this.clrs, this.dflt, i, this.pr, r, o)
							},
							u.parse = function(t, e, n, i, o, a, s) {
								return this.parseComplex(t.style, this.format(tt(t, this.p, r, !1, this.dflt)), this.format(e), o, a)
							},
							s.registerSpecialProp = function(t, e, n) {
								Et(t, {
									parser: function(t, i, r, o, a, s, l) {
										var c = new bt(t, r, 0, 0, a, 2, r, !1, n);
										return c.plugin = s,
											c.setRatio = e(t, i, o._tween, r),
											c
									},
									priority: n
								})
							},
							s.useSVGTransformAttr = !0;
						var Xt, At = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
							Pt = K("transform"),
							Rt = Q + "transform",
							Ot = K("transformOrigin"),
							Ct = null !== K("perspective"),
							Lt = H.Transform = function() {
								this.perspective = parseFloat(s.defaultTransformPerspective) || 0,
									this.force3D = !(s.defaultForce3D === !1 || !Ct) && (s.defaultForce3D || "auto")
							},
							It = a.SVGElement,
							Dt = function(t, e, n) {
								var i, r = U.createElementNS("http://www.w3.org/2000/svg", t),
									o = /([a-z])([A-Z])/g;
								for(i in n)
									r.setAttributeNS(null, i.replace(o, "$1-$2").toLowerCase(), n[i]);
								return e.appendChild(r),
									r
							},
							Bt = U.documentElement || {},
							Ft = function() {
								var t, e, n, i = v || /Android/i.test(W) && !a.chrome;
								return U.createElementNS && !i && (t = Dt("svg", Bt),
										e = Dt("rect", t, {
											width: 100,
											height: 50,
											x: 100
										}),
										n = e.getBoundingClientRect().width,
										e.style[Ot] = "50% 50%",
										e.style[Pt] = "scaleX(0.5)",
										i = n === e.getBoundingClientRect().width && !(p && Ct),
										Bt.removeChild(t)),
									i
							}(),
							zt = function(t, e, n, i, r, o) {
								var a, l, c, u, h, d, f, p, m, v, g, _, y, b, x = t._gsTransform,
									w = Vt(t, !0);
								x && (y = x.xOrigin,
										b = x.yOrigin),
									(!i || (a = i.split(" ")).length < 2) && (f = t.getBBox(),
										0 === f.x && 0 === f.y && f.width + f.height === 0 && (f = {
											x: parseFloat(t.hasAttribute("x") ? t.getAttribute("x") : t.hasAttribute("cx") ? t.getAttribute("cx") : 0) || 0,
											y: parseFloat(t.hasAttribute("y") ? t.getAttribute("y") : t.hasAttribute("cy") ? t.getAttribute("cy") : 0) || 0,
											width: 0,
											height: 0
										}),
										e = lt(e).split(" "),
										a = [(e[0].indexOf("%") !== -1 ? parseFloat(e[0]) / 100 * f.width : parseFloat(e[0])) + f.x, (e[1].indexOf("%") !== -1 ? parseFloat(e[1]) / 100 * f.height : parseFloat(e[1])) + f.y]),
									n.xOrigin = u = parseFloat(a[0]),
									n.yOrigin = h = parseFloat(a[1]),
									i && w !== jt && (d = w[0],
										f = w[1],
										p = w[2],
										m = w[3],
										v = w[4],
										g = w[5],
										_ = d * m - f * p,
										_ && (l = u * (m / _) + h * (-p / _) + (p * g - m * v) / _,
											c = u * (-f / _) + h * (d / _) - (d * g - f * v) / _,
											u = n.xOrigin = a[0] = l,
											h = n.yOrigin = a[1] = c)),
									x && (o && (n.xOffset = x.xOffset,
											n.yOffset = x.yOffset,
											x = n),
										r || r !== !1 && s.defaultSmoothOrigin !== !1 ? (l = u - y,
											c = h - b,
											x.xOffset += l * w[0] + c * w[2] - l,
											x.yOffset += l * w[1] + c * w[3] - c) : x.xOffset = x.yOffset = 0),
									o || t.setAttribute("data-svg-origin", a.join(" "))
							},
							Nt = function(t) {
								var e, n = j("svg", this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
									i = this.parentNode,
									r = this.nextSibling,
									o = this.style.cssText;
								if(Bt.appendChild(n),
									n.appendChild(this),
									this.style.display = "block",
									t)
									try {
										e = this.getBBox(),
											this._originalGetBBox = this.getBBox,
											this.getBBox = Nt
									} catch(t) {}
								else
									this._originalGetBBox && (e = this._originalGetBBox());
								return r ? i.insertBefore(this, r) : i.appendChild(this),
									Bt.removeChild(n),
									this.style.cssText = o,
									e
							},
							kt = function(t) {
								try {
									return t.getBBox()
								} catch(e) {
									return Nt.call(t, !0)
								}
							},
							Ut = function(t) {
								return !(!(It && t.getCTM && kt(t)) || t.parentNode && !t.ownerSVGElement)
							},
							jt = [1, 0, 0, 1, 0, 0],
							Vt = function(t, e) {
								var n, i, r, o, a, s, l = t._gsTransform || new Lt,
									c = 1e5,
									u = t.style;
								if(Pt ? i = tt(t, Rt, null, !0) : t.currentStyle && (i = t.currentStyle.filter.match(L),
										i = i && 4 === i.length ? [i[0].substr(4), Number(i[2].substr(4)), Number(i[1].substr(4)), i[3].substr(4), l.x || 0, l.y || 0].join(",") : ""),
									n = !i || "none" === i || "matrix(1, 0, 0, 1, 0, 0)" === i,
									n && Pt && ((s = "none" === $(t).display) || !t.parentNode) && (s && (o = u.display,
											u.display = "block"),
										t.parentNode || (a = 1,
											Bt.appendChild(t)),
										i = tt(t, Rt, null, !0),
										n = !i || "none" === i || "matrix(1, 0, 0, 1, 0, 0)" === i,
										o ? u.display = o : s && qt(u, "display"),
										a && Bt.removeChild(t)),
									(l.svg || t.getCTM && Ut(t)) && (n && (u[Pt] + "").indexOf("matrix") !== -1 && (i = u[Pt],
											n = 0),
										r = t.getAttribute("transform"),
										n && r && (r.indexOf("matrix") !== -1 ? (i = r,
											n = 0) : r.indexOf("translate") !== -1 && (i = "matrix(1,0,0,1," + r.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")",
											n = 0))),
									n)
									return jt;
								for(r = (i || "").match(y) || [],
									Tt = r.length; --Tt > -1;)
									o = Number(r[Tt]),
									r[Tt] = (a = o - (o |= 0)) ? (a * c + (a < 0 ? -.5 : .5) | 0) / c + o : o;
								return e && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r
							},
							Gt = H.getTransform = function(t, n, i, r) {
								if(t._gsTransform && i && !r)
									return t._gsTransform;
								var o, a, l, c, u, h, d = i ? t._gsTransform || new Lt : new Lt,
									f = d.scaleX < 0,
									p = 2e-5,
									m = 1e5,
									v = Ct ? parseFloat(tt(t, Ot, n, !1, "0 0 0").split(" ")[2]) || d.zOrigin || 0 : 0,
									g = parseFloat(s.defaultTransformPerspective) || 0;
								if(d.svg = !(!t.getCTM || !Ut(t)),
									d.svg && (zt(t, tt(t, Ot, n, !1, "50% 50%") + "", d, t.getAttribute("data-svg-origin")),
										Xt = s.useSVGTransformAttr || Ft),
									o = Vt(t),
									o !== jt) {
									if(16 === o.length) {
										var _, y, b, x, w, T = o[0],
											M = o[1],
											E = o[2],
											S = o[3],
											X = o[4],
											A = o[5],
											P = o[6],
											R = o[7],
											O = o[8],
											C = o[9],
											L = o[10],
											I = o[12],
											D = o[13],
											B = o[14],
											F = o[11],
											N = Math.atan2(P, L);
										d.zOrigin && (B = -d.zOrigin,
												I = O * B - o[12],
												D = C * B - o[13],
												B = L * B + d.zOrigin - o[14]),
											d.rotationX = N * z,
											N && (x = Math.cos(-N),
												w = Math.sin(-N),
												_ = X * x + O * w,
												y = A * x + C * w,
												b = P * x + L * w,
												O = X * -w + O * x,
												C = A * -w + C * x,
												L = P * -w + L * x,
												F = R * -w + F * x,
												X = _,
												A = y,
												P = b),
											N = Math.atan2(-E, L),
											d.rotationY = N * z,
											N && (x = Math.cos(-N),
												w = Math.sin(-N),
												_ = T * x - O * w,
												y = M * x - C * w,
												b = E * x - L * w,
												C = M * w + C * x,
												L = E * w + L * x,
												F = S * w + F * x,
												T = _,
												M = y,
												E = b),
											N = Math.atan2(M, T),
											d.rotation = N * z,
											N && (x = Math.cos(-N),
												w = Math.sin(-N),
												T = T * x + X * w,
												y = M * x + A * w,
												A = M * -w + A * x,
												P = E * -w + P * x,
												M = y),
											d.rotationX && Math.abs(d.rotationX) + Math.abs(d.rotation) > 359.9 && (d.rotationX = d.rotation = 0,
												d.rotationY = 180 - d.rotationY),
											d.scaleX = (Math.sqrt(T * T + M * M) * m + .5 | 0) / m,
											d.scaleY = (Math.sqrt(A * A + C * C) * m + .5 | 0) / m,
											d.scaleZ = (Math.sqrt(P * P + L * L) * m + .5 | 0) / m,
											d.rotationX || d.rotationY ? d.skewX = 0 : (d.skewX = X || A ? Math.atan2(X, A) * z + d.rotation : d.skewX || 0,
												Math.abs(d.skewX) > 90 && Math.abs(d.skewX) < 270 && (f ? (d.scaleX *= -1,
													d.skewX += d.rotation <= 0 ? 180 : -180,
													d.rotation += d.rotation <= 0 ? 180 : -180) : (d.scaleY *= -1,
													d.skewX += d.skewX <= 0 ? 180 : -180))),
											d.perspective = F ? 1 / (F < 0 ? -F : F) : 0,
											d.x = I,
											d.y = D,
											d.z = B,
											d.svg && (d.x -= d.xOrigin - (d.xOrigin * T - d.yOrigin * X),
												d.y -= d.yOrigin - (d.yOrigin * M - d.xOrigin * A))
									} else if(!Ct || r || !o.length || d.x !== o[4] || d.y !== o[5] || !d.rotationX && !d.rotationY) {
										var k = o.length >= 6,
											U = k ? o[0] : 1,
											j = o[1] || 0,
											V = o[2] || 0,
											G = k ? o[3] : 1;
										d.x = o[4] || 0,
											d.y = o[5] || 0,
											l = Math.sqrt(U * U + j * j),
											c = Math.sqrt(G * G + V * V),
											u = U || j ? Math.atan2(j, U) * z : d.rotation || 0,
											h = V || G ? Math.atan2(V, G) * z + u : d.skewX || 0,
											Math.abs(h) > 90 && Math.abs(h) < 270 && (f ? (l *= -1,
												h += u <= 0 ? 180 : -180,
												u += u <= 0 ? 180 : -180) : (c *= -1,
												h += h <= 0 ? 180 : -180)),
											d.scaleX = l,
											d.scaleY = c,
											d.rotation = u,
											d.skewX = h,
											Ct && (d.rotationX = d.rotationY = d.z = 0,
												d.perspective = g,
												d.scaleZ = 1),
											d.svg && (d.x -= d.xOrigin - (d.xOrigin * U + d.yOrigin * V),
												d.y -= d.yOrigin - (d.xOrigin * j + d.yOrigin * G))
									}
									d.zOrigin = v;
									for(a in d)
										d[a] < p && d[a] > -p && (d[a] = 0)
								}
								return i && (t._gsTransform = d,
										d.svg && (Xt && t.style[Pt] ? e.delayedCall(.001, function() {
											qt(t.style, Pt)
										}) : !Xt && t.getAttribute("transform") && e.delayedCall(.001, function() {
											t.removeAttribute("transform")
										}))),
									d
							},
							Ht = function(t) {
								var e, n, i = this.data,
									r = -i.rotation * F,
									o = r + i.skewX * F,
									a = 1e5,
									s = (Math.cos(r) * i.scaleX * a | 0) / a,
									l = (Math.sin(r) * i.scaleX * a | 0) / a,
									c = (Math.sin(o) * -i.scaleY * a | 0) / a,
									u = (Math.cos(o) * i.scaleY * a | 0) / a,
									h = this.t.style,
									d = this.t.currentStyle;
								if(d) {
									n = l,
										l = -c,
										c = -n,
										e = d.filter,
										h.filter = "";
									var f, p, m = this.t.offsetWidth,
										g = this.t.offsetHeight,
										_ = "absolute" !== d.position,
										y = "progid:DXImageTransform.Microsoft.Matrix(M11=" + s + ", M12=" + l + ", M21=" + c + ", M22=" + u,
										b = i.x + m * i.xPercent / 100,
										x = i.y + g * i.yPercent / 100;
									if(null != i.ox && (f = (i.oxp ? m * i.ox * .01 : i.ox) - m / 2,
											p = (i.oyp ? g * i.oy * .01 : i.oy) - g / 2,
											b += f - (f * s + p * l),
											x += p - (f * c + p * u)),
										_ ? (f = m / 2,
											p = g / 2,
											y += ", Dx=" + (f - (f * s + p * l) + b) + ", Dy=" + (p - (f * c + p * u) + x) + ")") : y += ", sizingMethod='auto expand')",
										e.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1 ? h.filter = e.replace(I, y) : h.filter = y + " " + e,
										0 !== t && 1 !== t || 1 === s && 0 === l && 0 === c && 1 === u && (_ && y.indexOf("Dx=0, Dy=0") === -1 || M.test(e) && 100 !== parseFloat(RegExp.$1) || e.indexOf(e.indexOf("Alpha")) === -1 && h.removeAttribute("filter")), !_) {
										var w, E, S, X = v < 8 ? 1 : -1;
										for(f = i.ieOffsetX || 0,
											p = i.ieOffsetY || 0,
											i.ieOffsetX = Math.round((m - ((s < 0 ? -s : s) * m + (l < 0 ? -l : l) * g)) / 2 + b),
											i.ieOffsetY = Math.round((g - ((u < 0 ? -u : u) * g + (c < 0 ? -c : c) * m)) / 2 + x),
											Tt = 0; Tt < 4; Tt++)
											E = at[Tt],
											w = d[E],
											n = w.indexOf("px") !== -1 ? parseFloat(w) : et(this.t, E, parseFloat(w), w.replace(T, "")) || 0,
											S = n !== i[E] ? Tt < 2 ? -i.ieOffsetX : -i.ieOffsetY : Tt < 2 ? f - i.ieOffsetX : p - i.ieOffsetY,
											h[E] = (i[E] = Math.round(n - S * (0 === Tt || 2 === Tt ? 1 : X))) + "px"
									}
								}
							},
							Wt = H.set3DTransformRatio = H.setTransformRatio = function(t) {
								var e, n, i, r, o, a, s, l, c, u, h, d, f, m, v, g, _, y, b, x, w, T, M, E = this.data,
									S = this.t.style,
									X = E.rotation,
									A = E.rotationX,
									P = E.rotationY,
									R = E.scaleX,
									O = E.scaleY,
									C = E.scaleZ,
									L = E.x,
									I = E.y,
									D = E.z,
									B = E.svg,
									z = E.perspective,
									N = E.force3D,
									k = E.skewY,
									U = E.skewX;
								if(k && (U += k,
										X += k),
									((1 === t || 0 === t) && "auto" === N && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !N) && !D && !z && !P && !A && 1 === C || Xt && B || !Ct)
									return void(X || U || B ? (X *= F,
										T = U * F,
										M = 1e5,
										n = Math.cos(X) * R,
										o = Math.sin(X) * R,
										i = Math.sin(X - T) * -O,
										a = Math.cos(X - T) * O,
										T && "simple" === E.skewType && (e = Math.tan(T - k * F),
											e = Math.sqrt(1 + e * e),
											i *= e,
											a *= e,
											k && (e = Math.tan(k * F),
												e = Math.sqrt(1 + e * e),
												n *= e,
												o *= e)),
										B && (L += E.xOrigin - (E.xOrigin * n + E.yOrigin * i) + E.xOffset,
											I += E.yOrigin - (E.xOrigin * o + E.yOrigin * a) + E.yOffset,
											Xt && (E.xPercent || E.yPercent) && (v = this.t.getBBox(),
												L += .01 * E.xPercent * v.width,
												I += .01 * E.yPercent * v.height),
											v = 1e-6,
											L < v && L > -v && (L = 0),
											I < v && I > -v && (I = 0)),
										b = (n * M | 0) / M + "," + (o * M | 0) / M + "," + (i * M | 0) / M + "," + (a * M | 0) / M + "," + L + "," + I + ")",
										B && Xt ? this.t.setAttribute("transform", "matrix(" + b) : S[Pt] = (E.xPercent || E.yPercent ? "translate(" + E.xPercent + "%," + E.yPercent + "%) matrix(" : "matrix(") + b) : S[Pt] = (E.xPercent || E.yPercent ? "translate(" + E.xPercent + "%," + E.yPercent + "%) matrix(" : "matrix(") + R + ",0,0," + O + "," + L + "," + I + ")");
								if(p && (v = 1e-4,
										R < v && R > -v && (R = C = 2e-5),
										O < v && O > -v && (O = C = 2e-5), !z || E.z || E.rotationX || E.rotationY || (z = 0)),
									X || U)
									X *= F,
									g = n = Math.cos(X),
									_ = o = Math.sin(X),
									U && (X -= U * F,
										g = Math.cos(X),
										_ = Math.sin(X),
										"simple" === E.skewType && (e = Math.tan((U - k) * F),
											e = Math.sqrt(1 + e * e),
											g *= e,
											_ *= e,
											E.skewY && (e = Math.tan(k * F),
												e = Math.sqrt(1 + e * e),
												n *= e,
												o *= e))),
									i = -_,
									a = g;
								else {
									if(!(P || A || 1 !== C || z || B))
										return void(S[Pt] = (E.xPercent || E.yPercent ? "translate(" + E.xPercent + "%," + E.yPercent + "%) translate3d(" : "translate3d(") + L + "px," + I + "px," + D + "px)" + (1 !== R || 1 !== O ? " scale(" + R + "," + O + ")" : ""));
									n = a = 1,
										i = o = 0
								}
								u = 1,
									r = s = l = c = h = d = 0,
									f = z ? -1 / z : 0,
									m = E.zOrigin,
									v = 1e-6,
									x = ",",
									w = "0",
									X = P * F,
									X && (g = Math.cos(X),
										_ = Math.sin(X),
										l = -_,
										h = f * -_,
										r = n * _,
										s = o * _,
										u = g,
										f *= g,
										n *= g,
										o *= g),
									X = A * F,
									X && (g = Math.cos(X),
										_ = Math.sin(X),
										e = i * g + r * _,
										y = a * g + s * _,
										c = u * _,
										d = f * _,
										r = i * -_ + r * g,
										s = a * -_ + s * g,
										u *= g,
										f *= g,
										i = e,
										a = y),
									1 !== C && (r *= C,
										s *= C,
										u *= C,
										f *= C),
									1 !== O && (i *= O,
										a *= O,
										c *= O,
										d *= O),
									1 !== R && (n *= R,
										o *= R,
										l *= R,
										h *= R),
									(m || B) && (m && (L += r * -m,
											I += s * -m,
											D += u * -m + m),
										B && (L += E.xOrigin - (E.xOrigin * n + E.yOrigin * i) + E.xOffset,
											I += E.yOrigin - (E.xOrigin * o + E.yOrigin * a) + E.yOffset),
										L < v && L > -v && (L = w),
										I < v && I > -v && (I = w),
										D < v && D > -v && (D = 0)),
									b = E.xPercent || E.yPercent ? "translate(" + E.xPercent + "%," + E.yPercent + "%) matrix3d(" : "matrix3d(",
									b += (n < v && n > -v ? w : n) + x + (o < v && o > -v ? w : o) + x + (l < v && l > -v ? w : l),
									b += x + (h < v && h > -v ? w : h) + x + (i < v && i > -v ? w : i) + x + (a < v && a > -v ? w : a),
									A || P || 1 !== C ? (b += x + (c < v && c > -v ? w : c) + x + (d < v && d > -v ? w : d) + x + (r < v && r > -v ? w : r),
										b += x + (s < v && s > -v ? w : s) + x + (u < v && u > -v ? w : u) + x + (f < v && f > -v ? w : f) + x) : b += ",0,0,0,0,1,0,",
									b += L + x + I + x + D + x + (z ? 1 + -D / z : 1) + ")",
									S[Pt] = b
							};
						u = Lt.prototype,
							u.x = u.y = u.z = u.skewX = u.skewY = u.rotation = u.rotationX = u.rotationY = u.zOrigin = u.xPercent = u.yPercent = u.xOffset = u.yOffset = 0,
							u.scaleX = u.scaleY = u.scaleZ = 1,
							Et("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
								parser: function(t, e, n, i, o, a, l) {
									if(i._lastParsedTransform === l)
										return o;
									i._lastParsedTransform = l;
									var c, u = l.scale && "function" == typeof l.scale ? l.scale : 0;
									"function" == typeof l[n] && (c = l[n],
											l[n] = e),
										u && (l.scale = u(_, t));
									var h, d, f, p, m, v, y, b, x, w = t._gsTransform,
										T = t.style,
										M = 1e-6,
										E = At.length,
										S = l,
										X = {},
										A = "transformOrigin",
										P = Gt(t, r, !0, S.parseTransform),
										R = S.transform && ("function" == typeof S.transform ? S.transform(_, g) : S.transform);
									if(i._transform = P,
										R && "string" == typeof R && Pt)
										d = V.style,
										d[Pt] = R,
										d.display = "block",
										d.position = "absolute",
										U.body.appendChild(V),
										h = Gt(V, null, !1),
										P.svg && (v = P.xOrigin,
											y = P.yOrigin,
											h.x -= P.xOffset,
											h.y -= P.yOffset,
											(S.transformOrigin || S.svgOrigin) && (R = {},
												zt(t, lt(S.transformOrigin), R, S.svgOrigin, S.smoothOrigin, !0),
												v = R.xOrigin,
												y = R.yOrigin,
												h.x -= R.xOffset - P.xOffset,
												h.y -= R.yOffset - P.yOffset),
											(v || y) && (b = Vt(V, !0),
												h.x -= v - (v * b[0] + y * b[2]),
												h.y -= y - (v * b[1] + y * b[3]))),
										U.body.removeChild(V),
										h.perspective || (h.perspective = P.perspective),
										null != S.xPercent && (h.xPercent = ut(S.xPercent, P.xPercent)),
										null != S.yPercent && (h.yPercent = ut(S.yPercent, P.yPercent));
									else if("object" == typeof S) {
										if(h = {
												scaleX: ut(null != S.scaleX ? S.scaleX : S.scale, P.scaleX),
												scaleY: ut(null != S.scaleY ? S.scaleY : S.scale, P.scaleY),
												scaleZ: ut(S.scaleZ, P.scaleZ),
												x: ut(S.x, P.x),
												y: ut(S.y, P.y),
												z: ut(S.z, P.z),
												xPercent: ut(S.xPercent, P.xPercent),
												yPercent: ut(S.yPercent, P.yPercent),
												perspective: ut(S.transformPerspective, P.perspective)
											},
											m = S.directionalRotation,
											null != m)
											if("object" == typeof m)
												for(d in m)
													S[d] = m[d];
											else
												S.rotation = m;
										"string" == typeof S.x && S.x.indexOf("%") !== -1 && (h.x = 0,
												h.xPercent = ut(S.x, P.xPercent)),
											"string" == typeof S.y && S.y.indexOf("%") !== -1 && (h.y = 0,
												h.yPercent = ut(S.y, P.yPercent)),
											h.rotation = ht("rotation" in S ? S.rotation : "shortRotation" in S ? S.shortRotation + "_short" : "rotationZ" in S ? S.rotationZ : P.rotation, P.rotation, "rotation", X),
											Ct && (h.rotationX = ht("rotationX" in S ? S.rotationX : "shortRotationX" in S ? S.shortRotationX + "_short" : P.rotationX || 0, P.rotationX, "rotationX", X),
												h.rotationY = ht("rotationY" in S ? S.rotationY : "shortRotationY" in S ? S.shortRotationY + "_short" : P.rotationY || 0, P.rotationY, "rotationY", X)),
											h.skewX = ht(S.skewX, P.skewX),
											h.skewY = ht(S.skewY, P.skewY)
									}
									for(Ct && null != S.force3D && (P.force3D = S.force3D,
											p = !0),
										P.skewType = S.skewType || P.skewType || s.defaultSkewType,
										f = P.force3D || P.z || P.rotationX || P.rotationY || h.z || h.rotationX || h.rotationY || h.perspective,
										f || null == S.scale || (h.scaleZ = 1); --E > -1;)
										x = At[E],
										R = h[x] - P[x],
										(R > M || R < -M || null != S[x] || null != N[x]) && (p = !0,
											o = new bt(P, x, P[x], R, o),
											x in X && (o.e = X[x]),
											o.xs0 = 0,
											o.plugin = a,
											i._overwriteProps.push(o.n));
									return R = S.transformOrigin,
										P.svg && (R || S.svgOrigin) && (v = P.xOffset,
											y = P.yOffset,
											zt(t, lt(R), h, S.svgOrigin, S.smoothOrigin),
											o = xt(P, "xOrigin", (w ? P : h).xOrigin, h.xOrigin, o, A),
											o = xt(P, "yOrigin", (w ? P : h).yOrigin, h.yOrigin, o, A),
											v === P.xOffset && y === P.yOffset || (o = xt(P, "xOffset", w ? v : P.xOffset, P.xOffset, o, A),
												o = xt(P, "yOffset", w ? y : P.yOffset, P.yOffset, o, A)),
											R = "0px 0px"),
										(R || Ct && f && P.zOrigin) && (Pt ? (p = !0,
											x = Ot,
											R = (R || tt(t, x, r, !1, "50% 50%")) + "",
											o = new bt(T, x, 0, 0, o, -1, A),
											o.b = T[x],
											o.plugin = a,
											Ct ? (d = P.zOrigin,
												R = R.split(" "),
												P.zOrigin = (R.length > 2 && (0 === d || "0px" !== R[2]) ? parseFloat(R[2]) : d) || 0,
												o.xs0 = o.e = R[0] + " " + (R[1] || "50%") + " 0px",
												o = new bt(P, "zOrigin", 0, 0, o, -1, o.n),
												o.b = d,
												o.xs0 = o.e = P.zOrigin) : o.xs0 = o.e = R) : lt(R + "", P)),
										p && (i._transformType = P.svg && Xt || !f && 3 !== this._transformType ? 2 : 3),
										c && (l[n] = c),
										u && (l.scale = u),
										o
								},
								prefix: !0
							}),
							Et("boxShadow", {
								defaultValue: "0px 0px 0px 0px #999",
								prefix: !0,
								color: !0,
								multi: !0,
								keyword: "inset"
							}),
							Et("borderRadius", {
								defaultValue: "0px",
								parser: function(t, e, n, o, a, s) {
									e = this.format(e);
									var l, c, u, h, d, f, p, m, v, g, _, y, b, x, w, T, M = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
										E = t.style;
									for(v = parseFloat(t.offsetWidth),
										g = parseFloat(t.offsetHeight),
										l = e.split(" "),
										c = 0; c < M.length; c++)
										this.p.indexOf("border") && (M[c] = K(M[c])),
										d = h = tt(t, M[c], r, !1, "0px"),
										d.indexOf(" ") !== -1 && (h = d.split(" "),
											d = h[0],
											h = h[1]),
										f = u = l[c],
										p = parseFloat(d),
										y = d.substr((p + "").length),
										b = "=" === f.charAt(1),
										b ? (m = parseInt(f.charAt(0) + "1", 10),
											f = f.substr(2),
											m *= parseFloat(f),
											_ = f.substr((m + "").length - (m < 0 ? 1 : 0)) || "") : (m = parseFloat(f),
											_ = f.substr((m + "").length)),
										"" === _ && (_ = i[n] || y),
										_ !== y && (x = et(t, "borderLeft", p, y),
											w = et(t, "borderTop", p, y),
											"%" === _ ? (d = x / v * 100 + "%",
												h = w / g * 100 + "%") : "em" === _ ? (T = et(t, "borderLeft", 1, "em"),
												d = x / T + "em",
												h = w / T + "em") : (d = x + "px",
												h = w + "px"),
											b && (f = parseFloat(d) + m + _,
												u = parseFloat(h) + m + _)),
										a = wt(E, M[c], d + " " + h, f + " " + u, !1, "0px", a);
									return a
								},
								prefix: !0,
								formatter: gt("0px 0px 0px 0px", !1, !0)
							}),
							Et("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
								defaultValue: "0px",
								parser: function(t, e, n, i, o, a) {
									return wt(t.style, n, this.format(tt(t, n, r, !1, "0px 0px")), this.format(e), !1, "0px", o)
								},
								prefix: !0,
								formatter: gt("0px 0px", !1, !0)
							}),
							Et("backgroundPosition", {
								defaultValue: "0 0",
								parser: function(t, e, n, i, o, a) {
									var s, l, c, u, h, d, f = "background-position",
										p = r || $(t, null),
										m = this.format((p ? v ? p.getPropertyValue(f + "-x") + " " + p.getPropertyValue(f + "-y") : p.getPropertyValue(f) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
										g = this.format(e);
									if(m.indexOf("%") !== -1 != (g.indexOf("%") !== -1) && g.split(",").length < 2 && (d = tt(t, "backgroundImage").replace(R, ""),
											d && "none" !== d)) {
										for(s = m.split(" "),
											l = g.split(" "),
											G.setAttribute("src", d),
											c = 2; --c > -1;)
											m = s[c],
											u = m.indexOf("%") !== -1,
											u !== (l[c].indexOf("%") !== -1) && (h = 0 === c ? t.offsetWidth - G.width : t.offsetHeight - G.height,
												s[c] = u ? parseFloat(m) / 100 * h + "px" : parseFloat(m) / h * 100 + "%");
										m = s.join(" ")
									}
									return this.parseComplex(t.style, m, g, o, a)
								},
								formatter: lt
							}),
							Et("backgroundSize", {
								defaultValue: "0 0",
								formatter: function(t) {
									return t += "",
										lt(t.indexOf(" ") === -1 ? t + " " + t : t)
								}
							}),
							Et("perspective", {
								defaultValue: "0px",
								prefix: !0
							}),
							Et("perspectiveOrigin", {
								defaultValue: "50% 50%",
								prefix: !0
							}),
							Et("transformStyle", {
								prefix: !0
							}),
							Et("backfaceVisibility", {
								prefix: !0
							}),
							Et("userSelect", {
								prefix: !0
							}),
							Et("margin", {
								parser: _t("marginTop,marginRight,marginBottom,marginLeft")
							}),
							Et("padding", {
								parser: _t("paddingTop,paddingRight,paddingBottom,paddingLeft")
							}),
							Et("clip", {
								defaultValue: "rect(0px,0px,0px,0px)",
								parser: function(t, e, n, i, o, a) {
									var s, l, c;
									return v < 9 ? (l = t.currentStyle,
											c = v < 8 ? " " : ",",
											s = "rect(" + l.clipTop + c + l.clipRight + c + l.clipBottom + c + l.clipLeft + ")",
											e = this.format(e).split(",").join(c)) : (s = this.format(tt(t, this.p, r, !1, this.dflt)),
											e = this.format(e)),
										this.parseComplex(t.style, s, e, o, a)
								}
							}),
							Et("textShadow", {
								defaultValue: "0px 0px 0px #999",
								color: !0,
								multi: !0
							}),
							Et("autoRound,strictUnits", {
								parser: function(t, e, n, i, r) {
									return r
								}
							}),
							Et("border", {
								defaultValue: "0px solid #000",
								parser: function(t, e, n, i, o, a) {
									var s = tt(t, "borderTopWidth", r, !1, "0px"),
										l = this.format(e).split(" "),
										c = l[0].replace(T, "");
									return "px" !== c && (s = parseFloat(s) / et(t, "borderTopWidth", 1, c) + c),
										this.parseComplex(t.style, this.format(s + " " + tt(t, "borderTopStyle", r, !1, "solid") + " " + tt(t, "borderTopColor", r, !1, "#000")), l.join(" "), o, a)
								},
								color: !0,
								formatter: function(t) {
									var e = t.split(" ");
									return e[0] + " " + (e[1] || "solid") + " " + (t.match(vt) || ["#000"])[0]
								}
							}),
							Et("borderWidth", {
								parser: _t("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
							}),
							Et("float,cssFloat,styleFloat", {
								parser: function(t, e, n, i, r, o) {
									var a = t.style,
										s = "cssFloat" in a ? "cssFloat" : "styleFloat";
									return new bt(a, s, 0, 0, r, -1, n, !1, 0, a[s], e)
								}
							});
						var Yt = function(t) {
							var e, n = this.t,
								i = n.filter || tt(this.data, "filter") || "",
								r = this.s + this.c * t | 0;
							100 === r && (i.indexOf("atrix(") === -1 && i.indexOf("radient(") === -1 && i.indexOf("oader(") === -1 ? (n.removeAttribute("filter"),
									e = !tt(this.data, "filter")) : (n.filter = i.replace(S, ""),
									e = !0)),
								e || (this.xn1 && (n.filter = i = i || "alpha(opacity=" + r + ")"),
									i.indexOf("pacity") === -1 ? 0 === r && this.xn1 || (n.filter = i + " alpha(opacity=" + r + ")") : n.filter = i.replace(M, "opacity=" + r))
						};
						Et("opacity,alpha,autoAlpha", {
							defaultValue: "1",
							parser: function(t, e, n, i, o, a) {
								var s = parseFloat(tt(t, "opacity", r, !1, "1")),
									l = t.style,
									c = "autoAlpha" === n;
								return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + s),
									c && 1 === s && "hidden" === tt(t, "visibility", r) && 0 !== e && (s = 0),
									Y ? o = new bt(l, "opacity", s, e - s, o) : (o = new bt(l, "opacity", 100 * s, 100 * (e - s), o),
										o.xn1 = c ? 1 : 0,
										l.zoom = 1,
										o.type = 2,
										o.b = "alpha(opacity=" + o.s + ")",
										o.e = "alpha(opacity=" + (o.s + o.c) + ")",
										o.data = t,
										o.plugin = a,
										o.setRatio = Yt),
									c && (o = new bt(l, "visibility", 0, 0, o, -1, null, !1, 0, 0 !== s ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit"),
										o.xs0 = "inherit",
										i._overwriteProps.push(o.n),
										i._overwriteProps.push(n)),
									o
							}
						});
						var qt = function(t, e) {
								e && (t.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e),
									t.removeProperty(e.replace(A, "-$1").toLowerCase())) : t.removeAttribute(e))
							},
							Zt = function(t) {
								if(this.t._gsClassPT = this,
									1 === t || 0 === t) {
									this.t.setAttribute("class", 0 === t ? this.b : this.e);
									for(var e = this.data, n = this.t.style; e;)
										e.v ? n[e.p] = e.v : qt(n, e.p),
										e = e._next;
									1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null)
								} else
									this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
							};
						Et("className", {
							parser: function(t, e, i, o, a, s, l) {
								var c, u, h, d, f, p = t.getAttribute("class") || "",
									m = t.style.cssText;
								if(a = o._classNamePT = new bt(t, i, 0, 0, a, 2),
									a.setRatio = Zt,
									a.pr = -11,
									n = !0,
									a.b = p,
									u = it(t, r),
									h = t._gsClassPT) {
									for(d = {},
										f = h.data; f;)
										d[f.p] = 1,
										f = f._next;
									h.setRatio(1)
								}
								return t._gsClassPT = a,
									a.e = "=" !== e.charAt(1) ? e : p.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""),
									t.setAttribute("class", a.e),
									c = rt(t, u, it(t), l, d),
									t.setAttribute("class", p),
									a.data = c.firstMPT,
									t.style.cssText = m,
									a = a.xfirst = o.parse(t, c.difs, a, s)
							}
						});
						var Qt = function(t) {
							if((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
								var e, n, i, r, o, a = this.t.style,
									s = c.transform.parse;
								if("all" === this.e)
									a.cssText = "",
									r = !0;
								else
									for(e = this.e.split(" ").join("").split(","),
										i = e.length; --i > -1;)
										n = e[i],
										c[n] && (c[n].parse === s ? r = !0 : n = "transformOrigin" === n ? Ot : c[n].p),
										qt(a, n);
								r && (qt(a, Pt),
									o = this.t._gsTransform,
									o && (o.svg && (this.t.removeAttribute("data-svg-origin"),
											this.t.removeAttribute("transform")),
										delete this.t._gsTransform))
							}
						};
						for(Et("clearProps", {
								parser: function(t, e, i, r, o) {
									return o = new bt(t, i, 0, 0, o, 2),
										o.setRatio = Qt,
										o.e = e,
										o.pr = -10,
										o.data = r._tween,
										n = !0,
										o
								}
							}),
							u = "bezier,throwProps,physicsProps,physics2D".split(","),
							Tt = u.length; Tt--;)
							St(u[Tt]);
						u = s.prototype,
							u._firstPT = u._lastParsedTransform = u._transform = null,
							u._onInitTween = function(t, e, a, l) {
								if(!t.nodeType)
									return !1;
								this._target = g = t,
									this._tween = a,
									this._vars = e,
									_ = l,
									h = e.autoRound,
									n = !1,
									i = e.suffixMap || s.suffixMap,
									r = $(t, ""),
									o = this._overwriteProps;
								var u, p, v, y, b, x, w, T, M, S = t.style;
								if(d && "" === S.zIndex && (u = tt(t, "zIndex", r),
										"auto" !== u && "" !== u || this._addLazySet(S, "zIndex", 0)),
									"string" == typeof e && (y = S.cssText,
										u = it(t, r),
										S.cssText = y + ";" + e,
										u = rt(t, u, it(t)).difs, !Y && E.test(e) && (u.opacity = parseFloat(RegExp.$1)),
										e = u,
										S.cssText = y),
									e.className ? this._firstPT = p = c.className.parse(t, e.className, "className", this, null, null, e) : this._firstPT = p = this.parse(t, e, null),
									this._transformType) {
									for(M = 3 === this._transformType,
										Pt ? f && (d = !0,
											"" === S.zIndex && (w = tt(t, "zIndex", r),
												"auto" !== w && "" !== w || this._addLazySet(S, "zIndex", 0)),
											m && this._addLazySet(S, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (M ? "visible" : "hidden"))) : S.zoom = 1,
										v = p; v && v._next;)
										v = v._next;
									T = new bt(t, "transform", 0, 0, null, 2),
										this._linkCSSP(T, null, v),
										T.setRatio = Pt ? Wt : Ht,
										T.data = this._transform || Gt(t, r, !0),
										T.tween = a,
										T.pr = -1,
										o.pop()
								}
								if(n) {
									for(; p;) {
										for(x = p._next,
											v = y; v && v.pr > p.pr;)
											v = v._next;
										(p._prev = v ? v._prev : b) ? p._prev._next = p: y = p,
											(p._next = v) ? v._prev = p : b = p,
											p = x
									}
									this._firstPT = y
								}
								return !0
							},
							u.parse = function(t, e, n, o) {
								var a, s, l, u, d, f, p, m, v, y, b = t.style;
								for(a in e)
									f = e[a],
									"function" == typeof f && (f = f(_, g)),
									s = c[a],
									s ? n = s.parse(t, f, a, this, n, o, e) : (d = tt(t, a, r) + "",
										v = "string" == typeof f,
										"color" === a || "fill" === a || "stroke" === a || a.indexOf("Color") !== -1 || v && X.test(f) ? (v || (f = pt(f),
												f = (f.length > 3 ? "rgba(" : "rgb(") + f.join(",") + ")"),
											n = wt(b, a, d, f, !0, "transparent", n, 0, o)) : v && B.test(f) ? n = wt(b, a, d, f, !0, null, n, 0, o) : (l = parseFloat(d),
											p = l || 0 === l ? d.substr((l + "").length) : "",
											"" !== d && "auto" !== d || ("width" === a || "height" === a ? (l = st(t, a, r),
												p = "px") : "left" === a || "top" === a ? (l = nt(t, a, r),
												p = "px") : (l = "opacity" !== a ? 0 : 1,
												p = "")),
											y = v && "=" === f.charAt(1),
											y ? (u = parseInt(f.charAt(0) + "1", 10),
												f = f.substr(2),
												u *= parseFloat(f),
												m = f.replace(T, "")) : (u = parseFloat(f),
												m = v ? f.replace(T, "") : ""),
											"" === m && (m = a in i ? i[a] : p),
											f = u || 0 === u ? (y ? u + l : u) + m : e[a],
											p !== m && "" !== m && (u || 0 === u) && l && (l = et(t, a, l, p),
												"%" === m ? (l /= et(t, a, 100, "%") / 100,
													e.strictUnits !== !0 && (d = l + "%")) : "em" === m || "rem" === m || "vw" === m || "vh" === m ? l /= et(t, a, 1, m) : "px" !== m && (u = et(t, a, u, m),
													m = "px"),
												y && (u || 0 === u) && (f = u + l + m)),
											y && (u += l), !l && 0 !== l || !u && 0 !== u ? void 0 !== b[a] && (f || f + "" != "NaN" && null != f) ? (n = new bt(b, a, u || l || 0, 0, n, -1, a, !1, 0, d, f),
												n.xs0 = "none" !== f || "display" !== a && a.indexOf("Style") === -1 ? f : d) : Z("invalid " + a + " tween value: " + e[a]) : (n = new bt(b, a, l, u - l, n, 0, a, h !== !1 && ("px" === m || "zIndex" === a), 0, d, f),
												n.xs0 = m))),
									o && n && !n.plugin && (n.plugin = o);
								return n
							},
							u.setRatio = function(t) {
								var e, n, i, r = this._firstPT,
									o = 1e-6;
								if(1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
									if(t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6)
										for(; r;) {
											if(e = r.c * t + r.s,
												r.r ? e = Math.round(e) : e < o && e > -o && (e = 0),
												r.type)
												if(1 === r.type)
													if(i = r.l,
														2 === i)
														r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2;
													else if(3 === i)
												r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;
											else if(4 === i)
												r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4;
											else if(5 === i)
												r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5;
											else {
												for(n = r.xs0 + e + r.xs1,
													i = 1; i < r.l; i++)
													n += r["xn" + i] + r["xs" + (i + 1)];
												r.t[r.p] = n
											} else
												r.type === -1 ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t);
											else
												r.t[r.p] = e + r.xs0;
											r = r._next
										}
								else
									for(; r;)
										2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t),
										r = r._next;
								else
									for(; r;) {
										if(2 !== r.type)
											if(r.r && r.type !== -1)
												if(e = Math.round(r.s + r.c),
													r.type) {
													if(1 === r.type) {
														for(i = r.l,
															n = r.xs0 + e + r.xs1,
															i = 1; i < r.l; i++)
															n += r["xn" + i] + r["xs" + (i + 1)];
														r.t[r.p] = n
													}
												} else
													r.t[r.p] = e + r.xs0;
										else
											r.t[r.p] = r.e;
										else
											r.setRatio(t);
										r = r._next
									}
							},
							u._enableTransforms = function(t) {
								this._transform = this._transform || Gt(this._target, r, !0),
									this._transformType = this._transform.svg && Xt || !t && 3 !== this._transformType ? 2 : 3
							};
						var Jt = function(t) {
							this.t[this.p] = this.e,
								this.data._linkCSSP(this, this._next, null, !0)
						};
						u._addLazySet = function(t, e, n) {
								var i = this._firstPT = new bt(t, e, 0, 0, this._firstPT, 2);
								i.e = n,
									i.setRatio = Jt,
									i.data = this
							},
							u._linkCSSP = function(t, e, n, i) {
								return t && (e && (e._prev = t),
										t._next && (t._next._prev = t._prev),
										t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next,
											i = !0),
										n ? n._next = t : i || null !== this._firstPT || (this._firstPT = t),
										t._next = e,
										t._prev = n),
									t
							},
							u._mod = function(t) {
								for(var e = this._firstPT; e;)
									"function" == typeof t[e.p] && t[e.p] === Math.round && (e.r = 1),
									e = e._next
							},
							u._kill = function(e) {
								var n, i, r, o = e;
								if(e.autoAlpha || e.alpha) {
									o = {};
									for(i in e)
										o[i] = e[i];
									o.opacity = 1,
										o.autoAlpha && (o.visibility = 1)
								}
								for(e.className && (n = this._classNamePT) && (r = n.xfirst,
										r && r._prev ? this._linkCSSP(r._prev, n._next, r._prev._prev) : r === this._firstPT && (this._firstPT = n._next),
										n._next && this._linkCSSP(n._next, n._next._next, r._prev),
										this._classNamePT = null),
									n = this._firstPT; n;)
									n.plugin && n.plugin !== i && n.plugin._kill && (n.plugin._kill(e),
										i = n.plugin),
									n = n._next;
								return t.prototype._kill.call(this, o)
							};
						var Kt = function(t, e, n) {
							var i, r, o, a;
							if(t.slice)
								for(r = t.length; --r > -1;)
									Kt(t[r], e, n);
							else
								for(i = t.childNodes,
									r = i.length; --r > -1;)
									o = i[r],
									a = o.type,
									o.style && (e.push(it(o)),
										n && n.push(o)),
									1 !== a && 9 !== a && 11 !== a || !o.childNodes.length || Kt(o, e, n)
						};
						return s.cascadeTo = function(t, n, i) {
								var r, o, a, s, l = e.to(t, n, i),
									c = [l],
									u = [],
									h = [],
									d = [],
									f = e._internals.reservedProps;
								for(t = l._targets || l.target,
									Kt(t, u, d),
									l.render(n, !0, !0),
									Kt(t, h),
									l.render(0, !0, !0),
									l._enabled(!0),
									r = d.length; --r > -1;)
									if(o = rt(d[r], u[r], h[r]),
										o.firstMPT) {
										o = o.difs;
										for(a in i)
											f[a] && (o[a] = i[a]);
										s = {};
										for(a in o)
											s[a] = u[r][a];
										c.push(e.fromTo(d[r], n, s, o))
									}
								return c
							},
							t.activate([s]),
							s
					}, !0),
					function() {
						var t = a._gsDefine.plugin({
								propName: "roundProps",
								version: "1.6.0",
								priority: -1,
								API: 2,
								init: function(t, e, n) {
									return this._tween = n, !0
								}
							}),
							e = function(t) {
								for(; t;)
									t.f || t.blob || (t.m = Math.round),
									t = t._next
							},
							n = t.prototype;
						n._onInitAllProps = function() {
								for(var t, n, i, r = this._tween, o = r.vars.roundProps.join ? r.vars.roundProps : r.vars.roundProps.split(","), a = o.length, s = {}, l = r._propLookup.roundProps; --a > -1;)
									s[o[a]] = Math.round;
								for(a = o.length; --a > -1;)
									for(t = o[a],
										n = r._firstPT; n;)
										i = n._next,
										n.pg ? n.t._mod(s) : n.n === t && (2 === n.f && n.t ? e(n.t._firstPT) : (this._add(n.t, t, n.s, n.c),
											i && (i._prev = n._prev),
											n._prev ? n._prev._next = i : r._firstPT === n && (r._firstPT = i),
											n._next = n._prev = null,
											r._propLookup[t] = l)),
										n = i;
								return !1
							},
							n._add = function(t, e, n, i) {
								this._addTween(t, e, n, n + i, e, Math.round),
									this._overwriteProps.push(e)
							}
					}(),
					function() {
						a._gsDefine.plugin({
							propName: "attr",
							API: 2,
							version: "0.6.0",
							init: function(t, e, n, i) {
								var r, o;
								if("function" != typeof t.setAttribute)
									return !1;
								for(r in e)
									o = e[r],
									"function" == typeof o && (o = o(i, t)),
									this._addTween(t, "setAttribute", t.getAttribute(r) + "", o + "", r, !1, r),
									this._overwriteProps.push(r);
								return !0
							}
						})
					}(),
					a._gsDefine.plugin({
						propName: "directionalRotation",
						version: "0.3.0",
						API: 2,
						init: function(t, e, n, i) {
							"object" != typeof e && (e = {
									rotation: e
								}),
								this.finals = {};
							var r, o, a, s, l, c, u = e.useRadians === !0 ? 2 * Math.PI : 360,
								h = 1e-6;
							for(r in e)
								"useRadians" !== r && (s = e[r],
									"function" == typeof s && (s = s(i, t)),
									c = (s + "").split("_"),
									o = c[0],
									a = parseFloat("function" != typeof t[r] ? t[r] : t[r.indexOf("set") || "function" != typeof t["get" + r.substr(3)] ? r : "get" + r.substr(3)]()),
									s = this.finals[r] = "string" == typeof o && "=" === o.charAt(1) ? a + parseInt(o.charAt(0) + "1", 10) * Number(o.substr(2)) : Number(o) || 0,
									l = s - a,
									c.length && (o = c.join("_"),
										o.indexOf("short") !== -1 && (l %= u,
											l !== l % (u / 2) && (l = l < 0 ? l + u : l - u)),
										o.indexOf("_cw") !== -1 && l < 0 ? l = (l + 9999999999 * u) % u - (l / u | 0) * u : o.indexOf("ccw") !== -1 && l > 0 && (l = (l - 9999999999 * u) % u - (l / u | 0) * u)),
									(l > h || l < -h) && (this._addTween(t, r, a, a + l, r),
										this._overwriteProps.push(r)));
							return !0
						},
						set: function(t) {
							var e;
							if(1 !== t)
								this._super.setRatio.call(this, t);
							else
								for(e = this._firstPT; e;)
									e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p],
									e = e._next
						}
					})._autoCSS = !0,
					a._gsDefine("easing.Back", ["easing.Ease"], function(t) {
						var e, n, i, r = a.GreenSockGlobals || a,
							o = r.com.greensock,
							s = 2 * Math.PI,
							l = Math.PI / 2,
							c = o._class,
							u = function(e, n) {
								var i = c("easing." + e, function() {}, !0),
									r = i.prototype = new t;
								return r.constructor = i,
									r.getRatio = n,
									i
							},
							h = t.register || function() {},
							d = function(t, e, n, i, r) {
								var o = c("easing." + t, {
									easeOut: new e,
									easeIn: new n,
									easeInOut: new i
								}, !0);
								return h(o, t),
									o
							},
							f = function(t, e, n) {
								this.t = t,
									this.v = e,
									n && (this.next = n,
										n.prev = this,
										this.c = n.v - e,
										this.gap = n.t - t)
							},
							p = function(e, n) {
								var i = c("easing." + e, function(t) {
										this._p1 = t || 0 === t ? t : 1.70158,
											this._p2 = 1.525 * this._p1
									}, !0),
									r = i.prototype = new t;
								return r.constructor = i,
									r.getRatio = n,
									r.config = function(t) {
										return new i(t)
									},
									i
							},
							m = d("Back", p("BackOut", function(t) {
								return(t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1
							}), p("BackIn", function(t) {
								return t * t * ((this._p1 + 1) * t - this._p1)
							}), p("BackInOut", function(t) {
								return(t *= 2) < 1 ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2)
							})),
							v = c("easing.SlowMo", function(t, e, n) {
								e = e || 0 === e ? e : .7,
									null == t ? t = .7 : t > 1 && (t = 1),
									this._p = 1 !== t ? e : 0,
									this._p1 = (1 - t) / 2,
									this._p2 = t,
									this._p3 = this._p1 + this._p2,
									this._calcEnd = n === !0
							}, !0),
							g = v.prototype = new t;
						return g.constructor = v,
							g.getRatio = function(t) {
								var e = t + (.5 - t) * this._p;
								return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e
							},
							v.ease = new v(.7, .7),
							g.config = v.config = function(t, e, n) {
								return new v(t, e, n)
							},
							e = c("easing.SteppedEase", function(t) {
								t = t || 1,
									this._p1 = 1 / t,
									this._p2 = t + 1
							}, !0),
							g = e.prototype = new t,
							g.constructor = e,
							g.getRatio = function(t) {
								return t < 0 ? t = 0 : t >= 1 && (t = .999999999),
									(this._p2 * t >> 0) * this._p1
							},
							g.config = e.config = function(t) {
								return new e(t)
							},
							n = c("easing.RoughEase", function(e) {
								e = e || {};
								for(var n, i, r, o, a, s, l = e.taper || "none", c = [], u = 0, h = 0 | (e.points || 20), d = h, p = e.randomize !== !1, m = e.clamp === !0, v = e.template instanceof t ? e.template : null, g = "number" == typeof e.strength ? .4 * e.strength : .4; --d > -1;)
									n = p ? Math.random() : 1 / h * d,
									i = v ? v.getRatio(n) : n,
									"none" === l ? r = g : "out" === l ? (o = 1 - n,
										r = o * o * g) : "in" === l ? r = n * n * g : n < .5 ? (o = 2 * n,
										r = o * o * .5 * g) : (o = 2 * (1 - n),
										r = o * o * .5 * g),
									p ? i += Math.random() * r - .5 * r : d % 2 ? i += .5 * r : i -= .5 * r,
									m && (i > 1 ? i = 1 : i < 0 && (i = 0)),
									c[u++] = {
										x: n,
										y: i
									};
								for(c.sort(function(t, e) {
										return t.x - e.x
									}),
									s = new f(1, 1, null),
									d = h; --d > -1;)
									a = c[d],
									s = new f(a.x, a.y, s);
								this._prev = new f(0, 0, 0 !== s.t ? s : s.next)
							}, !0),
							g = n.prototype = new t,
							g.constructor = n,
							g.getRatio = function(t) {
								var e = this._prev;
								if(t > e.t) {
									for(; e.next && t >= e.t;)
										e = e.next;
									e = e.prev
								} else
									for(; e.prev && t <= e.t;)
										e = e.prev;
								return this._prev = e,
									e.v + (t - e.t) / e.gap * e.c
							},
							g.config = function(t) {
								return new n(t)
							},
							n.ease = new n,
							d("Bounce", u("BounceOut", function(t) {
								return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
							}), u("BounceIn", function(t) {
								return(t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
							}), u("BounceInOut", function(t) {
								var e = t < .5;
								return t = e ? 1 - 2 * t : 2 * t - 1,
									t < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375,
									e ? .5 * (1 - t) : .5 * t + .5
							})),
							d("Circ", u("CircOut", function(t) {
								return Math.sqrt(1 - (t -= 1) * t)
							}), u("CircIn", function(t) {
								return -(Math.sqrt(1 - t * t) - 1)
							}), u("CircInOut", function(t) {
								return(t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
							})),
							i = function(e, n, i) {
								var r = c("easing." + e, function(t, e) {
										this._p1 = t >= 1 ? t : 1,
											this._p2 = (e || i) / (t < 1 ? t : 1),
											this._p3 = this._p2 / s * (Math.asin(1 / this._p1) || 0),
											this._p2 = s / this._p2
									}, !0),
									o = r.prototype = new t;
								return o.constructor = r,
									o.getRatio = n,
									o.config = function(t, e) {
										return new r(t, e)
									},
									r
							},
							d("Elastic", i("ElasticOut", function(t) {
								return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1
							}, .3), i("ElasticIn", function(t) {
								return -(this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2))
							}, .3), i("ElasticInOut", function(t) {
								return(t *= 2) < 1 ? -.5 * (this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * .5 + 1
							}, .45)),
							d("Expo", u("ExpoOut", function(t) {
								return 1 - Math.pow(2, -10 * t)
							}), u("ExpoIn", function(t) {
								return Math.pow(2, 10 * (t - 1)) - .001
							}), u("ExpoInOut", function(t) {
								return(t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
							})),
							d("Sine", u("SineOut", function(t) {
								return Math.sin(t * l)
							}), u("SineIn", function(t) {
								return -Math.cos(t * l) + 1
							}), u("SineInOut", function(t) {
								return -.5 * (Math.cos(Math.PI * t) - 1)
							})),
							c("easing.EaseLookup", {
								find: function(e) {
									return t.map[e]
								}
							}, !0),
							h(r.SlowMo, "SlowMo", "ease,"),
							h(n, "RoughEase", "ease,"),
							h(e, "SteppedEase", "ease,"),
							m
					}, !0)
			}),
			a._gsDefine && a._gsQueue.pop()(),
			function(o, a) {
				"use strict";
				var s = {},
					l = o.document,
					c = o.GreenSockGlobals = o.GreenSockGlobals || o;
				if(!c.TweenLite) {
					var u, h, d, f, p, m = function(t) {
							var e, n = t.split("."),
								i = c;
							for(e = 0; e < n.length; e++)
								i[n[e]] = i = i[n[e]] || {};
							return i
						},
						v = m("com.greensock"),
						g = 1e-10,
						_ = function(t) {
							var e, n = [],
								i = t.length;
							for(e = 0; e !== i; n.push(t[e++]))
							;
							return n
						},
						y = function() {},
						b = function() {
							var t = Object.prototype.toString,
								e = t.call([]);
							return function(n) {
								return null != n && (n instanceof Array || "object" == typeof n && !!n.push && t.call(n) === e)
							}
						}(),
						x = {},
						w = function(o, l, u, h) {
							this.sc = x[o] ? x[o].sc : [],
								x[o] = this,
								this.gsClass = null,
								this.func = u;
							var d = [];
							this.check = function(f) {
									for(var p, v, g, _, y, b = l.length, T = b; --b > -1;)
										(p = x[l[b]] || new w(l[b], [])).gsClass ? (d[b] = p.gsClass,
											T--) : f && p.sc.push(this);
									if(0 === T && u) {
										if(v = ("com.greensock." + o).split("."),
											g = v.pop(),
											_ = m(v.join("."))[g] = this.gsClass = u.apply(u, d),
											h)
											if(c[g] = s[g] = _,
												y = "undefined" != typeof t && t.exports, !y && n(27))
												i = [],
												r = function() {
													return _
												}
												.apply(e, i), !(void 0 !== r && (t.exports = r));
											else if(y)
											if(o === a) {
												t.exports = s[a] = _;
												for(b in s)
													_[b] = s[b]
											} else
												s[a] && (s[a][g] = _);
										for(b = 0; b < this.sc.length; b++)
											this.sc[b].check()
									}
								},
								this.check(!0)
						},
						T = o._gsDefine = function(t, e, n, i) {
							return new w(t, e, n, i)
						},
						M = v._class = function(t, e, n) {
							return e = e || function() {},
								T(t, [], function() {
									return e
								}, n),
								e
						};
					T.globals = c;
					var E = [0, 0, 1, 1],
						S = M("easing.Ease", function(t, e, n, i) {
							this._func = t,
								this._type = n || 0,
								this._power = i || 0,
								this._params = e ? E.concat(e) : E
						}, !0),
						X = S.map = {},
						A = S.register = function(t, e, n, i) {
							for(var r, o, a, s, l = e.split(","), c = l.length, u = (n || "easeIn,easeOut,easeInOut").split(","); --c > -1;)
								for(o = l[c],
									r = i ? M("easing." + o, null, !0) : v.easing[o] || {},
									a = u.length; --a > -1;)
									s = u[a],
									X[o + "." + s] = X[s + o] = r[s] = t.getRatio ? t : t[s] || new t
						};
					for(d = S.prototype,
						d._calcEnd = !1,
						d.getRatio = function(t) {
							if(this._func)
								return this._params[0] = t,
									this._func.apply(null, this._params);
							var e = this._type,
								n = this._power,
								i = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t);
							return 1 === n ? i *= i : 2 === n ? i *= i * i : 3 === n ? i *= i * i * i : 4 === n && (i *= i * i * i * i),
								1 === e ? 1 - i : 2 === e ? i : t < .5 ? i / 2 : 1 - i / 2
						},
						u = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"],
						h = u.length; --h > -1;)
						d = u[h] + ",Power" + h,
						A(new S(null, null, 1, h), d, "easeOut", !0),
						A(new S(null, null, 2, h), d, "easeIn" + (0 === h ? ",easeNone" : "")),
						A(new S(null, null, 3, h), d, "easeInOut");
					X.linear = v.easing.Linear.easeIn,
						X.swing = v.easing.Quad.easeInOut;
					var P = M("events.EventDispatcher", function(t) {
						this._listeners = {},
							this._eventTarget = t || this
					});
					d = P.prototype,
						d.addEventListener = function(t, e, n, i, r) {
							r = r || 0;
							var o, a, s = this._listeners[t],
								l = 0;
							for(this !== f || p || f.wake(),
								null == s && (this._listeners[t] = s = []),
								a = s.length; --a > -1;)
								o = s[a],
								o.c === e && o.s === n ? s.splice(a, 1) : 0 === l && o.pr < r && (l = a + 1);
							s.splice(l, 0, {
								c: e,
								s: n,
								up: i,
								pr: r
							})
						},
						d.removeEventListener = function(t, e) {
							var n, i = this._listeners[t];
							if(i)
								for(n = i.length; --n > -1;)
									if(i[n].c === e)
										return void i.splice(n, 1)
						},
						d.dispatchEvent = function(t) {
							var e, n, i, r = this._listeners[t];
							if(r)
								for(e = r.length,
									e > 1 && (r = r.slice(0)),
									n = this._eventTarget; --e > -1;)
									i = r[e],
									i && (i.up ? i.c.call(i.s || n, {
										type: t,
										target: n
									}) : i.c.call(i.s || n))
						};
					var R = o.requestAnimationFrame,
						O = o.cancelAnimationFrame,
						C = Date.now || function() {
							return(new Date).getTime()
						},
						L = C();
					for(u = ["ms", "moz", "webkit", "o"],
						h = u.length; --h > -1 && !R;)
						R = o[u[h] + "RequestAnimationFrame"],
						O = o[u[h] + "CancelAnimationFrame"] || o[u[h] + "CancelRequestAnimationFrame"];
					M("Ticker", function(t, e) {
							var n, i, r, o, a, s = this,
								c = C(),
								u = !(e === !1 || !R) && "auto",
								h = 500,
								d = 33,
								m = "tick",
								v = function(t) {
									var e, l, u = C() - L;
									u > h && (c += u - d),
										L += u,
										s.time = (L - c) / 1e3,
										e = s.time - a,
										(!n || e > 0 || t === !0) && (s.frame++,
											a += e + (e >= o ? .004 : o - e),
											l = !0),
										t !== !0 && (r = i(v)),
										l && s.dispatchEvent(m)
								};
							P.call(s),
								s.time = s.frame = 0,
								s.tick = function() {
									v(!0)
								},
								s.lagSmoothing = function(t, e) {
									h = t || 1 / g,
										d = Math.min(e, h, 0)
								},
								s.sleep = function() {
									null != r && (u && O ? O(r) : clearTimeout(r),
										i = y,
										r = null,
										s === f && (p = !1))
								},
								s.wake = function(t) {
									null !== r ? s.sleep() : t ? c += -L + (L = C()) : s.frame > 10 && (L = C() - h + 5),
										i = 0 === n ? y : u && R ? R : function(t) {
											return setTimeout(t, 1e3 * (a - s.time) + 1 | 0)
										},
										s === f && (p = !0),
										v(2)
								},
								s.fps = function(t) {
									return arguments.length ? (n = t,
										o = 1 / (n || 60),
										a = this.time + o,
										void s.wake()) : n
								},
								s.useRAF = function(t) {
									return arguments.length ? (s.sleep(),
										u = t,
										void s.fps(n)) : u
								},
								s.fps(t),
								setTimeout(function() {
									"auto" === u && s.frame < 5 && "hidden" !== l.visibilityState && s.useRAF(!1)
								}, 1500)
						}),
						d = v.Ticker.prototype = new v.events.EventDispatcher,
						d.constructor = v.Ticker;
					var I = M("core.Animation", function(t, e) {
						if(this.vars = e = e || {},
							this._duration = this._totalDuration = t || 0,
							this._delay = Number(e.delay) || 0,
							this._timeScale = 1,
							this._active = e.immediateRender === !0,
							this.data = e.data,
							this._reversed = e.reversed === !0,
							$) {
							p || f.wake();
							var n = this.vars.useFrames ? K : $;
							n.add(this, n._time),
								this.vars.paused && this.paused(!0)
						}
					});
					f = I.ticker = new v.Ticker,
						d = I.prototype,
						d._dirty = d._gc = d._initted = d._paused = !1,
						d._totalTime = d._time = 0,
						d._rawPrevTime = -1,
						d._next = d._last = d._onUpdate = d._timeline = d.timeline = null,
						d._paused = !1;
					var D = function() {
						p && C() - L > 2e3 && f.wake(),
							setTimeout(D, 2e3)
					};
					D(),
						d.play = function(t, e) {
							return null != t && this.seek(t, e),
								this.reversed(!1).paused(!1)
						},
						d.pause = function(t, e) {
							return null != t && this.seek(t, e),
								this.paused(!0)
						},
						d.resume = function(t, e) {
							return null != t && this.seek(t, e),
								this.paused(!1)
						},
						d.seek = function(t, e) {
							return this.totalTime(Number(t), e !== !1)
						},
						d.restart = function(t, e) {
							return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, e !== !1, !0)
						},
						d.reverse = function(t, e) {
							return null != t && this.seek(t || this.totalDuration(), e),
								this.reversed(!0).paused(!1)
						},
						d.render = function(t, e, n) {},
						d.invalidate = function() {
							return this._time = this._totalTime = 0,
								this._initted = this._gc = !1,
								this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0),
								this
						},
						d.isActive = function() {
							var t, e = this._timeline,
								n = this._startTime;
							return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= n && t < n + this.totalDuration() / this._timeScale
						},
						d._enabled = function(t, e) {
							return p || f.wake(),
								this._gc = !t,
								this._active = this.isActive(),
								e !== !0 && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
						},
						d._kill = function(t, e) {
							return this._enabled(!1, !1)
						},
						d.kill = function(t, e) {
							return this._kill(t, e),
								this
						},
						d._uncache = function(t) {
							for(var e = t ? this : this.timeline; e;)
								e._dirty = !0,
								e = e.timeline;
							return this
						},
						d._swapSelfInParams = function(t) {
							for(var e = t.length, n = t.concat(); --e > -1;)
								"{self}" === t[e] && (n[e] = this);
							return n
						},
						d._callback = function(t) {
							var e = this.vars,
								n = e[t],
								i = e[t + "Params"],
								r = e[t + "Scope"] || e.callbackScope || this,
								o = i ? i.length : 0;
							switch(o) {
								case 0:
									n.call(r);
									break;
								case 1:
									n.call(r, i[0]);
									break;
								case 2:
									n.call(r, i[0], i[1]);
									break;
								default:
									n.apply(r, i)
							}
						},
						d.eventCallback = function(t, e, n, i) {
							if("on" === (t || "").substr(0, 2)) {
								var r = this.vars;
								if(1 === arguments.length)
									return r[t];
								null == e ? delete r[t] : (r[t] = e,
										r[t + "Params"] = b(n) && n.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(n) : n,
										r[t + "Scope"] = i),
									"onUpdate" === t && (this._onUpdate = e)
							}
							return this
						},
						d.delay = function(t) {
							return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay),
								this._delay = t,
								this) : this._delay
						},
						d.duration = function(t) {
							return arguments.length ? (this._duration = this._totalDuration = t,
								this._uncache(!0),
								this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0),
								this) : (this._dirty = !1,
								this._duration)
						},
						d.totalDuration = function(t) {
							return this._dirty = !1,
								arguments.length ? this.duration(t) : this._totalDuration
						},
						d.time = function(t, e) {
							return arguments.length ? (this._dirty && this.totalDuration(),
								this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
						},
						d.totalTime = function(t, e, n) {
							if(p || f.wake(), !arguments.length)
								return this._totalTime;
							if(this._timeline) {
								if(t < 0 && !n && (t += this.totalDuration()),
									this._timeline.smoothChildTiming) {
									this._dirty && this.totalDuration();
									var i = this._totalDuration,
										r = this._timeline;
									if(t > i && !n && (t = i),
										this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? i - t : t) / this._timeScale,
										r._dirty || this._uncache(!1),
										r._timeline)
										for(; r._timeline;)
											r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0),
											r = r._timeline
								}
								this._gc && this._enabled(!0, !1),
									this._totalTime === t && 0 !== this._duration || (k.length && et(),
										this.render(t, e, !1),
										k.length && et())
							}
							return this
						},
						d.progress = d.totalProgress = function(t, e) {
							var n = this.duration();
							return arguments.length ? this.totalTime(n * t, e) : n ? this._time / n : this.ratio
						},
						d.startTime = function(t) {
							return arguments.length ? (t !== this._startTime && (this._startTime = t,
									this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)),
								this) : this._startTime
						},
						d.endTime = function(t) {
							return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
						},
						d.timeScale = function(t) {
							if(!arguments.length)
								return this._timeScale;
							if(t = t || g,
								this._timeline && this._timeline.smoothChildTiming) {
								var e = this._pauseTime,
									n = e || 0 === e ? e : this._timeline.totalTime();
								this._startTime = n - (n - this._startTime) * this._timeScale / t
							}
							return this._timeScale = t,
								this._uncache(!1)
						},
						d.reversed = function(t) {
							return arguments.length ? (t != this._reversed && (this._reversed = t,
									this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)),
								this) : this._reversed
						},
						d.paused = function(t) {
							if(!arguments.length)
								return this._paused;
							var e, n, i = this._timeline;
							return t != this._paused && i && (p || t || f.wake(),
									e = i.rawTime(),
									n = e - this._pauseTime, !t && i.smoothChildTiming && (this._startTime += n,
										this._uncache(!1)),
									this._pauseTime = t ? e : null,
									this._paused = t,
									this._active = this.isActive(), !t && 0 !== n && this._initted && this.duration() && (e = i.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale,
										this.render(e, e === this._totalTime, !0))),
								this._gc && !t && this._enabled(!0, !1),
								this
						};
					var B = M("core.SimpleTimeline", function(t) {
						I.call(this, 0, t),
							this.autoRemoveChildren = this.smoothChildTiming = !0
					});
					d = B.prototype = new I,
						d.constructor = B,
						d.kill()._gc = !1,
						d._first = d._last = d._recent = null,
						d._sortChildren = !1,
						d.add = d.insert = function(t, e, n, i) {
							var r, o;
							if(t._startTime = Number(e || 0) + t._delay,
								t._paused && this !== t._timeline && (t._pauseTime = t._startTime + (this.rawTime() - t._startTime) / t._timeScale),
								t.timeline && t.timeline._remove(t, !0),
								t.timeline = t._timeline = this,
								t._gc && t._enabled(!0, !0),
								r = this._last,
								this._sortChildren)
								for(o = t._startTime; r && r._startTime > o;)
									r = r._prev;
							return r ? (t._next = r._next,
									r._next = t) : (t._next = this._first,
									this._first = t),
								t._next ? t._next._prev = t : this._last = t,
								t._prev = r,
								this._recent = t,
								this._timeline && this._uncache(!0),
								this
						},
						d._remove = function(t, e) {
							return t.timeline === this && (e || t._enabled(!1, !0),
									t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next),
									t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev),
									t._next = t._prev = t.timeline = null,
									t === this._recent && (this._recent = this._last),
									this._timeline && this._uncache(!0)),
								this
						},
						d.render = function(t, e, n) {
							var i, r = this._first;
							for(this._totalTime = this._time = this._rawPrevTime = t; r;)
								i = r._next,
								(r._active || t >= r._startTime && !r._paused) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, n) : r.render((t - r._startTime) * r._timeScale, e, n)),
								r = i
						},
						d.rawTime = function() {
							return p || f.wake(),
								this._totalTime
						};
					var F = M("TweenLite", function(t, e, n) {
							if(I.call(this, e, n),
								this.render = F.prototype.render,
								null == t)
								throw "Cannot tween a null target.";
							this.target = t = "string" != typeof t ? t : F.selector(t) || t;
							var i, r, a, s = t.jquery || t.length && t !== o && t[0] && (t[0] === o || t[0].nodeType && t[0].style && !t.nodeType),
								l = this.vars.overwrite;
							if(this._overwrite = l = null == l ? J[F.defaultOverwrite] : "number" == typeof l ? l >> 0 : J[l],
								(s || t instanceof Array || t.push && b(t)) && "number" != typeof t[0])
								for(this._targets = a = _(t),
									this._propLookup = [],
									this._siblings = [],
									i = 0; i < a.length; i++)
									r = a[i],
									r ? "string" != typeof r ? r.length && r !== o && r[0] && (r[0] === o || r[0].nodeType && r[0].style && !r.nodeType) ? (a.splice(i--, 1),
										this._targets = a = a.concat(_(r))) : (this._siblings[i] = nt(r, this, !1),
										1 === l && this._siblings[i].length > 1 && rt(r, this, null, 1, this._siblings[i])) : (r = a[i--] = F.selector(r),
										"string" == typeof r && a.splice(i + 1, 1)) : a.splice(i--, 1);
							else
								this._propLookup = {},
								this._siblings = nt(t, this, !1),
								1 === l && this._siblings.length > 1 && rt(t, this, null, 1, this._siblings);
							(this.vars.immediateRender || 0 === e && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -g,
								this.render(Math.min(0, -this._delay)))
						}, !0),
						z = function(t) {
							return t && t.length && t !== o && t[0] && (t[0] === o || t[0].nodeType && t[0].style && !t.nodeType)
						},
						N = function(t, e) {
							var n, i = {};
							for(n in t)
								Q[n] || n in e && "transform" !== n && "x" !== n && "y" !== n && "width" !== n && "height" !== n && "className" !== n && "border" !== n || !(!Y[n] || Y[n] && Y[n]._autoCSS) || (i[n] = t[n],
									delete t[n]);
							t.css = i
						};
					d = F.prototype = new I,
						d.constructor = F,
						d.kill()._gc = !1,
						d.ratio = 0,
						d._firstPT = d._targets = d._overwrittenProps = d._startAt = null,
						d._notifyPluginsOfEnabled = d._lazy = !1,
						F.version = "1.19.1",
						F.defaultEase = d._ease = new S(null, null, 1, 1),
						F.defaultOverwrite = "auto",
						F.ticker = f,
						F.autoSleep = 120,
						F.lagSmoothing = function(t, e) {
							f.lagSmoothing(t, e)
						},
						F.selector = o.$ || o.jQuery || function(t) {
							var e = o.$ || o.jQuery;
							return e ? (F.selector = e,
								e(t)) : "undefined" == typeof l ? t : l.querySelectorAll ? l.querySelectorAll(t) : l.getElementById("#" === t.charAt(0) ? t.substr(1) : t)
						};
					var k = [],
						U = {},
						j = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
						V = function(t) {
							for(var e, n = this._firstPT, i = 1e-6; n;)
								e = n.blob ? 1 === t ? this.end : t ? this.join("") : this.start : n.c * t + n.s,
								n.m ? e = n.m(e, this._target || n.t) : e < i && e > -i && !n.blob && (e = 0),
								n.f ? n.fp ? n.t[n.p](n.fp, e) : n.t[n.p](e) : n.t[n.p] = e,
								n = n._next
						},
						G = function(t, e, n, i) {
							var r, o, a, s, l, c, u, h = [],
								d = 0,
								f = "",
								p = 0;
							for(h.start = t,
								h.end = e,
								t = h[0] = t + "",
								e = h[1] = e + "",
								n && (n(h),
									t = h[0],
									e = h[1]),
								h.length = 0,
								r = t.match(j) || [],
								o = e.match(j) || [],
								i && (i._next = null,
									i.blob = 1,
									h._firstPT = h._applyPT = i),
								l = o.length,
								s = 0; s < l; s++)
								u = o[s],
								c = e.substr(d, e.indexOf(u, d) - d),
								f += c || !s ? c : ",",
								d += c.length,
								p ? p = (p + 1) % 5 : "rgba(" === c.substr(-5) && (p = 1),
								u === r[s] || r.length <= s ? f += u : (f && (h.push(f),
										f = ""),
									a = parseFloat(r[s]),
									h.push(a),
									h._firstPT = {
										_next: h._firstPT,
										t: h,
										p: h.length - 1,
										s: a,
										c: ("=" === u.charAt(1) ? parseInt(u.charAt(0) + "1", 10) * parseFloat(u.substr(2)) : parseFloat(u) - a) || 0,
										f: 0,
										m: p && p < 4 ? Math.round : 0
									}),
								d += u.length;
							return f += e.substr(d),
								f && h.push(f),
								h.setRatio = V,
								h
						},
						H = function(t, e, n, i, r, o, a, s, l) {
							"function" == typeof i && (i = i(l || 0, t));
							var c, u = typeof t[e],
								h = "function" !== u ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
								d = "get" !== n ? n : h ? a ? t[h](a) : t[h]() : t[e],
								f = "string" == typeof i && "=" === i.charAt(1),
								p = {
									t: t,
									p: e,
									s: d,
									f: "function" === u,
									pg: 0,
									n: r || e,
									m: o ? "function" == typeof o ? o : Math.round : 0,
									pr: 0,
									c: f ? parseInt(i.charAt(0) + "1", 10) * parseFloat(i.substr(2)) : parseFloat(i) - d || 0
								};
							if(("number" != typeof d || "number" != typeof i && !f) && (a || isNaN(d) || !f && isNaN(i) || "boolean" == typeof d || "boolean" == typeof i ? (p.fp = a,
									c = G(d, f ? p.s + p.c : i, s || F.defaultStringFilter, p),
									p = {
										t: c,
										p: "setRatio",
										s: 0,
										c: 1,
										f: 2,
										pg: 0,
										n: r || e,
										pr: 0,
										m: 0
									}) : (p.s = parseFloat(d),
									f || (p.c = parseFloat(i) - p.s || 0))),
								p.c)
								return(p._next = this._firstPT) && (p._next._prev = p),
									this._firstPT = p,
									p
						},
						W = F._internals = {
							isArray: b,
							isSelector: z,
							lazyTweens: k,
							blobDif: G
						},
						Y = F._plugins = {},
						q = W.tweenLookup = {},
						Z = 0,
						Q = W.reservedProps = {
							ease: 1,
							delay: 1,
							overwrite: 1,
							onComplete: 1,
							onCompleteParams: 1,
							onCompleteScope: 1,
							useFrames: 1,
							runBackwards: 1,
							startAt: 1,
							onUpdate: 1,
							onUpdateParams: 1,
							onUpdateScope: 1,
							onStart: 1,
							onStartParams: 1,
							onStartScope: 1,
							onReverseComplete: 1,
							onReverseCompleteParams: 1,
							onReverseCompleteScope: 1,
							onRepeat: 1,
							onRepeatParams: 1,
							onRepeatScope: 1,
							easeParams: 1,
							yoyo: 1,
							immediateRender: 1,
							repeat: 1,
							repeatDelay: 1,
							data: 1,
							paused: 1,
							reversed: 1,
							autoCSS: 1,
							lazy: 1,
							onOverwrite: 1,
							callbackScope: 1,
							stringFilter: 1,
							id: 1
						},
						J = {
							none: 0,
							all: 1,
							auto: 2,
							concurrent: 3,
							allOnStart: 4,
							preexisting: 5,
							true: 1,
							false: 0
						},
						K = I._rootFramesTimeline = new B,
						$ = I._rootTimeline = new B,
						tt = 30,
						et = W.lazyRender = function() {
							var t, e = k.length;
							for(U = {}; --e > -1;)
								t = k[e],
								t && t._lazy !== !1 && (t.render(t._lazy[0], t._lazy[1], !0),
									t._lazy = !1);
							k.length = 0
						};
					$._startTime = f.time,
						K._startTime = f.frame,
						$._active = K._active = !0,
						setTimeout(et, 1),
						I._updateRoot = F.render = function() {
							var t, e, n;
							if(k.length && et(),
								$.render((f.time - $._startTime) * $._timeScale, !1, !1),
								K.render((f.frame - K._startTime) * K._timeScale, !1, !1),
								k.length && et(),
								f.frame >= tt) {
								tt = f.frame + (parseInt(F.autoSleep, 10) || 120);
								for(n in q) {
									for(e = q[n].tweens,
										t = e.length; --t > -1;)
										e[t]._gc && e.splice(t, 1);
									0 === e.length && delete q[n]
								}
								if(n = $._first,
									(!n || n._paused) && F.autoSleep && !K._first && 1 === f._listeners.tick.length) {
									for(; n && n._paused;)
										n = n._next;
									n || f.sleep()
								}
							}
						},
						f.addEventListener("tick", I._updateRoot);
					var nt = function(t, e, n) {
							var i, r, o = t._gsTweenID;
							if(q[o || (t._gsTweenID = o = "t" + Z++)] || (q[o] = {
									target: t,
									tweens: []
								}),
								e && (i = q[o].tweens,
									i[r = i.length] = e,
									n))
								for(; --r > -1;)
									i[r] === e && i.splice(r, 1);
							return q[o].tweens
						},
						it = function(t, e, n, i) {
							var r, o, a = t.vars.onOverwrite;
							return a && (r = a(t, e, n, i)),
								a = F.onOverwrite,
								a && (o = a(t, e, n, i)),
								r !== !1 && o !== !1
						},
						rt = function(t, e, n, i, r) {
							var o, a, s, l;
							if(1 === i || i >= 4) {
								for(l = r.length,
									o = 0; o < l; o++)
									if((s = r[o]) !== e)
										s._gc || s._kill(null, t, e) && (a = !0);
									else if(5 === i)
									break;
								return a
							}
							var c, u = e._startTime + g,
								h = [],
								d = 0,
								f = 0 === e._duration;
							for(o = r.length; --o > -1;)
								(s = r[o]) === e || s._gc || s._paused || (s._timeline !== e._timeline ? (c = c || ot(e, 0, f),
									0 === ot(s, c, f) && (h[d++] = s)) : s._startTime <= u && s._startTime + s.totalDuration() / s._timeScale > u && ((f || !s._initted) && u - s._startTime <= 2e-10 || (h[d++] = s)));
							for(o = d; --o > -1;)
								if(s = h[o],
									2 === i && s._kill(n, t, e) && (a = !0),
									2 !== i || !s._firstPT && s._initted) {
									if(2 !== i && !it(s, e))
										continue;
									s._enabled(!1, !1) && (a = !0)
								}
							return a
						},
						ot = function(t, e, n) {
							for(var i = t._timeline, r = i._timeScale, o = t._startTime; i._timeline;) {
								if(o += i._startTime,
									r *= i._timeScale,
									i._paused)
									return -100;
								i = i._timeline
							}
							return o /= r,
								o > e ? o - e : n && o === e || !t._initted && o - e < 2 * g ? g : (o += t.totalDuration() / t._timeScale / r) > e + g ? 0 : o - e - g
						};
					d._init = function() {
							var t, e, n, i, r, o, a = this.vars,
								s = this._overwrittenProps,
								l = this._duration,
								c = !!a.immediateRender,
								u = a.ease;
							if(a.startAt) {
								this._startAt && (this._startAt.render(-1, !0),
										this._startAt.kill()),
									r = {};
								for(i in a.startAt)
									r[i] = a.startAt[i];
								if(r.overwrite = !1,
									r.immediateRender = !0,
									r.lazy = c && a.lazy !== !1,
									r.startAt = r.delay = null,
									this._startAt = F.to(this.target, 0, r),
									c)
									if(this._time > 0)
										this._startAt = null;
									else if(0 !== l)
									return
							} else if(a.runBackwards && 0 !== l)
								if(this._startAt)
									this._startAt.render(-1, !0),
									this._startAt.kill(),
									this._startAt = null;
								else {
									0 !== this._time && (c = !1),
										n = {};
									for(i in a)
										Q[i] && "autoCSS" !== i || (n[i] = a[i]);
									if(n.overwrite = 0,
										n.data = "isFromStart",
										n.lazy = c && a.lazy !== !1,
										n.immediateRender = c,
										this._startAt = F.to(this.target, 0, n),
										c) {
										if(0 === this._time)
											return
									} else
										this._startAt._init(),
										this._startAt._enabled(!1),
										this.vars.immediateRender && (this._startAt = null)
								}
							if(this._ease = u = u ? u instanceof S ? u : "function" == typeof u ? new S(u, a.easeParams) : X[u] || F.defaultEase : F.defaultEase,
								a.easeParams instanceof Array && u.config && (this._ease = u.config.apply(u, a.easeParams)),
								this._easeType = this._ease._type,
								this._easePower = this._ease._power,
								this._firstPT = null,
								this._targets)
								for(o = this._targets.length,
									t = 0; t < o; t++)
									this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], s ? s[t] : null, t) && (e = !0);
							else
								e = this._initProps(this.target, this._propLookup, this._siblings, s, 0);
							if(e && F._onPluginEvent("_onInitAllProps", this),
								s && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)),
								a.runBackwards)
								for(n = this._firstPT; n;)
									n.s += n.c,
									n.c = -n.c,
									n = n._next;
							this._onUpdate = a.onUpdate,
								this._initted = !0
						},
						d._initProps = function(t, e, n, i, r) {
							var a, s, l, c, u, h;
							if(null == t)
								return !1;
							U[t._gsTweenID] && et(),
								this.vars.css || t.style && t !== o && t.nodeType && Y.css && this.vars.autoCSS !== !1 && N(this.vars, t);
							for(a in this.vars)
								if(h = this.vars[a],
									Q[a])
									h && (h instanceof Array || h.push && b(h)) && h.join("").indexOf("{self}") !== -1 && (this.vars[a] = h = this._swapSelfInParams(h, this));
								else if(Y[a] && (c = new Y[a])._onInitTween(t, this.vars[a], this, r)) {
								for(this._firstPT = u = {
										_next: this._firstPT,
										t: c,
										p: "setRatio",
										s: 0,
										c: 1,
										f: 1,
										n: a,
										pg: 1,
										pr: c._priority,
										m: 0
									},
									s = c._overwriteProps.length; --s > -1;)
									e[c._overwriteProps[s]] = this._firstPT;
								(c._priority || c._onInitAllProps) && (l = !0),
								(c._onDisable || c._onEnable) && (this._notifyPluginsOfEnabled = !0),
								u._next && (u._next._prev = u)
							} else
								e[a] = H.call(this, t, a, "get", h, a, 0, null, this.vars.stringFilter, r);
							return i && this._kill(i, t) ? this._initProps(t, e, n, i, r) : this._overwrite > 1 && this._firstPT && n.length > 1 && rt(t, this, e, this._overwrite, n) ? (this._kill(e, t),
								this._initProps(t, e, n, i, r)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (U[t._gsTweenID] = !0),
								l)
						},
						d.render = function(t, e, n) {
							var i, r, o, a, s = this._time,
								l = this._duration,
								c = this._rawPrevTime;
							if(t >= l - 1e-7 && t >= 0)
								this._totalTime = this._time = l,
								this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1,
								this._reversed || (i = !0,
									r = "onComplete",
									n = n || this._timeline.autoRemoveChildren),
								0 === l && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (t = 0),
									(c < 0 || t <= 0 && t >= -1e-7 || c === g && "isPause" !== this.data) && c !== t && (n = !0,
										c > g && (r = "onReverseComplete")),
									this._rawPrevTime = a = !e || t || c === t ? t : g);
							else if(t < 1e-7)
								this._totalTime = this._time = 0,
								this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0,
								(0 !== s || 0 === l && c > 0) && (r = "onReverseComplete",
									i = this._reversed),
								t < 0 && (this._active = !1,
									0 === l && (this._initted || !this.vars.lazy || n) && (c >= 0 && (c !== g || "isPause" !== this.data) && (n = !0),
										this._rawPrevTime = a = !e || t || c === t ? t : g)),
								this._initted || (n = !0);
							else if(this._totalTime = this._time = t,
								this._easeType) {
								var u = t / l,
									h = this._easeType,
									d = this._easePower;
								(1 === h || 3 === h && u >= .5) && (u = 1 - u),
								3 === h && (u *= 2),
									1 === d ? u *= u : 2 === d ? u *= u * u : 3 === d ? u *= u * u * u : 4 === d && (u *= u * u * u * u),
									1 === h ? this.ratio = 1 - u : 2 === h ? this.ratio = u : t / l < .5 ? this.ratio = u / 2 : this.ratio = 1 - u / 2
							} else
								this.ratio = this._ease.getRatio(t / l);
							if(this._time !== s || n) {
								if(!this._initted) {
									if(this._init(), !this._initted || this._gc)
										return;
									if(!n && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration))
										return this._time = this._totalTime = s,
											this._rawPrevTime = c,
											k.push(this),
											void(this._lazy = [t, e]);
									this._time && !i ? this.ratio = this._ease.getRatio(this._time / l) : i && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
								}
								for(this._lazy !== !1 && (this._lazy = !1),
									this._active || !this._paused && this._time !== s && t >= 0 && (this._active = !0),
									0 === s && (this._startAt && (t >= 0 ? this._startAt.render(t, e, n) : r || (r = "_dummyGS")),
										this.vars.onStart && (0 === this._time && 0 !== l || e || this._callback("onStart"))),
									o = this._firstPT; o;)
									o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s,
									o = o._next;
								this._onUpdate && (t < 0 && this._startAt && t !== -1e-4 && this._startAt.render(t, e, n),
										e || (this._time !== s || i || n) && this._callback("onUpdate")),
									r && (this._gc && !n || (t < 0 && this._startAt && !this._onUpdate && t !== -1e-4 && this._startAt.render(t, e, n),
										i && (this._timeline.autoRemoveChildren && this._enabled(!1, !1),
											this._active = !1), !e && this.vars[r] && this._callback(r),
										0 === l && this._rawPrevTime === g && a !== g && (this._rawPrevTime = 0)))
							}
						},
						d._kill = function(t, e, n) {
							if("all" === t && (t = null),
								null == t && (null == e || e === this.target))
								return this._lazy = !1,
									this._enabled(!1, !1);
							e = "string" != typeof e ? e || this._targets || this.target : F.selector(e) || e;
							var i, r, o, a, s, l, c, u, h, d = n && this._time && n._startTime === this._startTime && this._timeline === n._timeline;
							if((b(e) || z(e)) && "number" != typeof e[0])
								for(i = e.length; --i > -1;)
									this._kill(t, e[i], n) && (l = !0);
							else {
								if(this._targets) {
									for(i = this._targets.length; --i > -1;)
										if(e === this._targets[i]) {
											s = this._propLookup[i] || {},
												this._overwrittenProps = this._overwrittenProps || [],
												r = this._overwrittenProps[i] = t ? this._overwrittenProps[i] || {} : "all";
											break
										}
								} else {
									if(e !== this.target)
										return !1;
									s = this._propLookup,
										r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
								}
								if(s) {
									if(c = t || s,
										u = t !== r && "all" !== r && t !== s && ("object" != typeof t || !t._tempKill),
										n && (F.onOverwrite || this.vars.onOverwrite)) {
										for(o in c)
											s[o] && (h || (h = []),
												h.push(o));
										if((h || !t) && !it(this, n, e, h))
											return !1
									}
									for(o in c)
										(a = s[o]) && (d && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s,
												l = !0),
											a.pg && a.t._kill(c) && (l = !0),
											a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next),
												a._next && (a._next._prev = a._prev),
												a._next = a._prev = null),
											delete s[o]),
										u && (r[o] = 1);
									!this._firstPT && this._initted && this._enabled(!1, !1)
								}
							}
							return l
						},
						d.invalidate = function() {
							return this._notifyPluginsOfEnabled && F._onPluginEvent("_onDisable", this),
								this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null,
								this._notifyPluginsOfEnabled = this._active = this._lazy = !1,
								this._propLookup = this._targets ? {} : [],
								I.prototype.invalidate.call(this),
								this.vars.immediateRender && (this._time = -g,
									this.render(Math.min(0, -this._delay))),
								this
						},
						d._enabled = function(t, e) {
							if(p || f.wake(),
								t && this._gc) {
								var n, i = this._targets;
								if(i)
									for(n = i.length; --n > -1;)
										this._siblings[n] = nt(i[n], this, !0);
								else
									this._siblings = nt(this.target, this, !0)
							}
							return I.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && F._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
						},
						F.to = function(t, e, n) {
							return new F(t, e, n)
						},
						F.from = function(t, e, n) {
							return n.runBackwards = !0,
								n.immediateRender = 0 != n.immediateRender,
								new F(t, e, n)
						},
						F.fromTo = function(t, e, n, i) {
							return i.startAt = n,
								i.immediateRender = 0 != i.immediateRender && 0 != n.immediateRender,
								new F(t, e, i)
						},
						F.delayedCall = function(t, e, n, i, r) {
							return new F(e, 0, {
								delay: t,
								onComplete: e,
								onCompleteParams: n,
								callbackScope: i,
								onReverseComplete: e,
								onReverseCompleteParams: n,
								immediateRender: !1,
								lazy: !1,
								useFrames: r,
								overwrite: 0
							})
						},
						F.set = function(t, e) {
							return new F(t, 0, e)
						},
						F.getTweensOf = function(t, e) {
							if(null == t)
								return [];
							t = "string" != typeof t ? t : F.selector(t) || t;
							var n, i, r, o;
							if((b(t) || z(t)) && "number" != typeof t[0]) {
								for(n = t.length,
									i = []; --n > -1;)
									i = i.concat(F.getTweensOf(t[n], e));
								for(n = i.length; --n > -1;)
									for(o = i[n],
										r = n; --r > -1;)
										o === i[r] && i.splice(n, 1)
							} else
								for(i = nt(t).concat(),
									n = i.length; --n > -1;)
									(i[n]._gc || e && !i[n].isActive()) && i.splice(n, 1);
							return i
						},
						F.killTweensOf = F.killDelayedCallsTo = function(t, e, n) {
							"object" == typeof e && (n = e,
								e = !1);
							for(var i = F.getTweensOf(t, e), r = i.length; --r > -1;)
								i[r]._kill(n, t)
						};
					var at = M("plugins.TweenPlugin", function(t, e) {
						this._overwriteProps = (t || "").split(","),
							this._propName = this._overwriteProps[0],
							this._priority = e || 0,
							this._super = at.prototype
					}, !0);
					if(d = at.prototype,
						at.version = "1.19.0",
						at.API = 2,
						d._firstPT = null,
						d._addTween = H,
						d.setRatio = V,
						d._kill = function(t) {
							var e, n = this._overwriteProps,
								i = this._firstPT;
							if(null != t[this._propName])
								this._overwriteProps = [];
							else
								for(e = n.length; --e > -1;)
									null != t[n[e]] && n.splice(e, 1);
							for(; i;)
								null != t[i.n] && (i._next && (i._next._prev = i._prev),
									i._prev ? (i._prev._next = i._next,
										i._prev = null) : this._firstPT === i && (this._firstPT = i._next)),
								i = i._next;
							return !1
						},
						d._mod = d._roundProps = function(t) {
							for(var e, n = this._firstPT; n;)
								e = t[this._propName] || null != n.n && t[n.n.split(this._propName + "_").join("")],
								e && "function" == typeof e && (2 === n.f ? n.t._applyPT.m = e : n.m = e),
								n = n._next
						},
						F._onPluginEvent = function(t, e) {
							var n, i, r, o, a, s = e._firstPT;
							if("_onInitAllProps" === t) {
								for(; s;) {
									for(a = s._next,
										i = r; i && i.pr > s.pr;)
										i = i._next;
									(s._prev = i ? i._prev : o) ? s._prev._next = s: r = s,
										(s._next = i) ? i._prev = s : o = s,
										s = a
								}
								s = e._firstPT = r
							}
							for(; s;)
								s.pg && "function" == typeof s.t[t] && s.t[t]() && (n = !0),
								s = s._next;
							return n
						},
						at.activate = function(t) {
							for(var e = t.length; --e > -1;)
								t[e].API === at.API && (Y[(new t[e])._propName] = t[e]);
							return !0
						},
						T.plugin = function(t) {
							if(!(t && t.propName && t.init && t.API))
								throw "illegal plugin definition.";
							var e, n = t.propName,
								i = t.priority || 0,
								r = t.overwriteProps,
								o = {
									init: "_onInitTween",
									set: "setRatio",
									kill: "_kill",
									round: "_mod",
									mod: "_mod",
									initAll: "_onInitAllProps"
								},
								a = M("plugins." + n.charAt(0).toUpperCase() + n.substr(1) + "Plugin", function() {
									at.call(this, n, i),
										this._overwriteProps = r || []
								}, t.global === !0),
								s = a.prototype = new at(n);
							s.constructor = a,
								a.API = t.API;
							for(e in o)
								"function" == typeof t[e] && (s[o[e]] = t[e]);
							return a.version = t.version,
								at.activate([a]),
								a
						},
						u = o._gsQueue) {
						for(h = 0; h < u.length; h++)
							u[h]();
						for(d in x)
							x[d].func || o.console.log("GSAP encountered missing dependency: " + d)
					}
					p = !1
				}
			}("undefined" != typeof t && t.exports && "undefined" != typeof o ? o : this || window, "TweenMax")
	}).call(e, function() {
		return this
	}())
}, function(t, e) {
	(function(e) {
		t.exports = e
	}).call(e, {})
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function o(t) {
		v = new l.Group;
		var e = p.default.resources.model.carp;
		e.scale.x = e.scale.y = e.scale.z = .0000002,
			e.children[0].material.shading = l.SmoothShading;
		var n = e.clone();
		e.rotation.y = .2 * Math.PI,
			n.rotation.y = 1.2 * Math.PI,
			v.add(e),
			v.add(n),
			v.position.z = -m,
			v.position.y = -400,
			t.add(v)
	}

	function a(t) {
		return v.position.z > 5e3 ? void(v.visible = !1) : (0 === d.default.status ? v.visible = !0 : v.visible = !1,
			v.position.z += t,
			void(v.rotation.y += .015 * Math.PI))
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var s = n(9),
		l = r(s),
		c = n(10),
		u = i(c),
		h = n(11),
		d = i(h),
		f = n(14),
		p = i(f),
		m = u.default.FLOOR_DEPTH,
		v = (u.default.MOVE_STEP,
			void 0);
	e.default = {
		init: o,
		update: a
	}
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function o(t) {
		_ = f.default.resources.model.end.clone(),
			_.position.z = g,
			_.position.y = 1e3,
			_.scale.x = _.scale.y = _.scale.z = .15,
			t.add(_)
	}

	function a(t, e) {
		0 === h.default.status ? _.visible = !0 : _.visible = !1,
			_.position.z += t,
			_.position.z > c.default.AVATAR_Z - 2e3 && !h.default.ended && (m.default.trigger(v),
				h.default.ended = !0),
			y += e,
			_.rotation.y = y / 2e3,
			_.position.y = 1e3 + 70 * Math.sin(y / 500)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var s = n(9),
		l = (r(s),
			n(10)),
		c = i(l),
		u = n(11),
		h = i(u),
		d = n(14),
		f = i(d),
		p = n(30),
		m = i(p),
		v = (c.default.FLOOR_DEPTH,
			c.default.MOVE_STEP,
			c.default.MEET_END),
		g = c.default.END_POSITION,
		_ = void 0,
		y = 0;
	e.default = {
		init: o,
		update: a
	}
}, function(t, e) {
	"use strict";
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
			return typeof t
		} :
		function(t) {
			return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
		},
		i = {},
		r = /\s+/,
		o = function t(e, i, o, a, s) {
			var l, c = 0;
			if(o && "object" === ("undefined" == typeof o ? "undefined" : n(o))) {
				void 0 !== a && "context" in s && void 0 === s.context && (s.context = a);
				for(l = _.keys(o); c < l.length; c++)
					i = t(e, i, l[c], o[l[c]], s)
			} else if(o && r.test(o))
				for(l = o.split(r); c < l.length; c++)
					i = e(i, l[c], a, s);
			else
				i = e(i, o, a, s);
			return i
		};
	i.on = function(t, e, n) {
		return a(this, t, e, n)
	};
	var a = function(t, e, n, i, r) {
		if(t._events = o(s, t._events || {}, e, n, {
				context: i,
				ctx: t,
				listening: r
			}),
			r) {
			var a = t._listeners || (t._listeners = {});
			a[r.id] = r
		}
		return t
	};
	i.listenTo = function(t, e, n) {
		if(!t)
			return this;
		var i = t._listenId || (t._listenId = _.uniqueId("l")),
			r = this._listeningTo || (this._listeningTo = {}),
			o = r[i];
		if(!o) {
			var s = this._listenId || (this._listenId = _.uniqueId("l"));
			o = r[i] = {
				obj: t,
				objId: i,
				id: s,
				listeningTo: r,
				count: 0
			}
		}
		return a(t, e, n, this, o),
			this
	};
	var s = function(t, e, n, i) {
		if(n) {
			var r = t[e] || (t[e] = []),
				o = i.context,
				a = i.ctx,
				s = i.listening;
			s && s.count++,
				r.push({
					callback: n,
					context: o,
					ctx: o || a,
					listening: s
				})
		}
		return t
	};
	i.off = function(t, e, n) {
			return this._events ? (this._events = o(l, this._events, t, e, {
					context: n,
					listeners: this._listeners
				}),
				this) : this
		},
		i.stopListening = function(t, e, n) {
			var i = this._listeningTo;
			if(!i)
				return this;
			for(var r = t ? [t._listenId] : _.keys(i), o = 0; o < r.length; o++) {
				var a = i[r[o]];
				if(!a)
					break;
				a.obj.off(e, n, this)
			}
			return this
		};
	var l = function(t, e, n, i) {
		if(t) {
			var r, o = 0,
				a = i.context,
				s = i.listeners;
			if(e || n || a) {
				for(var l = e ? [e] : _.keys(t); o < l.length; o++) {
					e = l[o];
					var c = t[e];
					if(!c)
						break;
					for(var u = [], h = 0; h < c.length; h++) {
						var d = c[h];
						n && n !== d.callback && n !== d.callback._callback || a && a !== d.context ? u.push(d) : (r = d.listening,
							r && 0 === --r.count && (delete s[r.id],
								delete r.listeningTo[r.objId]))
					}
					u.length ? t[e] = u : delete t[e]
				}
				return t
			}
			for(var f = _.keys(s); o < f.length; o++)
				r = s[f[o]],
				delete s[r.id],
				delete r.listeningTo[r.objId]
		}
	};
	i.once = function(t, e, n) {
			var i = o(c, {}, t, e, _.bind(this.off, this));
			return "string" == typeof t && null == n && (e = void 0),
				this.on(i, e, n)
		},
		i.listenToOnce = function(t, e, n) {
			var i = o(c, {}, e, n, _.bind(this.stopListening, this, t));
			return this.listenTo(t, i)
		};
	var c = function(t, e, n, i) {
		if(n) {
			var r = t[e] = _.once(function() {
				i(e, r),
					n.apply(this, arguments)
			});
			r._callback = n
		}
		return t
	};
	i.trigger = function(t) {
		if(!this._events)
			return this;
		for(var e = Math.max(0, arguments.length - 1), n = Array(e), i = 0; i < e; i++)
			n[i] = arguments[i + 1];
		return o(u, this._events, t, void 0, n),
			this
	};
	var u = function(t, e, n, i) {
			if(t) {
				var r = t[e],
					o = t.all;
				r && o && (o = o.slice()),
					r && h(r, i),
					o && h(o, [e].concat(i))
			}
			return t
		},
		h = function(t, e) {
			var n, i = -1,
				r = t.length,
				o = e[0],
				a = e[1],
				s = e[2];
			switch(e.length) {
				case 0:
					for(; ++i < r;)
						(n = t[i]).callback.call(n.ctx);
					return;
				case 1:
					for(; ++i < r;)
						(n = t[i]).callback.call(n.ctx, o);
					return;
				case 2:
					for(; ++i < r;)
						(n = t[i]).callback.call(n.ctx, o, a);
					return;
				case 3:
					for(; ++i < r;)
						(n = t[i]).callback.call(n.ctx, o, a, s);
					return;
				default:
					for(; ++i < r;)
						(n = t[i]).callback.apply(n.ctx, e);
					return
			}
		};
	i.bind = i.on,
		i.unbind = i.off,
		e.default = i
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function o(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}

	function a(t, e) {
		if(!t)
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return !e || "object" != typeof e && "function" != typeof e ? t : e
	}

	function s(t, e) {
		if("function" != typeof e && null !== e)
			throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, {
				constructor: {
					value: t,
					enumerable: !1,
					writable: !0,
					configurable: !0
				}
			}),
			e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
	}

	function l(t) {
		X = new R(g.default.resources.model.leftWing, g.default.resources.model.rightWing, g.default.resources.texture.particleNoiseTex, g.default.resources.texture.particleSpriteTex),
			X.position.z = M,
			X.position.y = T,
			X.scale.x = X.scale.y = X.scale.z = 5,
			X.rotation.x = .08 * Math.PI,
			X.visible = !1,
			t.add(X)
	}

	function c() {
		X.visible = !0,
			m.TweenMax.fromTo(X.position, 1, {
				z: 4600,
				x: -780
			}, {
				z: M,
				x: 0,
				ease: Power1.easeOut
			})
	}

	function u() {
		var t = new m.TimelineLite({
				onComplete: function() {
					this.restart()
				}
			}),
			e = X.position.y;
		t.to(X.position, 1.2, {
			y: e - 25,
			ease: Power1.easeInOut
		}).to(X.position, 1.2, {
			y: e,
			ease: Power1.easeInOut
		})
	}

	function h(t) {
		if(X.update(t),
			void 0 !== x.default.expectedControlX) {
			var e = x.default.expectedControlX,
				n = x.default.expectedControlY,
				i = 1,
				r = T + n / i * S + .2 * n * S,
				o = w + e / i * E;
			x.default.avatarPositionY = X.position.y = r,
				x.default.avatarPositionX = X.position.x = o
		}
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var d = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		f = n(9),
		p = r(f),
		m = n(26),
		v = n(14),
		g = i(v),
		_ = n(10),
		y = i(_),
		b = n(11),
		x = i(b),
		w = (y.default.FLOOR_WIDTH,
			y.default.AVATAR_X),
		T = y.default.AVATAR_Y,
		M = y.default.AVATAR_Z,
		E = y.default.X_LIMIT,
		S = y.default.Y_LIMIT,
		X = void 0;
	e.default = {
		init: l,
		update: h,
		show: c,
		float: u
	};
	var A = 0,
		P = new p.Clock(!0),
		R = function(t) {
			function e(t, n, i, r) {
				o(this, e);
				var s = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
				return s.group = new p.Object3D,
					s.kiteGroup = new p.Object3D,
					s.leftPart = t,
					t.children[0].material.side = p.DoubleSide,
					s.leftPart.position.set(-1, 0, 0),
					s.leftPart.scale.set(10, 10, 10),
					s.add(s.leftPart),
					s.rightPart = n,
					s.rightPart.children[0].material.side = p.DoubleSide,
					s.rightPart.position.set(0, 0, 0),
					s.rightPart.scale.set(10, 10, 10),
					s.add(s.rightPart),
					s.kiteGroup.add(s.leftPart),
					s.kiteGroup.add(s.rightPart),
					s.group.add(s.kiteGroup),
					s.spawnerOptions = {
						spawnRate: 5e3,
						horizontalSpeed: 3,
						verticalSpeed: 5,
						timeScale: 1
					},
					s.kiteGroup.position.y = -50,
					s.add(s.group),
					s
			}
			return s(e, t),
				d(e, [{
					key: "update",
					value: function(t) {
						var e = P.getDelta() * this.spawnerOptions.timeScale;
						A += e,
							this.leftPart.rotation.z = Math.sin(10 * A) * p.Math.degToRad(-5),
							this.rightPart.rotation.z = Math.sin(10 * A) * p.Math.degToRad(5),
							this.kiteGroup.rotation.z = Math.sin(2 * A) * p.Math.degToRad(10),
							this.kiteGroup.position.x = 5 * Math.sin(2 * A)
					}
				}]),
				e
		}(p.Object3D)
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function o(t) {
		var e = d.default.resources.model.car.children[0].geometry;
		e = (new l.Geometry).fromBufferGeometry(e);
		var n = new u.default.PrefabBufferGeometry(e, y);
		w = new u.default.StandardAnimationMaterial({
				shading: l.FlatShading,
				vertexColors: l.VertexColors,
				wireframe: !1,
				uniformValues: {
					metalness: .5,
					roughness: .5
				},
				uniforms: {
					uTime: {
						value: 0
					},
					uDuration: {
						value: 1
					}
				},
				vertexFunctions: u.default.ShaderChunk.quaternion_rotation,
				vertexParameters: "\n\t\t\tuniform float uTime;\n\t\t\tuniform float uDuration;\n\t\t\tattribute float aOffset;\n    \tattribute vec4 aRotation;\n\t\t\tattribute vec3 aStartPosition;\n\t\t\tattribute vec3 aEndPosition;\n\t\t\tattribute float aScale;\n\t\t",
				vertexPosition: "\n\t\t\tfloat tProgress = mod((uTime + aOffset), uDuration) / uDuration;\n    \ttransformed = rotateVector(quatFromAxisAngle(aRotation.xyz, aRotation.w), transformed);\n\t\t\ttransformed *= aScale;\n\t\t\ttransformed += mix(aStartPosition, aEndPosition, tProgress);\n\t\t"
			}),
			n.createAttribute("aOffset", 1, function(t, e, n) {
				t[0] = e / n
			});
		var i = [];
		n.createAttribute("aStartPosition", 3, function(t, e) {
				t[0] = l.Math.randFloat(-g, g),
					i.push(t[0]),
					t[1] = e % 2 ? _ : -_,
					t[2] = t[0] > 0 ? -b / 2 : b
			}),
			n.createAttribute("aEndPosition", 3, function(t, e) {
				t[0] = i[e],
					t[1] = e % 2 ? _ : -_,
					t[2] = t[0] > 0 ? b : -b / 2
			});
		new l.Vector3;
		n.createAttribute("aRotation", 4, function(t, e) {
				new l.Vector3(0, 1, 0).toArray(t),
					t[3] = i[e] > 0 ? 0 : Math.PI
			}),
			n.createAttribute("aScale", 1, function(t) {
				t[0] = .3
			});
		var r = new l.Color,
			o = void 0,
			a = void 0,
			s = void 0;
		n.createAttribute("color", 3, function(t, e, n) {
				o = e / n * .1,
					a = l.Math.randFloat(.4, .6),
					s = l.Math.randFloat(.4, .6),
					r.setHSL(o, a, s),
					r.toArray(t)
			}),
			x = new l.Mesh(n, w),
			x.position.z = -b,
			t.add(x)
	}

	function a() {
		0 === v.default.status ? x.visible = !0 : x.visible = !1,
			w && (w.uniforms.uTime.value += .005)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var s = n(9),
		l = r(s),
		c = n(33),
		u = i(c),
		h = n(14),
		d = i(h),
		f = n(10),
		p = i(f),
		m = n(11),
		v = i(m),
		g = p.default.CAR_WIDTH,
		_ = p.default.CAR_HEIGHT,
		y = p.default.CAR_COUNT,
		b = p.default.BUILDING_DEPTH,
		x = (p.default.FLOOR_YPOS,
			void 0),
		w = void 0;
	e.default = {
		init: o,
		update: a
	}
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var o = n(9),
		a = r(o),
		s = n(34),
		l = i(s),
		c = n(35),
		u = i(c),
		h = n(36),
		d = i(h),
		f = n(37),
		p = i(f),
		m = n(38),
		v = i(m),
		g = n(39),
		_ = i(g),
		y = n(40),
		b = i(y),
		x = n(41),
		w = i(x),
		T = n(42),
		M = i(T),
		E = n(43),
		S = i(E),
		X = n(44),
		A = i(X),
		P = n(45),
		R = i(P),
		O = n(46),
		C = i(O),
		L = n(48),
		I = i(L);
	a.BAS = {
			Utils: l.default,
			ShaderChunk: u.default,
			ModelBufferGeometry: d.default,
			PointBufferGeometry: p.default,
			PrefabBufferGeometry: v.default,
			BaseAnimationMaterial: _.default,
			BasicAnimationMaterial: b.default,
			DepthAnimationMaterial: w.default,
			DistanceAnimationMaterial: M.default,
			PhongAnimationMaterial: S.default,
			PointsAnimationMaterial: A.default,
			StandardAnimationMaterial: R.default,
			Timeline: C.default,
			TimelineChunks: I.default
		},
		a.BAS.Timeline.register("rotate", {
			compiler: function(t) {
				var e = new a.Vector4(t.transition.from.axis.x, t.transition.from.axis.y, t.transition.from.axis.z, t.transition.from.angle),
					n = t.transition.to.axis || t.transition.from.axis,
					i = new a.Vector4(n.x, n.y, n.z, t.transition.to.angle),
					r = t.transition.origin;
				return [I.default.delayDuration(t), I.default.vec4("cRotationFrom" + t.key, e, 8), I.default.vec4("cRotationTo" + t.key, i, 8), r && I.default.vec3("cOrigin" + t.key, r, 2), "void applyTransform" + t.key + "(float time, inout vec3 v) {", I.default.renderCheck(t), I.default.progress(t), r && "v -= cOrigin" + t.key + ";", "vec3 axis = normalize(mix(cRotationFrom" + t.key + ".xyz, cRotationTo" + t.key + ".xyz, progress));", "float angle = mix(cRotationFrom" + t.key + ".w, cRotationTo" + t.key + ".w, progress);", "vec4 q = quatFromAxisAngle(axis, angle);", "v = rotateVector(q, v);", r && "v += cOrigin" + t.key + ";", "}"].join("\n")
			},
			defaultFrom: {
				axis: new a.Vector3,
				angle: 0
			}
		}),
		a.BAS.Timeline.register("scale", {
			compiler: function(t) {
				var e = t.transition.origin;
				return [I.default.delayDuration(t), I.default.vec3("cScaleFrom" + t.key, t.transition.from, 2), I.default.vec3("cScaleTo" + t.key, t.transition.to, 2), e && I.default.vec3("cOrigin" + t.key, e, 2), "void applyTransform" + t.key + "(float time, inout vec3 v) {", I.default.renderCheck(t), I.default.progress(t), e && "v -= cOrigin" + t.key + ";", "v *= mix(cScaleFrom" + t.key + ", cScaleTo" + t.key + ", progress);", e && "v += cOrigin" + t.key + ";", "}"].join("\n")
			},
			defaultFrom: new a.Vector3(1, 1, 1)
		}),
		a.BAS.Timeline.register("translate", {
			compiler: function(t) {
				return [I.default.delayDuration(t), I.default.vec3("cTranslateFrom" + t.key, t.transition.from, 2), I.default.vec3("cTranslateTo" + t.key, t.transition.to, 2), "void applyTransform" + t.key + "(float time, inout vec3 v) {", I.default.renderCheck(t), I.default.progress(t), "v += mix(cTranslateFrom" + t.key + ", cTranslateTo" + t.key + ", progress);", "}"].join("\n")
			},
			defaultFrom: new a.Vector3(0, 0, 0)
		}),
		e.default = a.BAS
}, function(t, e, n) {
	"use strict";

	function i(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var r = n(9),
		o = i(r),
		a = {
			separateFaces: function(t) {
				for(var e = [], n = 0, i = t.faces.length; n < i; n++) {
					var r = e.length,
						o = t.faces[n],
						a = o.a,
						s = o.b,
						l = o.c,
						c = t.vertices[a],
						u = t.vertices[s],
						h = t.vertices[l];
					e.push(c.clone()),
						e.push(u.clone()),
						e.push(h.clone()),
						o.a = r,
						o.b = r + 1,
						o.c = r + 2
				}
				t.vertices = e
			},
			computeCentroid: function(t, e, n) {
				var i = t.vertices[e.a],
					r = t.vertices[e.b],
					a = t.vertices[e.c];
				return n = n || new o.Vector3,
					n.x = (i.x + r.x + a.x) / 3,
					n.y = (i.y + r.y + a.y) / 3,
					n.z = (i.z + r.z + a.z) / 3,
					n
			},
			randomInBox: function(t, e) {
				return e = e || new o.Vector3,
					e.x = o.Math.randFloat(t.min.x, t.max.x),
					e.y = o.Math.randFloat(t.min.y, t.max.y),
					e.z = o.Math.randFloat(t.min.z, t.max.z),
					e
			},
			randomAxis: function(t) {
				return t = t || new o.Vector3,
					t.x = o.Math.randFloatSpread(2),
					t.y = o.Math.randFloatSpread(2),
					t.z = o.Math.randFloatSpread(2),
					t.normalize(),
					t
			},
			createDepthAnimationMaterial: function(t) {
				return new o.BAS.DepthAnimationMaterial({
					uniforms: t.uniforms,
					vertexFunctions: t.vertexFunctions,
					vertexParameters: t.vertexParameters,
					vertexInit: t.vertexInit,
					vertexPosition: t.vertexPosition
				})
			},
			createDistanceAnimationMaterial: function(t) {
				return new o.BAS.DistanceAnimationMaterial({
					uniforms: t.uniforms,
					vertexFunctions: t.vertexFunctions,
					vertexParameters: t.vertexParameters,
					vertexInit: t.vertexInit,
					vertexPosition: t.vertexPosition
				})
			}
		};
	e.default = a
}, function(t, e, n) {
	"use strict";

	function i(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var r = n(9),
		o = (i(r), {});
	o.catmull_rom_spline = "\n\tvec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, vec2 c) {\n    vec4 v0 = (p2 - p0) * c.x;\n    vec4 v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n\n    return vec4((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n\t}\n\tvec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t) {\n\t\t\treturn catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n\t}\n\n\tvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t, vec2 c) {\n\t\t\tvec3 v0 = (p2 - p0) * c.x;\n\t\t\tvec3 v1 = (p3 - p1) * c.y;\n\t\t\tfloat t2 = t * t;\n\t\t\tfloat t3 = t * t * t;\n\n\t\t\treturn vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n\t}\n\tvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\n\t\t\treturn catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n\t}\n\n\tvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t, vec2 c) {\n\t\t\tvec2 v0 = (p2 - p0) * c.x;\n\t\t\tvec2 v1 = (p3 - p1) * c.y;\n\t\t\tfloat t2 = t * t;\n\t\t\tfloat t3 = t * t * t;\n\n\t\t\treturn vec2((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n\t}\n\tvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n\t\t\treturn catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n\t}\n\n\tfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t, vec2 c) {\n\t\t\tfloat v0 = (p2 - p0) * c.x;\n\t\t\tfloat v1 = (p3 - p1) * c.y;\n\t\t\tfloat t2 = t * t;\n\t\t\tfloat t3 = t * t * t;\n\n\t\t\treturn float((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n\t}\n\tfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t) {\n\t\t\treturn catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n\t}\n\n\tivec4 getCatmullRomSplineIndices(float l, float p) {\n\t\t\tfloat index = floor(p);\n\t\t\tint i0 = int(max(0.0, index - 1.0));\n\t\t\tint i1 = int(index);\n\t\t\tint i2 = int(min(index + 1.0, l));\n\t\t\tint i3 = int(min(index + 2.0, l));\n\n\t\t\treturn ivec4(i0, i1, i2, i3);\n\t}\n\n\tivec4 getCatmullRomSplineIndicesClosed(float l, float p) {\n\t\t\tfloat index = floor(p);\n\t\t\tint i0 = int(index == 0.0 ? l : index - 1.0);\n\t\t\tint i1 = int(index);\n\t\t\tint i2 = int(mod(index + 1.0, l));\n\t\t\tint i3 = int(mod(index + 2.0, l));\n\n\t\t\treturn ivec4(i0, i1, i2, i3);\n\t}\n",
		o.cubic_bezier = "\n\tvec3 cubicBezier(vec3 p0, vec3 c0, vec3 c1, vec3 p1, float t) {\n\t\t\tfloat tn = 1.0 - t;\n\n\t\t\treturn tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\n\t}\n\n\tvec2 cubicBezier(vec2 p0, vec2 c0, vec2 c1, vec2 p1, float t) {\n\t\t\tfloat tn = 1.0 - t;\n\n\t\t\treturn tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\n\t}\n",
		o.ease_back_in = "\n\tfloat easeBackIn(float p, float amplitude) {\n\t\t\treturn p * p * ((amplitude + 1.0) * p - amplitude);\n\t}\n\n\tfloat easeBackIn(float p) {\n\t\t\treturn easeBackIn(p, 1.70158);\n\t}\n\n\tfloat easeBackIn(float t, float b, float c, float d, float amplitude) {\n\t\t\treturn b + easeBackIn(t / d, amplitude) * c;\n\t}\n\n\tfloat easeBackIn(float t, float b, float c, float d) {\n\t\t\treturn b + easeBackIn(t / d) * c;\n\t}\n",
		o.ease_back_in_out = "\n\tfloat easeBackInOut(float p, float amplitude) {\n\t\t\tamplitude *= 1.525;\n\n\t\t\treturn ((p *= 2.0) < 1.0) ? 0.5 * p * p * ((amplitude + 1.0) * p - amplitude) : 0.5 * ((p -= 2.0) * p * ((amplitude + 1.0) * p + amplitude) + 2.0);\n\t}\n\n\tfloat easeBackInOut(float p) {\n\t\t\treturn easeBackInOut(p, 1.70158);\n\t}\n\n\tfloat easeBackInOut(float t, float b, float c, float d, float amplitude) {\n\t\t\treturn b + easeBackInOut(t / d, amplitude) * c;\n\t}\n\n\tfloat easeBackInOut(float t, float b, float c, float d) {\n\t\t\treturn b + easeBackInOut(t / d) * c;\n\t}\n",
		o.ease_back_out = "\n\tfloat easeBackOut(float p, float amplitude) {\n    return ((p = p - 1.0) * p * ((amplitude + 1.0) * p + amplitude) + 1.0);\n\t}\n\n\tfloat easeBackOut(float p) {\n\t\t\treturn easeBackOut(p, 1.70158);\n\t}\n\n\tfloat easeBackOut(float t, float b, float c, float d, float amplitude) {\n\t\t\treturn b + easeBackOut(t / d, amplitude) * c;\n\t}\n\n\tfloat easeBackOut(float t, float b, float c, float d) {\n\t\t\treturn b + easeBackOut(t / d) * c;\n\t}\n",
		o.ease_bezier = "\n\tfloat easeBezier(float p, vec4 curve) {\n\t\t\tfloat ip = 1.0 - p;\n\t\t\treturn (3.0 * ip * ip * p * curve.xy + 3.0 * ip * p * p * curve.zw + p * p * p).y;\n\t}\n\n\tfloat easeBezier(float t, float b, float c, float d, vec4 curve) {\n\t\t\treturn b + easeBezier(t / d, curve) * c;\n\t}\n",
		o.ease_bounce_in = "\n\tfloat easeBounceIn(float p) {\n    if ((p = 1.0 - p) < 1.0 / 2.75) {\n        return 1.0 - (7.5625 * p * p);\n    } else if (p < 2.0 / 2.75) {\n        return 1.0 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);\n    } else if (p < 2.5 / 2.75) {\n        return 1.0 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);\n    }\n    return 1.0 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);\n\t}\n\n\tfloat easeBounceIn(float t, float b, float c, float d) {\n\t\t\treturn b + easeBounceIn(t / d) * c;\n\t}\n",
		o.ease_bounce_in_out = "\n\tfloat easeBounceInOut(float p) {\n    bool invert = (p < 0.5);\n\n    p = invert ? (1.0 - (p * 2.0)) : ((p * 2.0) - 1.0);\n\n    if (p < 1.0 / 2.75) {\n        p = 7.5625 * p * p;\n    } else if (p < 2.0 / 2.75) {\n        p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\n    } else if (p < 2.5 / 2.75) {\n        p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\n    } else {\n        p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\n    }\n\n    return invert ? (1.0 - p) * 0.5 : p * 0.5 + 0.5;\n\t}\n\n\tfloat easeBounceInOut(float t, float b, float c, float d) {\n\t\t\treturn b + easeBounceInOut(t / d) * c;\n\t}\n",
		o.ease_bounce_out = "\n\tfloat easeBounceOut(float p) {\n    if (p < 1.0 / 2.75) {\n        return 7.5625 * p * p;\n    } else if (p < 2.0 / 2.75) {\n        return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\n    } else if (p < 2.5 / 2.75) {\n        return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\n    }\n    return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\n\t}\n\n\tfloat easeBounceOut(float t, float b, float c, float d) {\n\t\t\treturn b + easeBounceOut(t / d) * c;\n\t}\n",
		o.ease_circ_in = "\n\tfloat easeCircIn(float p) {\n    return -(sqrt(1.0 - p * p) - 1.0);\n\t}\n\n\tfloat easeCircIn(float t, float b, float c, float d) {\n\t\t\treturn b + easeCircIn(t / d) * c;\n\t}\n",
		o.ease_circ_in_out = "\n\tfloat easeCircInOut(float p) {\n    return ((p *= 2.0) < 1.0) ? -0.5 * (sqrt(1.0 - p * p) - 1.0) : 0.5 * (sqrt(1.0 - (p -= 2.0) * p) + 1.0);\n\t}\n\n\tfloat easeCircInOut(float t, float b, float c, float d) {\n\t\t\treturn b + easeCircInOut(t / d) * c;\n\t}\n",
		o.ease_circ_out = "\n\tfloat easeCircOut(float p) {\n\t\treturn sqrt(1.0 - (p = p - 1.0) * p);\n\t}\n\n\tfloat easeCircOut(float t, float b, float c, float d) {\n\t\treturn b + easeCircOut(t / d) * c;\n\t}\n",
		o.ease_cubic_in = "\n\tfloat easeCubicIn(float t) {\n\t\treturn t * t * t;\n\t}\n\n\tfloat easeCubicIn(float t, float b, float c, float d) {\n\t\treturn b + easeCubicIn(t / d) * c;\n\t}\n",
		o.ease_cubic_in_out = "\n\tfloat easeCubicInOut(float t) {\n\t\treturn (t /= 0.5) < 1.0 ? 0.5 * t * t * t : 0.5 * ((t-=2.0) * t * t + 2.0);\n\t}\n\n\tfloat easeCubicInOut(float t, float b, float c, float d) {\n\t\treturn b + easeCubicInOut(t / d) * c;\n\t}\n",
		o.ease_cubic_out = "\n\tfloat easeCubicOut(float t) {\n\t\tfloat f = t - 1.0;\n\t\treturn f * f * f + 1.0;\n\t}\n\n\tfloat easeCubicOut(float t, float b, float c, float d) {\n\t\treturn b + easeCubicOut(t / d) * c;\n\t}\n",
		o.ease_elastic_in = "\n\tfloat easeElasticIn(float p, float amplitude, float period) {\n\t\t\tfloat p1 = max(amplitude, 1.0);\n\t\t\tfloat p2 = period / min(amplitude, 1.0);\n\t\t\tfloat p3 = p2 / PI2 * (asin(1.0 / p1));\n\n\t\t\treturn -(p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2));\n\t}\n\n\tfloat easeElasticIn(float p) {\n\t\t\treturn easeElasticIn(p, 1.0, 0.3);\n\t}\n\n\tfloat easeElasticIn(float t, float b, float c, float d, float amplitude, float period) {\n\t\t\treturn b + easeElasticIn(t / d, amplitude, period) * c;\n\t}\n\n\tfloat easeElasticIn(float t, float b, float c, float d) {\n\t\t\treturn b + easeElasticIn(t / d) * c;\n\t}\n",
		o.ease_elastic_in_out = "\n\tfloat easeElasticInOut(float p, float amplitude, float period) {\n\t\t\tfloat p1 = max(amplitude, 1.0);\n\t\t\tfloat p2 = period / min(amplitude, 1.0);\n\t\t\tfloat p3 = p2 / PI2 * (asin(1.0 / p1));\n\n\t\t\treturn ((p *= 2.0) < 1.0) ? -0.5 * (p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2)) : p1 * pow(2.0, -10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2) * 0.5 + 1.0;\n\t}\n\n\tfloat easeElasticInOut(float p) {\n\t\t\treturn easeElasticInOut(p, 1.0, 0.3);\n\t}\n\n\tfloat easeElasticInOut(float t, float b, float c, float d, float amplitude, float period) {\n\t\t\treturn b + easeElasticInOut(t / d, amplitude, period) * c;\n\t}\n\n\tfloat easeElasticInOut(float t, float b, float c, float d) {\n\t\t\treturn b + easeElasticInOut(t / d) * c;\n\t}\n",
		o.ease_elastic_out = "\n\tfloat easeElasticOut(float p, float amplitude, float period) {\n\t\t\tfloat p1 = max(amplitude, 1.0);\n\t\t\tfloat p2 = period / min(amplitude, 1.0);\n\t\t\tfloat p3 = p2 / PI2 * (asin(1.0 / p1));\n\n\t\t\treturn p1 * pow(2.0, -10.0 * p) * sin((p - p3) * PI2 / p2) + 1.0;\n\t}\n\n\tfloat easeElasticOut(float p) {\n\t\t\treturn easeElasticOut(p, 1.0, 0.3);\n\t}\n\n\tfloat easeElasticOut(float t, float b, float c, float d, float amplitude, float period) {\n\t\t\treturn b + easeElasticOut(t / d, amplitude, period) * c;\n\t}\n\n\tfloat easeElasticOut(float t, float b, float c, float d) {\n\t\t\treturn b + easeElasticOut(t / d) * c;\n\t}\n",
		o.ease_expo_in = "\n\tfloat easeExpoIn(float p) {\n\t\t\treturn pow(2.0, 10.0 * (p - 1.0));\n\t}\n\n\tfloat easeExpoIn(float t, float b, float c, float d) {\n\t\t\treturn b + easeExpoIn(t / d) * c;\n\t}\n",
		o.ease_expo_in_out = "\n\tfloat easeExpoInOut(float p) {\n\t\t\treturn ((p *= 2.0) < 1.0) ? 0.5 * pow(2.0, 10.0 * (p - 1.0)) : 0.5 * (2.0 - pow(2.0, -10.0 * (p - 1.0)));\n\t}\n\n\tfloat easeExpoInOut(float t, float b, float c, float d) {\n\t\t\treturn b + easeExpoInOut(t / d) * c;\n\t}\n",
		o.ease_expo_out = "\n\tfloat easeExpoOut(float p) {\n\t\treturn 1.0 - pow(2.0, -10.0 * p);\n\t}\n\n\tfloat easeExpoOut(float t, float b, float c, float d) {\n\t\treturn b + easeExpoOut(t / d) * c;\n\t}\n",
		o.ease_quad_in = "\n\tfloat easeQuadIn(float t) {\n\t\t\treturn t * t;\n\t}\n\n\tfloat easeQuadIn(float t, float b, float c, float d) {\n\t\treturn b + easeQuadIn(t / d) * c;\n\t}\n",
		o.ease_quad_in_out = "\n\tfloat easeQuadInOut(float t) {\n\t\t\tfloat p = 2.0 * t * t;\n\t\t\treturn t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n\t}\n\n\tfloat easeQuadInOut(float t, float b, float c, float d) {\n\t\t\treturn b + easeQuadInOut(t / d) * c;\n\t}\n",
		o.ease_quad_out = "\n\tfloat easeQuadOut(float t) {\n\t\treturn -t * (t - 2.0);\n\t}\n\n\tfloat easeQuadOut(float t, float b, float c, float d) {\n\t\treturn b + easeQuadOut(t / d) * c;\n\t}\n",
		o.ease_quart_in = "\n\tfloat easeQuartIn(float t) {\n\t\treturn t * t * t * t;\n\t}\n\n\tfloat easeQuartIn(float t, float b, float c, float d) {\n\t\treturn b + easeQuartIn(t / d) * c;\n\t}\n",
		o.ease_quart_in_out = "\n\tfloat easeQuartInOut(float t) {\n\t\t\treturn t < 0.5 ? 8.0 * pow(t, 4.0) : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n\t}\n\n\tfloat easeQuartInOut(float t, float b, float c, float d) {\n\t\t\treturn b + easeQuartInOut(t / d) * c;\n\t}\n",
		o.ease_quart_out = "\n\tfloat easeQuartOut(float t) {\n\t\treturn 1.0 - pow(1.0 - t, 4.0);\n\t}\n\n\tfloat easeQuartOut(float t, float b, float c, float d) {\n\t\treturn b + easeQuartOut(t / d) * c;\n\t}\n",
		o.ease_quint_in = "\n\tfloat easeQuintIn(float t) {\n\t\t\treturn pow(t, 5.0);\n\t}\n\n\tfloat easeQuintIn(float t, float b, float c, float d) {\n\t\t\treturn b + easeQuintIn(t / d) * c;\n\t}\n",
		o.ease_quint_in_out = "\n\tfloat easeQuintInOut(float t) {\n\t\t\treturn (t /= 0.5) < 1.0 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2.0) * t * t * t * t + 2.0);\n\t}\n\n\tfloat easeQuintInOut(float t, float b, float c, float d) {\n\t\t\treturn b + easeQuintInOut(t / d) * c;\n\t}\n",
		o.ease_quint_out = "\n\tfloat easeQuintOut(float t) {\n\t\t\treturn (t -= 1.0) * t * t * t * t + 1.0;\n\t}\n\n\tfloat easeQuintOut(float t, float b, float c, float d) {\n\t\t\treturn b + easeQuintOut(t / d) * c;\n\t}\n",
		o.ease_sine_in = "\n\tfloat easeSineIn(float p) {\n\t\treturn -cos(p * 1.57079632679) + 1.0;\n\t}\n\n\tfloat easeSineIn(float t, float b, float c, float d) {\n\t\treturn b + easeSineIn(t / d) * c;\n\t}\n",
		o.ease_sine_in_out = "\n\tfloat easeSineInOut(float p) {\n\t\treturn -0.5 * (cos(PI * p) - 1.0);\n\t}\n\n\tfloat easeSineInOut(float t, float b, float c, float d) {\n\t\treturn b + easeSineInOut(t / d) * c;\n\t}\n",
		o.ease_sine_out = "\n\tfloat easeSineOut(float p) {\n\t\treturn sin(p * 1.57079632679);\n\t}\n\n\tfloat easeSineOut(float t, float b, float c, float d) {\n\t\treturn b + easeSineOut(t / d) * c;\n\t}\n",
		o.quaternion_rotation = "\n\tvec3 rotateVector(vec4 q, vec3 v) {\n\t\t\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n\t}\n\n\tvec4 quatFromAxisAngle(vec3 axis, float angle) {\n\t\t\tfloat halfAngle = angle * 0.5;\n\t\t\treturn vec4(axis.xyz * sin(halfAngle), cos(halfAngle));\n\t}\n",
		o.quaternion_slerp = "\n\tvec4 quatSlerp(vec4 q0, vec4 q1, float t) {\n    float s = 1.0 - t;\n    float c = dot(q0, q1);\n    float dir = -1.0; //c >= 0.0 ? 1.0 : -1.0;\n    float sqrSn = 1.0 - c * c;\n\n    if (sqrSn > 2.220446049250313e-16) {\n        float sn = sqrt(sqrSn);\n        float len = atan(sn, c * dir);\n\n        s = sin(s * len) / sn;\n        t = sin(t * len) / sn;\n    }\n\n    float tDir = t * dir;\n\n    return normalize(q0 * s + q1 * tDir);\n}\n",
		e.default = o
}, function(t, e, n) {
	"use strict";

	function i(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function r(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}

	function o(t, e) {
		if(!t)
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return !e || "object" != typeof e && "function" != typeof e ? t : e
	}

	function a(t, e) {
		if("function" != typeof e && null !== e)
			throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, {
				constructor: {
					value: t,
					enumerable: !1,
					writable: !0,
					configurable: !0
				}
			}),
			e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var s = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		l = n(9),
		c = i(l),
		u = function(t) {
			function e(t, n) {
				r(this, e);
				var i = o(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
				return i.modelGeometry = t,
					i.faceCount = i.modelGeometry.faces.length,
					i.vertexCount = i.modelGeometry.vertices.length,
					n = n || {},
					n.computeCentroids && i.computeCentroids(),
					i.bufferIndices(),
					i.bufferPositions(n.localizeFaces),
					i
			}
			return a(e, t),
				s(e, [{
					key: "computeCentroids",
					value: function() {
						this.centroids = [];
						for(var t = 0; t < this.faceCount; t++)
							this.centroids[t] = c.BAS.Utils.computeCentroid(this.modelGeometry, this.modelGeometry.faces[t])
					}
				}, {
					key: "bufferIndices",
					value: function() {
						var t = new Uint32Array(3 * this.faceCount);
						this.setIndex(new c.BufferAttribute(t, 1));
						for(var e = 0, n = 0; e < this.faceCount; e++,
							n += 3) {
							var i = this.modelGeometry.faces[e];
							t[n] = i.a,
								t[n + 1] = i.b,
								t[n + 2] = i.c
						}
					}
				}, {
					key: "bufferPositions",
					value: function(t) {
						var e, n, i = this.createAttribute("position", 3).array;
						if(t === !0)
							for(e = 0; e < this.faceCount; e++) {
								var r = this.modelGeometry.faces[e],
									o = this.centroids ? this.centroids[e] : c.BAS.Utils.computeCentroid(this.modelGeometry, r),
									a = this.modelGeometry.vertices[r.a],
									s = this.modelGeometry.vertices[r.b],
									l = this.modelGeometry.vertices[r.c];
								i[3 * r.a] = a.x - o.x,
									i[3 * r.a + 1] = a.y - o.y,
									i[3 * r.a + 2] = a.z - o.z,
									i[3 * r.b] = s.x - o.x,
									i[3 * r.b + 1] = s.y - o.y,
									i[3 * r.b + 2] = s.z - o.z,
									i[3 * r.c] = l.x - o.x,
									i[3 * r.c + 1] = l.y - o.y,
									i[3 * r.c + 2] = l.z - o.z
							}
						else
							for(e = 0,
								n = 0; e < this.vertexCount; e++,
								n += 3) {
								var u = this.modelGeometry.vertices[e];
								i[n] = u.x,
									i[n + 1] = u.y,
									i[n + 2] = u.z
							}
					}
				}, {
					key: "bufferUVs",
					value: function() {
						for(var t = this.createAttribute("uv", 2).array, e = 0; e < this.faceCount; e++) {
							var n, i = this.modelGeometry.faces[e];
							n = this.modelGeometry.faceVertexUvs[0][e][0],
								t[2 * i.a] = n.x,
								t[2 * i.a + 1] = n.y,
								n = this.modelGeometry.faceVertexUvs[0][e][1],
								t[2 * i.b] = n.x,
								t[2 * i.b + 1] = n.y,
								n = this.modelGeometry.faceVertexUvs[0][e][2],
								t[2 * i.c] = n.x,
								t[2 * i.c + 1] = n.y
						}
					}
				}, {
					key: "createAttribute",
					value: function(t, e, n) {
						var i = new Float32Array(this.vertexCount * e),
							r = new c.BufferAttribute(i, e);
						if(this.addAttribute(t, r),
							n)
							for(var o = [], a = 0; a < this.faceCount; a++)
								n(o, a, this.faceCount),
								this.setFaceData(r, a, o);
						return r
					}
				}, {
					key: "setFaceData",
					value: function(t, e, n) {
						t = "string" == typeof t ? this.attributes[t] : t;
						for(var i = 3 * e * t.itemSize, r = 0; r < 3; r++)
							for(var o = 0; o < t.itemSize; o++)
								t.array[i++] = n[o]
					}
				}]),
				e
		}(c.BufferGeometry);
	e.default = u
}, function(t, e, n) {
	"use strict";

	function i(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function r(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}

	function o(t, e) {
		if(!t)
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return !e || "object" != typeof e && "function" != typeof e ? t : e
	}

	function a(t, e) {
		if("function" != typeof e && null !== e)
			throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, {
				constructor: {
					value: t,
					enumerable: !1,
					writable: !0,
					configurable: !0
				}
			}),
			e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var s = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		l = n(9),
		c = i(l),
		u = function(t) {
			function e(t) {
				r(this, e);
				var n = o(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
				return n.pointCount = t,
					n.bufferIndices(),
					n.bufferPositions(),
					n
			}
			return a(e, t),
				s(e, [{
					key: "bufferIndices",
					value: function() {
						var t = this.pointCount,
							e = new Uint32Array(t);
						this.setIndex(new c.BufferAttribute(e, 1));
						for(var n = 0; n < t; n++)
							e[n] = n
					}
				}, {
					key: "bufferPositions",
					value: function() {
						this.createAttribute("position", 3)
					}
				}, {
					key: "createAttribute",
					value: function(t, e, n) {
						var i = new Float32Array(this.pointCount * e),
							r = new c.BufferAttribute(i, e);
						if(this.addAttribute(t, r),
							n)
							for(var o = [], a = 0; a < this.pointCount; a++)
								n(o, a, this.pointCount),
								this.setPointData(r, a, o);
						return r
					}
				}, {
					key: "setPointData",
					value: function(t, e, n) {
						t = "string" == typeof t ? this.attributes[t] : t;
						for(var i = e * t.itemSize, r = 0; r < t.itemSize; r++)
							t.array[i++] = n[r]
					}
				}]),
				e
		}(c.BufferGeometry);
	e.default = u
}, function(t, e, n) {
	"use strict";

	function i(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function r(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}

	function o(t, e) {
		if(!t)
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return !e || "object" != typeof e && "function" != typeof e ? t : e
	}

	function a(t, e) {
		if("function" != typeof e && null !== e)
			throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, {
				constructor: {
					value: t,
					enumerable: !1,
					writable: !0,
					configurable: !0
				}
			}),
			e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var s = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		l = n(9),
		c = i(l),
		u = function(t) {
			function e(t, n) {
				r(this, e);
				var i = o(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
				return i.prefabGeometry = t,
					i.prefabCount = n,
					i.prefabVertexCount = t.vertices.length,
					i.bufferIndices(),
					i.bufferPositions(),
					i
			}
			return a(e, t),
				s(e, [{
					key: "bufferIndices",
					value: function() {
						for(var t = this.prefabGeometry.faces.length, e = 3 * this.prefabGeometry.faces.length, n = [], i = 0; i < t; i++) {
							var r = this.prefabGeometry.faces[i];
							n.push(r.a, r.b, r.c)
						}
						var o = new Uint32Array(this.prefabCount * e);
						this.setIndex(new c.BufferAttribute(o, 1));
						for(var a = 0; a < this.prefabCount; a++)
							for(var s = 0; s < e; s++)
								o[a * e + s] = n[s] + a * this.prefabVertexCount
					}
				}, {
					key: "bufferPositions",
					value: function() {
						for(var t = this.createAttribute("position", 3).array, e = 0, n = 0; e < this.prefabCount; e++)
							for(var i = 0; i < this.prefabVertexCount; i++,
								n += 3) {
								var r = this.prefabGeometry.vertices[i];
								t[n] = r.x,
									t[n + 1] = r.y,
									t[n + 2] = r.z
							}
					}
				}, {
					key: "bufferUvs",
					value: function() {
						for(var t = this.prefabGeometry.faces.length, e = this.prefabVertexCount = this.prefabGeometry.vertices.length, n = [], i = 0; i < t; i++) {
							var r = this.prefabGeometry.faces[i],
								o = this.prefabGeometry.faceVertexUvs[0][i];
							n[r.a] = o[0],
								n[r.b] = o[1],
								n[r.c] = o[2]
						}
						for(var a = this.createAttribute("uv", 2), s = 0, l = 0; s < this.prefabCount; s++)
							for(var c = 0; c < e; c++,
								l += 2) {
								var u = n[c];
								a.array[l] = u.x,
									a.array[l + 1] = u.y
							}
					}
				}, {
					key: "createAttribute",
					value: function(t, e, n) {
						var i = new Float32Array(this.prefabCount * this.prefabVertexCount * e),
							r = new c.BufferAttribute(i, e);
						if(this.addAttribute(t, r),
							n)
							for(var o = [], a = 0; a < this.prefabCount; a++)
								n(o, a, this.prefabCount),
								this.setPrefabData(r, a, o);
						return r
					}
				}, {
					key: "setPrefabData",
					value: function(t, e, n) {
						t = "string" == typeof t ? this.attributes[t] : t;
						for(var i = e * this.prefabVertexCount * t.itemSize, r = 0; r < this.prefabVertexCount; r++)
							for(var o = 0; o < t.itemSize; o++)
								t.array[i++] = n[o]
					}
				}]),
				e
		}(c.BufferGeometry);
	e.default = u
}, function(t, e, n) {
	"use strict";

	function i(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function r(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}

	function o(t, e) {
		if(!t)
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return !e || "object" != typeof e && "function" != typeof e ? t : e
	}

	function a(t, e) {
		if("function" != typeof e && null !== e)
			throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, {
				constructor: {
					value: t,
					enumerable: !1,
					writable: !0,
					configurable: !0
				}
			}),
			e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var s = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		l = n(9),
		c = i(l),
		u = function(t) {
			function e(t, n) {
				r(this, e);
				var i = o(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
				i.init && i.init();
				var a = t.uniformValues;
				if(delete t.uniformValues,
					i.setValues(t),
					i.uniforms = c.UniformsUtils.merge([n, i.uniforms]),
					i.setUniformValues(a),
					a && (a.map && (i.defines.USE_MAP = ""),
						a.normalMap && (i.defines.USE_NORMALMAP = ""),
						a.envMap && (i.defines.USE_ENVMAP = ""),
						a.aoMap && (i.defines.USE_AOMAP = ""),
						a.specularMap && (i.defines.USE_SPECULARMAP = ""),
						a.alphaMap && (i.defines.USE_ALPHAMAP = ""),
						a.lightMap && (i.defines.USE_LIGHTMAP = ""),
						a.emissiveMap && (i.defines.USE_EMISSIVEMAP = ""),
						a.bumpMap && (i.defines.USE_BUMPMAP = ""),
						a.displacementMap && (i.defines.USE_DISPLACEMENTMAP = ""),
						a.roughnessMap && (i.defines.USE_DISPLACEMENTMAP = ""),
						a.roughnessMap && (i.defines.USE_ROUGHNESSMAP = ""),
						a.metalnessMap && (i.defines.USE_METALNESSMAP = ""),
						a.envMap)) {
					i.defines.USE_ENVMAP = "";
					var s = "ENVMAP_TYPE_CUBE",
						l = "ENVMAP_MODE_REFLECTION",
						u = "ENVMAP_BLENDING_MULTIPLY";
					switch(a.envMap.mapping) {
						case c.CubeReflectionMapping:
						case c.CubeRefractionMapping:
							s = "ENVMAP_TYPE_CUBE";
							break;
						case c.CubeUVReflectionMapping:
						case c.CubeUVRefractionMapping:
							s = "ENVMAP_TYPE_CUBE_UV";
							break;
						case c.EquirectangularReflectionMapping:
						case c.EquirectangularRefractionMapping:
							s = "ENVMAP_TYPE_EQUIREC";
							break;
						case c.SphericalReflectionMapping:
							s = "ENVMAP_TYPE_SPHERE"
					}
					switch(a.envMap.mapping) {
						case c.CubeRefractionMapping:
						case c.EquirectangularRefractionMapping:
							l = "ENVMAP_MODE_REFRACTION"
					}
					switch(a.combine) {
						case c.MixOperation:
							u = "ENVMAP_BLENDING_MIX";
							break;
						case c.AddOperation:
							u = "ENVMAP_BLENDING_ADD";
							break;
						case c.MultiplyOperation:
						default:
							u = "ENVMAP_BLENDING_MULTIPLY"
					}
					i.defines[s] = "",
						i.defines[u] = "",
						i.defines[l] = ""
				}
				return i
			}
			return a(e, t),
				s(e, [{
					key: "setUniformValues",
					value: function(t) {
						for(var e in t)
							if(e in this.uniforms) {
								var n = this.uniforms[e],
									i = t[e];
								n.value = i
							}
					}
				}, {
					key: "_stringifyChunk",
					value: function(t) {
						return this[t] ? this[t].join("\n") : ""
					}
				}]),
				e
		}(c.ShaderMaterial);
	e.default = u
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function o(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}

	function a(t, e) {
		if(!t)
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return !e || "object" != typeof e && "function" != typeof e ? t : e
	}

	function s(t, e) {
		if("function" != typeof e && null !== e)
			throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, {
				constructor: {
					value: t,
					enumerable: !1,
					writable: !0,
					configurable: !0
				}
			}),
			e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var l = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		c = n(9),
		u = r(c),
		h = n(39),
		d = i(h),
		f = function(t) {
			function e(t) {
				o(this, e);
				var n = u.ShaderLib.basic,
					i = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n.uniforms));
				return i.lights = !1,
					i.vertexShader = i._concatVertexShader(),
					i.fragmentShader = i._concatFragmentShader(),
					i
			}
			return s(e, t),
				l(e, [{
					key: "init",
					value: function() {
						this.varyingParameters = [],
							this.vertexFunctions = [],
							this.vertexParameters = [],
							this.vertexInit = [],
							this.vertexNormal = [],
							this.vertexPosition = [],
							this.vertexColor = [],
							this.fragmentFunctions = [],
							this.fragmentParameters = [],
							this.fragmentInit = [],
							this.fragmentMap = [],
							this.fragmentDiffuse = []
					}
				}, {
					key: "_concatVertexShader",
					value: function() {
						return "\n\t\t\t#include <common>\n\t\t\t#include <uv_pars_vertex>\n\t\t\t#include <uv2_pars_vertex>\n\t\t\t#include <envmap_pars_vertex>\n\t\t\t#include <color_pars_vertex>\n\t\t\t#include <morphtarget_pars_vertex>\n\t\t\t#include <skinning_pars_vertex>\n\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t#include <clipping_planes_pars_vertex>\n\n\t\t\t" + this.vertexFunctions + "\n\t\t\t" + this.vertexParameters + "\n\t\t\t" + this.varyingParameters + "\n\n\t\t\tvoid main() {\n\n\t\t\t\t" + this.vertexInit + "\n\n\t\t\t\t#include <uv_vertex>\n\t\t\t\t#include <uv2_vertex>\n\t\t\t\t#include <color_vertex>\n\t\t\t\t#include <skinbase_vertex>\n\n\t\t\t\t#ifdef USE_ENVMAP\n\n\t\t\t\t\t#include <beginnormal_vertex>\n\n\t\t\t\t\t" + this.vertexNormal + "\n\n\t\t\t\t\t#include <morphnormal_vertex>\n\t\t\t\t\t#include <skinnormal_vertex>\n\t\t\t\t\t#include <defaultnormal_vertex>\n\n\t\t\t\t#endif\n\n\t\t\t\t#include <begin_vertex>\n\n\t\t\t\t" + this.vertexPosition + "\n\t\t\t\t" + this.vertexColor + "\n\n\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t#include <skinning_vertex>\n\t\t\t\t#include <project_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\n\t\t\t\t#include <worldpos_vertex>\n\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t#include <envmap_vertex>\n\n\t\t\t}\n\t\t"
					}
				}, {
					key: "_concatFragmentShader",
					value: function() {
						return "\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\n\t\t\t" + this.fragmentFunctions + "\n\t\t\t" + this.fragmentParameters + "\n\t\t\t" + this.varyingParameters + "\n\n\t\t\t#ifndef FLAT_SHADED\n\n\t\t\t\tvarying vec3 vNormal;\n\n\t\t\t#endif\n\n\t\t\t#include <common>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <uv_pars_fragment>\n\t\t\t#include <uv2_pars_fragment>\n\t\t\t#include <map_pars_fragment>\n\t\t\t#include <alphamap_pars_fragment>\n\t\t\t#include <aomap_pars_fragment>\n\t\t\t#include <envmap_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <specularmap_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\n\t\t\tvoid main() {\n\n\t\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t\t" + this.fragmentInit + "\n\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t\t" + this.fragmentDiffuse + "\n\n\t\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\t\t" + (this.fragmentMap || "#include <map_fragment>") + "\n\n\t\t\t\t#include <color_fragment>\n\n\t\t\t\t#include <alphamap_fragment>\n\t\t\t\t#include <alphatest_fragment>\n\t\t\t\t#include <specularmap_fragment>\n\n\t\t\t\tReflectedLight reflectedLight;\n\t\t\t\treflectedLight.directDiffuse = vec3( 0.0 );\n\t\t\t\treflectedLight.directSpecular = vec3( 0.0 );\n\t\t\t\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\t\t\t\treflectedLight.indirectSpecular = vec3( 0.0 );\n\n\t\t\t\t#include <aomap_fragment>\n\n\t\t\t\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n\t\t\t\t#include <normal_flip>\n\t\t\t\t#include <envmap_fragment>\n\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <encodings_fragment>\n\t\t\t\t#include <fog_fragment>\n\n\t\t\t}\n\t\t"
					}
				}]),
				e
		}(d.default);
	e.default = f
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function o(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}

	function a(t, e) {
		if(!t)
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return !e || "object" != typeof e && "function" != typeof e ? t : e
	}

	function s(t, e) {
		if("function" != typeof e && null !== e)
			throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, {
				constructor: {
					value: t,
					enumerable: !1,
					writable: !0,
					configurable: !0
				}
			}),
			e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var l = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		c = n(9),
		u = r(c),
		h = n(39),
		d = i(h),
		f = function(t) {
			function e(t) {
				o(this, e);
				var n = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t)),
					i = u.ShaderLib.depth,
					i = u.ShaderLib.depth;
				return n.uniforms = u.UniformsUtils.merge([i.uniforms, n.uniforms]),
					n.vertexShader = n._concatVertexShader(),
					n.fragmentShader = i.fragmentShader,
					n
			}
			return s(e, t),
				l(e, [{
					key: "init",
					value: function() {
						this.depthPacking = u.RGBADepthPacking,
							this.clipping = !0,
							this.vertexFunctions = [],
							this.vertexParameters = [],
							this.vertexInit = [],
							this.vertexPosition = []
					}
				}, {
					key: "_concatVertexShader",
					value: function() {
						return "\n\t\t\t" + u.ShaderChunk.common + "\n\t\t\t" + u.ShaderChunk.uv_pars_vertex + "\n\t\t\t" + u.ShaderChunk.displacementmap_pars_vertex + "\n\t\t\t" + u.ShaderChunk.morphtarget_pars_vertex + "\n\t\t\t" + u.ShaderChunk.skinning_pars_vertex + "\n\t\t\t" + u.ShaderChunk.logdepthbuf_pars_vertex + "\n\t\t\t" + u.ShaderChunk.clipping_planes_pars_vertex + "\n\n\t\t\t" + this.vertexFunctions + "\n\t\t\t" + this.vertexParameters + "\n\n\t\t\tvoid main() {\n\n\t\t\t\t" + this.vertexInit + "\n\n\t\t\t\t" + u.ShaderChunk.uv_vertex + "\n\t\t\t\t" + u.ShaderChunk.skinbase_vertex + "\n\n\t\t\t\t" + u.ShaderChunk.begin_vertex + "\n\n\t\t\t\t" + this.vertexPosition + "\n\n\n\t\t\t\t" + u.ShaderChunk.displacementmap_vertex + "\n\t\t\t\t" + u.ShaderChunk.morphtarget_vertex + "\n\t\t\t\t" + u.ShaderChunk.skinning_vertex + "\n\t\t\t\t" + u.ShaderChunk.project_vertex + "\n\t\t\t\t" + u.ShaderChunk.logdepthbuf_vertex + "\n\t\t\t\t" + u.ShaderChunk.clipping_planes_vertex + "\n\t\t\t}\n\t\t"
					}
				}]),
				e
		}(d.default);
	e.default = f
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function o(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}

	function a(t, e) {
		if(!t)
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return !e || "object" != typeof e && "function" != typeof e ? t : e
	}

	function s(t, e) {
		if("function" != typeof e && null !== e)
			throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, {
				constructor: {
					value: t,
					enumerable: !1,
					writable: !0,
					configurable: !0
				}
			}),
			e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var l = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		c = n(9),
		u = r(c),
		h = n(39),
		d = i(h),
		f = function(t) {
			function e(t) {
				o(this, e);
				var n = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t)),
					i = u.ShaderLib.distanceRGBA,
					i = u.ShaderLib.distanceRGBA;
				return n.uniforms = u.UniformsUtils.merge([i.uniforms, n.uniforms]),
					n.vertexShader = n._concatVertexShader(),
					n.fragmentShader = i.fragmentShader,
					n
			}
			return s(e, t),
				l(e, [{
					key: "init",
					value: function() {
						this.depthPacking = u.RGBADepthPacking,
							this.clipping = !0,
							this.vertexFunctions = [],
							this.vertexParameters = [],
							this.vertexInit = [],
							this.vertexPosition = []
					}
				}, {
					key: "_concatVertexShader",
					value: function() {
						return "\n\t\t\tvarying vec4 vWorldPosition;\n\n\t\t\t" + u.ShaderChunk.common + "\n\t\t\t" + u.ShaderChunk.morphtarget_pars_vertex + "\n\t\t\t" + u.ShaderChunk.skinning_pars_vertex + "\n\t\t\t" + u.ShaderChunk.clipping_planes_pars_vertex + "\n\n\t\t\t" + this._stringifyChunk("vertexFunctions") + "\n\t\t\t" + this._stringifyChunk("vertexParameters") + "\n\n\t\t\tvoid main() {\n\n\t\t\t\t" + this._stringifyChunk("vertexInit") + "\n\n\t\t\t\t" + u.ShaderChunk.skinbase_vertex + "\n\t\t\t\t" + u.ShaderChunk.begin_vertex + "\n\n\t\t\t\t" + this._stringifyChunk("vertexPosition") + "\n\n\t\t\t\t" + u.ShaderChunk.morphtarget_vertex + "\n\t\t\t\t" + u.ShaderChunk.skinning_vertex + "\n\t\t\t\t" + u.ShaderChunk.project_vertex + "\n\t\t\t\t" + u.ShaderChunk.worldpos_vertex + "\n\t\t\t\t" + u.ShaderChunk.clipping_planes_vertex + "\n\n\t\t\t\tvWorldPosition = worldPosition;\n\t\t\t}\n\t\t";
					}
				}]),
				e
		}(d.default);
	e.default = f
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function o(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}

	function a(t, e) {
		if(!t)
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return !e || "object" != typeof e && "function" != typeof e ? t : e
	}

	function s(t, e) {
		if("function" != typeof e && null !== e)
			throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, {
				constructor: {
					value: t,
					enumerable: !1,
					writable: !0,
					configurable: !0
				}
			}),
			e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var l = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		c = n(9),
		u = r(c),
		h = n(39),
		d = i(h),
		f = function(t) {
			function e(t) {
				o(this, e);
				var n = u.ShaderLib.phong,
					i = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n.uniforms));
				return i.lights = !0,
					i.vertexShader = i._concatVertexShader(),
					i.fragmentShader = i._concatFragmentShader(),
					i
			}
			return s(e, t),
				l(e, [{
					key: "init",
					value: function() {
						this.varyingParameters = [],
							this.vertexFunctions = [],
							this.vertexParameters = [],
							this.vertexInit = [],
							this.vertexNormal = [],
							this.vertexPosition = [],
							this.vertexColor = [],
							this.fragmentFunctions = [],
							this.fragmentParameters = [],
							this.fragmentInit = [],
							this.fragmentMap = [],
							this.fragmentDiffuse = [],
							this.fragmentEmissive = [],
							this.fragmentSpecular = []
					}
				}, {
					key: "_concatVertexShader",
					value: function() {
						return "\n\t\t\t#define PHONG\n\n\t\t\tvarying vec3 vViewPosition;\n\n\t\t\t#ifndef FLAT_SHADED\n\n\t\t\t\tvarying vec3 vNormal;\n\n\t\t\t#endif\n\n\t\t\t#include <common>\n\t\t\t#include <uv_pars_vertex>\n\t\t\t#include <uv2_pars_vertex>\n\t\t\t#include <displacementmap_pars_vertex>\n\t\t\t#include <envmap_pars_vertex>\n\t\t\t#include <color_pars_vertex>\n\t\t\t#include <morphtarget_pars_vertex>\n\t\t\t#include <skinning_pars_vertex>\n\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t#include <clipping_planes_pars_vertex>\n\n\t\t\t" + this.vertexFunctions + "\n\t\t\t" + this.vertexParameters + "\n\t\t\t" + this.varyingParameters + "\n\n\t\t\tvoid main() {\n\n\t\t\t\t" + this.vertexInit + "\n\t\t\t\t#include <uv_vertex>\n\t\t\t\t#include <uv2_vertex>\n\t\t\t\t#include <color_vertex>\n\t\t\t\t#include <beginnormal_vertex>\n\n\t\t\t\t" + this.vertexNormal + "\n\n\t\t\t\t#include <morphnormal_vertex>\n\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t#include <skinnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\n\t\t\t\t#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\t\t\t\t\tvNormal = normalize( transformedNormal );\n\n\t\t\t\t#endif\n\n\t\t\t\t#include <begin_vertex>\n\n\t\t\t\t" + this.vertexPosition + "\n\t\t\t\t" + this.vertexColor + "\n\n\t\t\t\t#include <displacementmap_vertex>\n\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t#include <skinning_vertex>\n\t\t\t\t#include <project_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <clipping_planes_vertex>\n\n\t\t\t\t\tvViewPosition = - mvPosition.xyz;\n\n\t\t\t\t#include <worldpos_vertex>\n\t\t\t\t#include <envmap_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}\n\t\t"
					}
				}, {
					key: "_concatFragmentShader",
					value: function() {
						return "\n\t\t\t#define PHONG\n\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform vec3 emissive;\n\t\t\tuniform vec3 specular;\n\t\t\tuniform float shininess;\n\t\t\tuniform float opacity;\n\n\t\t\t" + this.fragmentFunctions + "\n\t\t\t" + this.fragmentParameters + "\n\t\t\t" + this.varyingParameters + "\n\n\t\t\t#include <common>\n\t\t\t#include <packing>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <uv_pars_fragment>\n\t\t\t#include <uv2_pars_fragment>\n\t\t\t#include <map_pars_fragment>\n\t\t\t#include <alphamap_pars_fragment>\n\t\t\t#include <aomap_pars_fragment>\n\t\t\t#include <lightmap_pars_fragment>\n\t\t\t#include <emissivemap_pars_fragment>\n\t\t\t#include <envmap_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <bsdfs>\n\t\t\t#include <lights_pars>\n\t\t\t#include <lights_phong_pars_fragment>\n\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t#include <bumpmap_pars_fragment>\n\t\t\t#include <normalmap_pars_fragment>\n\t\t\t#include <specularmap_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\n\t\t\tvoid main() {\n\n\t\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t\t" + this.fragmentInit + "\n\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t\t\t\tvec3 totalEmissiveRadiance = emissive;\n\n\t\t\t\t" + this.fragmentDiffuse + "\n\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t" + (this.fragmentMap || "#include <map_fragment>") + "\n\t\t\t\t#include <color_fragment>\n\n\t\t\t\t#include <alphamap_fragment>\n\t\t\t\t#include <alphatest_fragment>\n\t\t\t\t#include <specularmap_fragment>\n\t\t\t\t#include <normal_flip>\n\t\t\t\t#include <normal_fragment>\n\n\t\t\t\t" + this.fragmentEmissive + "\n\n\t\t\t\t#include <emissivemap_fragment>\n\n\t\t\t\t// accumulation\n\t\t\t\t#include <lights_phong_fragment>\n\n\t\t\t\t" + this.fragmentSpecular + "\n\n\t\t\t\t#include <lights_template>\n\n\t\t\t\t// modulation\n\t\t\t\t#include <aomap_fragment>\n\n\t\t\t\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t\t\t\t#include <envmap_fragment>\n\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <encodings_fragment>\n\t\t\t\t#include <fog_fragment>\n\n\t\t\t}\n\t\t"
					}
				}]),
				e
		}(d.default);
	e.default = f
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function o(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}

	function a(t, e) {
		if(!t)
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return !e || "object" != typeof e && "function" != typeof e ? t : e
	}

	function s(t, e) {
		if("function" != typeof e && null !== e)
			throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, {
				constructor: {
					value: t,
					enumerable: !1,
					writable: !0,
					configurable: !0
				}
			}),
			e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var l = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		c = n(9),
		u = r(c),
		h = n(39),
		d = i(h),
		f = function(t) {
			function e(t) {
				o(this, e);
				var n = u.ShaderLib.points,
					i = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n.uniforms));
				return i.vertexShader = i._concatVertexShader(),
					i.fragmentShader = i._concatFragmentShader(),
					i
			}
			return s(e, t),
				l(e, [{
					key: "init",
					value: function() {
						this.varyingParameters = [],
							this.vertexFunctions = [],
							this.vertexParameters = [],
							this.vertexInit = [],
							this.vertexNormal = [],
							this.vertexPosition = [],
							this.vertexColor = [],
							this.fragmentFunctions = [],
							this.fragmentParameters = [],
							this.fragmentInit = [],
							this.fragmentMap = [],
							this.fragmentDiffuse = [],
							this.fragmentShape = []
					}
				}, {
					key: "_concatVertexShader",
					value: function() {
						return "\n\t\t\tuniform float size;\n\t\t\tuniform float scale;\n\t\t\t#include <common>\n\t\t\t#include <color_pars_vertex>\n\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\n\t\t\t" + this.vertexFunctions + "\n\t\t\t" + this.vertexParameters + "\n\t\t\t" + this.varyingParameters + "\n\n\t\t\tvoid main() {\n\t\t\t\n\t\t\t\t" + this.vertexInit + "\n\t\t\t\t\n\t\t\t\t#include <color_vertex>\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t\n\t\t\t\t" + this.vertexPosition + "\n\t\t\t\t" + this.vertexColor + "\n\t\t\t\t\n\t\t\t\t#include <project_vertex>\n\t\t\t\t#ifdef USE_SIZEATTENUATION\n\t\t\t\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t\t\t\t#else\n\t\t\t\t\tgl_PointSize = size;\n\t\t\t\t#endif\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t#include <worldpos_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}\n\t\t"
					}
				}, {
					key: "_concatFragmentShader",
					value: function() {
						return "\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\t\t\t\n\t\t\t" + this.fragmentFunctions + "\n\t\t\t" + this.fragmentParameters + "\n\t\t\t" + this.varyingParameters + "\n\t\t\t\n\t\t\t#include <common>\n\t\t\t#include <packing>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <map_particle_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\n\t\t\tvoid main() {\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\t\n\t\t\t\t" + this.fragmentInit + "\n\t\t\t\t\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\t\n\t\t\t\t" + this.fragmentDiffuse + "\n\t\t\t\t\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\n\t\t\t\t" + (this.fragmentMap || "#include <map_fragment>") + "\n\t\t\t\t#include <map_particle_fragment>\n\t\t\t\t#include <color_fragment>\n\t\t\t\t#include <alphatest_fragment>\n\t\t\t\toutgoingLight = diffuseColor.rgb;\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t\n\t\t\t\t" + this.fragmentShape + "\n\t\t\t\t\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <encodings_fragment>\n\t\t\t\t#include <fog_fragment>\n\t\t\t}\n\t\t"
					}
				}]),
				e
		}(d.default);
	e.default = f
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function o(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}

	function a(t, e) {
		if(!t)
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return !e || "object" != typeof e && "function" != typeof e ? t : e
	}

	function s(t, e) {
		if("function" != typeof e && null !== e)
			throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, {
				constructor: {
					value: t,
					enumerable: !1,
					writable: !0,
					configurable: !0
				}
			}),
			e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var l = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		c = n(9),
		u = r(c),
		h = n(39),
		d = i(h),
		f = function(t) {
			function e(t) {
				o(this, e);
				var n = u.ShaderLib.standard,
					i = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n.uniforms));
				return i.lights = !0,
					i.vertexShader = i._concatVertexShader(),
					i.fragmentShader = i._concatFragmentShader(),
					i
			}
			return s(e, t),
				l(e, [{
					key: "init",
					value: function() {
						this.varyingParameters = [],
							this.vertexFunctions = [],
							this.vertexParameters = [],
							this.vertexInit = [],
							this.vertexNormal = [],
							this.vertexPosition = [],
							this.vertexColor = [],
							this.fragmentFunctions = [],
							this.fragmentParameters = [],
							this.fragmentInit = [],
							this.fragmentMap = [],
							this.fragmentDiffuse = [],
							this.fragmentRoughness = [],
							this.fragmentMetalness = [],
							this.fragmentEmissive = []
					}
				}, {
					key: "_concatVertexShader",
					value: function() {
						return "\n\t\t\t#define PHYSICAL\n\n\t\t\tvarying vec3 vViewPosition;\n\n\t\t\t#ifndef FLAT_SHADED\n\n\t\t\t\tvarying vec3 vNormal;\n\n\t\t\t#endif\n\n\t\t\t#include <common>\n\t\t\t#include <uv_pars_vertex>\n\t\t\t#include <uv2_pars_vertex>\n\t\t\t#include <displacementmap_pars_vertex>\n\t\t\t#include <color_pars_vertex>\n\t\t\t#include <morphtarget_pars_vertex>\n\t\t\t#include <skinning_pars_vertex>\n\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t#include <specularmap_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t#include <clipping_planes_pars_vertex>\n\n\t\t\t" + this.vertexFunctions + "\n\t\t\t" + this.vertexParameters + "\n\t\t\t" + this.varyingParameters + "\n\n\t\t\tvoid main() {\n\n\t\t\t\t" + this.vertexInit + "\n\n\t\t\t\t#include <uv_vertex>\n\t\t\t\t#include <uv2_vertex>\n\t\t\t\t#include <color_vertex>\n\t\t\t\t#include <beginnormal_vertex>\n\n\t\t\t\t" + this.vertexNormal + "\n\n\t\t\t\t#include <morphnormal_vertex>\n\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t#include <skinnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\n\t\t\t\t#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\t\t\t\t\tvNormal = normalize( transformedNormal );\n\n\t\t\t\t#endif\n\n\t\t\t\t#include <begin_vertex>\n\n\t\t\t\t" + this.vertexPosition + "\n\t\t\t\t" + this.vertexColor + "\n\n\t\t\t\t#include <displacementmap_vertex>\n\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t#include <skinning_vertex>\n\t\t\t\t#include <project_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <clipping_planes_vertex>\n\n\t\t\t\tvViewPosition = - mvPosition.xyz;\n\n\t\t\t\t#include <worldpos_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}\n\t\t"
					}
				}, {
					key: "_concatFragmentShader",
					value: function() {
						return "\n\t\t\t#define PHYSICAL\n\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform vec3 emissive;\n\t\t\tuniform float roughness;\n\t\t\tuniform float metalness;\n\t\t\tuniform float opacity;\n\n\t\t\t#ifndef STANDARD\n\t\t\t\tuniform float clearCoat;\n\t\t\t\tuniform float clearCoatRoughness;\n\t\t\t#endif\n\n\t\t\tvarying vec3 vViewPosition;\n\n\t\t\t#ifndef FLAT_SHADED\n\t\t\t\tvarying vec3 vNormal;\n\t\t\t#endif\n\n\t\t\t" + this.fragmentFunctions + "\n\t\t\t" + this.fragmentParameters + "\n\t\t\t" + this.varyingParameters + "\n\n\t\t\t#include <common>\n\t\t\t#include <packing>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <uv_pars_fragment>\n\t\t\t#include <uv2_pars_fragment>\n\t\t\t#include <map_pars_fragment>\n\t\t\t#include <alphamap_pars_fragment>\n\t\t\t#include <aomap_pars_fragment>\n\t\t\t#include <lightmap_pars_fragment>\n\t\t\t#include <emissivemap_pars_fragment>\n\t\t\t#include <envmap_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <bsdfs>\n\t\t\t#include <cube_uv_reflection_fragment>\n\t\t\t#include <lights_pars>\n\t\t\t#include <lights_physical_pars_fragment>\n\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t#include <bumpmap_pars_fragment>\n\t\t\t#include <normalmap_pars_fragment>\n\t\t\t#include <roughnessmap_pars_fragment>\n\t\t\t#include <metalnessmap_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\n\t\t\tvoid main() {\n\n\t\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t\t" + this.fragmentInit + "\n\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t\t\t\tvec3 totalEmissiveRadiance = emissive;\n\n\t\t\t\t" + this.fragmentDiffuse + "\n\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t" + (this.fragmentMap || "#include <map_fragment>") + "\n\t\t\t\t#include <color_fragment>\n\n\t\t\t\t#include <alphamap_fragment>\n\t\t\t\t#include <alphatest_fragment>\n\t\t\t\t#include <specularmap_fragment>\n\n\t\t\t\t//'#include <roughnessmap_fragment>'\n\t\t\t\tfloat roughnessFactor = roughness;\n\n\t\t\t\t" + this.fragmentRoughness + "\n\n\t\t\t\t#ifdef USE_ROUGHNESSMAP\n\t\t\t\t roughnessFactor *= texture2D( roughnessMap, vUv ).r;\n\t\t\t\t#endif\n\n\t\t\t\t//'#include <metalnessmap_fragment>'\n\t\t\t\tfloat metalnessFactor = metalness;\n\t\t\t\t" + this.fragmentMetalness + "\n\t\t\t\t#ifdef USE_METALNESSMAP\n\t\t\t\t\tmetalnessFactor *= texture2D( metalnessMap, vUv ).r;\n\t\t\t\t#endif\n\n\t\t\t\t#include <normal_flip>\n\t\t\t\t#include <normal_fragment>\n\n\t\t\t\t" + this.fragmentEmissive + "\n\n\t\t\t\t#include <emissivemap_fragment>\n\n\t\t\t\t// accumulation\n\t\t\t\t#include <lights_physical_fragment>\n\t\t\t\t#include <lights_template>\n\n\t\t\t\t// modulation\n\t\t\t\t#include <aomap_fragment>\n\n\t\t\t\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <encodings_fragment>\n\t\t\t\t#include <fog_fragment>\n\n\t\t\t}\n\t\t"
					}
				}]),
				e
		}(d.default);
	e.default = f
}, function(module, exports, __webpack_require__) {
	"use strict";

	function _interopRequireDefault(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function _classCallCheck(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}
	Object.defineProperty(exports, "__esModule", {
		value: !0
	});
	var _createClass = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		_TimelineSegment = __webpack_require__(47),
		_TimelineSegment2 = _interopRequireDefault(_TimelineSegment),
		Timeline = function() {
			function Timeline() {
				_classCallCheck(this, Timeline),
					this.duration = 0,
					this.timeKey = "tTime",
					this.segments = {},
					this.__key = 0
			}
			return _createClass(Timeline, [{
					key: "add",
					value: function add(duration, transitions, positionOffset) {
						var start = this.duration;
						void 0 !== positionOffset ? ("number" == typeof positionOffset ? start = positionOffset : "string" == typeof positionOffset && eval("start" + positionOffset),
							this.duration = Math.max(this.duration, start + duration)) : this.duration += duration;
						for(var keys = Object.keys(transitions), key, i = 0; i < keys.length; i++)
							key = keys[i],
							this.processTransition(key, transitions[key], start, duration)
					}
				}, {
					key: "processTransition",
					value: function(t, e, n, i) {
						var r = Timeline.segmentDefinitions[t],
							o = this.segments[t];
						o || (o = this.segments[t] = []),
							void 0 === e.from && (0 === o.length ? e.from = r.defaultFrom : e.from = o[o.length - 1].transition.to),
							o.push(new _TimelineSegment2.default((this.__key++).toString(), n, i, e, r.compiler))
					}
				}, {
					key: "compile",
					value: function() {
						for(var t, e = [], n = Object.keys(this.segments), i = 0; i < n.length; i++)
							t = this.segments[n[i]],
							this.fillGaps(t),
							t.forEach(function(t) {
								e.push(t.compile())
							});
						return e
					}
				}, {
					key: "fillGaps",
					value: function(t) {
						if(0 !== t.length) {
							for(var e, n, i = 0; i < t.length - 1; i++)
								e = t[i],
								n = t[i + 1],
								e.trail = n.start - e.end;
							e = t[t.length - 1],
								e.trail = this.duration - e.end
						}
					}
				}, {
					key: "getTransformCalls",
					value: function(t) {
						var e = this.timeKey;
						return this.segments[t] ? this.segments[t].map(function(t) {
							return "applyTransform" + t.key + "(" + e + ", transformed);"
						}).join("\n") : ""
					}
				}]),
				Timeline
		}();
	exports.default = Timeline,
		Timeline.segmentDefinitions = {},
		Timeline.register = function(t, e) {
			Timeline.segmentDefinitions[t] = e
		}
}, function(t, e) {
	"use strict";

	function n(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var i = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		r = function() {
			function t(e, i, r, o, a) {
				n(this, t),
					this.key = e,
					this.start = i,
					this.duration = r,
					this.transition = o,
					this.compiler = a,
					this.trail = 0
			}
			return i(t, [{
					key: "compile",
					value: function() {
						return this.compiler(this)
					}
				}]),
				t
		}();
	e.default = r,
		Object.defineProperty(r.prototype, "end", {
			get: function() {
				return this.start + this.duration
			}
		})
}, function(t, e) {
	"use strict";
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var n = {
		vec3: function(t, e, n) {
			var i = (e.x || 0).toPrecision(n),
				r = (e.y || 0).toPrecision(n),
				o = (e.z || 0).toPrecision(n);
			return "vec3 " + t + " = vec3(" + i + "," + r + "," + o + ");"
		},
		vec4: function(t, e, n) {
			var i = (e.x || 0).toPrecision(n),
				r = (e.y || 0).toPrecision(n),
				o = (e.z || 0).toPrecision(n),
				a = (e.w || 0).toPrecision(n);
			return "vec4 " + t + " = vec4(" + i + "," + r + "," + o + "," + a + ");"
		},
		delayDuration: function(t) {
			return ["float cDelay" + t.key + " = " + t.start.toPrecision(4) + ";", "float cDuration" + t.key + " = " + t.duration.toPrecision(4) + ";"].join("\n")
		},
		progress: function(t) {
			return 0 === t.duration ? "float progress = 1.0;" : ["float progress = clamp(time - cDelay" + t.key + ", 0.0, cDuration" + t.key + ") / cDuration" + t.key + ";", t.transition.ease ? "progress = " + t.transition.ease + "(progress" + (t.transition.easeParams ? "," + t.transition.easeParams.map(function(t) {
				return t.toPrecision(4)
			}).join(",") : "") + ");" : ""].join("\n")
		},
		renderCheck: function(t) {
			var e = t.start.toPrecision(4),
				n = (t.end + t.trail).toPrecision(4);
			return "if (time < " + e + " || time > " + n + ") return;"
		}
	};
	e.default = n
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function o(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}

	function a(t, e) {
		if(!t)
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return !e || "object" != typeof e && "function" != typeof e ? t : e
	}

	function s(t, e) {
		if("function" != typeof e && null !== e)
			throw new TypeError("Super expression must either be null or a function, not " + typeof e);
		t.prototype = Object.create(e && e.prototype, {
				constructor: {
					value: t,
					enumerable: !1,
					writable: !0,
					configurable: !0
				}
			}),
			e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
	}

	function l(t) {
		function e() {
			return(Math.random() - .5) * b * .5
		}
		E = {
			uTime: {
				type: "f",
				value: .1
			},
			tChannel0: {
				type: "t",
				value: f.default.resources.texture.logo
			},
			tChannel1: {
				type: "t",
				value: f.default.resources.texture.blackhole
			},
			tChannel2: {
				type: "t",
				value: f.default.resources.texture.blackhole
			}
		};
		var n = [{
			x: 0,
			y: e(),
			z: -T
		}, {
			x: 0,
			y: e(),
			z: 2 * -T
		}, {
			x: 0,
			y: e(),
			z: 3 * -T
		}, {
			x: 0,
			y: e(),
			z: 4 * -T
		}];
		M = new h.Group,
			M.position.z = -5e3,
			n.forEach(function(t) {
				var e = new S;
				e.position.set(t.x, t.y, t.z),
					M.add(e)
			}),
			t.add(M)
	}

	function c(t, e) {
		function n(t, e) {
			y.default.trigger(x, e),
				t._entered = !0
		}
		var i = m.default.entryCount;
		if(i > 3)
			return void(M.visible = !1);
		if(0 !== m.default.status && 1 !== m.default.status)
			return void(M.visible = !1);
		M.visible = !0,
			E.uTime.value += .002 * e,
			M.position.z += t;
		var r = m.default.avatarPositionX,
			o = m.default.avatarPositionY,
			a = M.children[i],
			s = M.position.x + a.position.x,
			l = M.position.y + a.position.y,
			c = M.position.z + a.position.z;
		1 === m.default.status && (a.position.x = r,
			a.position.y = o,
			a.scale.x < 3.5 && (a.scale.x += .1,
				a.scale.y += .1)), !a._entered && c > 3800 && (Math.pow(s - r, 2) + Math.pow(l - o, 2) > Math.pow(w, 2) ? (a._entered = !1,
			1 !== i || M.children[0]._entered ? m.default.entryCount++ : n(a, i)) : n(a, i))
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var u = n(9),
		h = r(u),
		d = (n(26),
			n(14)),
		f = i(d),
		p = n(11),
		m = i(p),
		v = n(10),
		g = i(v),
		_ = n(30),
		y = i(_),
		b = (g.default.MOVE_STEP,
			g.default.SCENE_HEIGHT),
		x = g.default.ENTER_DISTRICT,
		w = g.default.ENTRY_RADIUS,
		T = g.default.ENTRY_DISTANCE,
		M = void 0,
		E = void 0,
		S = function(t) {
			function e() {
				o(this, e),
					E.tChannel1.value.wrapS = E.tChannel1.value.wrapT = h.RepeatWrapping,
					E.tChannel2.value.wrapS = E.tChannel2.value.wrapT = h.RepeatWrapping;
				var t = new h.ShaderMaterial({
						uniforms: E,
						vertexShader: n(50),
						fragmentShader: n(51),
						transparent: !0
					}),
					i = new h.PlaneGeometry(2e3, 2e3, 1, 1);
				return a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, i, t))
			}
			return s(e, t),
				e
		}(h.Mesh);
	e.default = {
		init: l,
		update: c
	}
}, function(t, e) {
	t.exports = "#define GLSLIFY 1\nvarying vec2 vUv; \n\nvoid main() {\n\tvUv = uv;\n\n\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(t, e) {
	t.exports = "#define GLSLIFY 1\n/*\n * https://www.shadertoy.com/view/4sXSzs\n */\nuniform float uTime;\nuniform sampler2D tChannel0;\nuniform sampler2D tChannel1;\nuniform sampler2D tChannel2;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n\t// vec2 p = gl_FragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * vUv;\n\n\tif(length(p) > 1.0){\n\t\tdiscard;\n\t}\n\n\tif(length(p) > 0.92){\n\t\tfloat mid = 0.5;\n\t\tfloat speed = 5.0;\n\n\t\tvec2 rotated = vec2(cos(uTime * speed) * (vUv.x - mid) + sin(uTime * speed) * (vUv.y - mid) + mid,\n\t\t\t\t\t\t\t\t\t\t\t\tcos(uTime * speed) * (vUv.y - mid) - sin(uTime * speed) * (vUv.x - mid) + mid);\n\n\t\tgl_FragColor = texture2D(tChannel0, rotated);\n\t} else{\n\t\t// vec2 q = p - vec2(0.5, 0.5);\n\t\tvec2 q = p;\n\n\t\t// q.x += sin(uTime* 0.6) * 0.2;\n\t\t// q.y += cos(uTime* 0.4) * 0.3;\n\n\t\tfloat len = length(q);\n\n\t\tfloat a = atan(q.y, q.x) + uTime * 0.3;\n\t\tfloat b = atan(q.y, q.x) + uTime * 0.3;\n\t\tfloat r1 = 0.3 / len + uTime * 0.5;\n\t\tfloat r2 = 0.2 / len + uTime * 0.5;\n\n\t\tfloat m = (1.0 + sin(uTime * 0.5)) / 2.0;\n\t\tvec4 tex1 = texture2D(tChannel1, vec2(a + 0.1 / len, r1 ));\n\t\tvec4 tex2 = texture2D(tChannel2, vec2(b + 0.1 / len, r2 ));\n\t\tvec3 col = vec3(mix(tex1, tex2, m));\n\t\tgl_FragColor = vec4(col * len * 1.5, 1.0);\n\t}\n}\n"
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function o(t) {
		g = new l.WebGLRenderer({
				antialias: !0
			}),
			g.setSize(p, m),
			t.appendChild(g.domElement),
			h.default.on(v, function() {
				g.setSize(window.innerWidth, window.innerHeight)
			})
	}

	function a(t, e) {
		g.render(t, e)
	}

	function s() {
		return g
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var l = n(9),
		c = (r(l),
			n(11)),
		u = (i(c),
			n(30)),
		h = i(u),
		d = n(10),
		f = i(d),
		p = (f.default.FOG_COLOR,
			f.default.FINAL_MAX_SPEED,
			f.default.SCREEN_WIDTH),
		m = f.default.SCREEN_HEIGHT,
		v = f.default.WINDOW_RESIZE,
		g = void 0;
	e.default = {
		init: o,
		draw: a,
		getRenderer: s
	}
}, function(t, e, n) {
	"use strict";

	function i(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function r(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function o(t) {
		for(var e, n, i = t.length; 0 !== i;)
			n = Math.floor(Math.random() * i),
			i -= 1,
			e = t[i],
			t[i] = t[n],
			t[n] = e;
		return t
	}

	function a() {
		var t = M.default.isIOS && !M.default.ip6;
		B = o(D).map(function(e) {
				return t ? A.default.panoVideos[e] : A.default.normalVideos[e]
			}),
			L = (0,
				b.$)("#subDistricts"),
			t ? (C = new g.default(L),
				I = new R.DeviceOrientationControls(C.camera),
				I.target = new R.Vector3(1, 0, 0),
				I.alphaOffsetAngle = Math.PI / 2) : C = new y.default(L)
	}

	function s() {
		return C.camera
	}

	function l() {
		return C.scene
	}

	function c(t) {
		var e = C.setVideo(B[t]),
			n = new Promise(function(t, e) {
				document.querySelector("#control-board").addEventListener("tap", function() {
					1 === M.default.status && t()
				})
			});
		return Promise.race([e, n])
	}

	function u() {
		C.playVideo().then(function() {
			w.default.trigger(O)
		})
	}

	function h() {
		L.style.visibility = "visible"
	}

	function d() {
		L.style.visibility = "hidden"
	}

	function f() {
		C.togglePlay()
	}

	function p() {
		var t = M.default.isIOS && !M.default.ip6;
		2 === M.default.status && t && I.update()
	}

	function m() {
		return C.video
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var v = n(54),
		g = r(v),
		_ = n(55),
		y = r(_),
		b = n(56),
		x = n(30),
		w = r(x),
		T = n(11),
		M = r(T),
		E = n(10),
		S = r(E),
		X = n(24),
		A = r(X),
		P = n(9),
		R = i(P);
	n(57);
	var O = S.default.LEAVE_DISTRICT,
		C = void 0,
		L = void 0,
		I = void 0,
		D = ["east", "west", "south", "north"],
		B = void 0;
	e.default = {
		init: a,
		start: u,
		show: h,
		hide: d,
		setVideo: c,
		update: p,
		togglePlay: f,
		getScene: l,
		getCamera: s,
		getSubVideo: m
	}
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function o(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var a = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		s = n(9),
		l = r(s),
		c = n(10),
		u = i(c),
		h = u.default.SCREEN_WIDTH,
		d = u.default.SCREEN_HEIGHT,
		f = 120,
		p = 500,
		m = 60,
		v = 60,
		g = function() {
			function t(e) {
				o(this, t),
					this.container = e,
					this.containerWidth = h,
					this.containerHeight = d,
					this.rafId = void 0,
					this.init()
			}
			return a(t, [{
					key: "init",
					value: function() {
						var t = (this.container,
								this.containerWidth),
							e = this.containerHeight;
						this.camera = new l.PerspectiveCamera(f, t / e, .1, 1e3),
							this.camera.position.x = 0,
							this.camera.position.y = 0,
							this.camera.position.z = 0,
							this.camera.lookAt(new l.Vector3(500, 0, 0)),
							this.scene = new l.Scene,
							this.geometry = new l.SphereBufferGeometry(p, m, v),
							this.video = document.createElement("video"),
							this.video.setAttribute("webkit-playsinline", "true"),
							this.video.setAttribute("playsinline", "true"),
							this.video.setAttribute("crossorigin", "anonymous"),
							this.video.style.display = "none",
							this.container.appendChild(this.video),
							this.texture = new l.VideoTexture(this.video),
							this.texture.minFilter = l.LinearFilter,
							this.texture.format = l.RGBFormat
					}
				}, {
					key: "setVideo",
					value: function(t, e) {
						var n = this;
						return this.video.src = t,
							this.material || (this.material = new l.MeshBasicMaterial({
									map: this.texture
								}),
								this.mesh = new l.Mesh(this.geometry, this.material),
								this.mesh.scale.x = -1,
								this.scene.add(this.mesh)),
							new Promise(function(t) {
								var e = function e() {
									n.video.removeEventListener("canplaythrough", e),
										t()
								};
								n.video.addEventListener("canplaythrough", e),
									n.video.load()
							})
					}
				}, {
					key: "playVideo",
					value: function() {
						var t = this;
						return this.video.play(),
							this.video.onended = null,
							new Promise(function(e) {
								t.video.onended = e
							})
					}
				}, {
					key: "draw",
					value: function() {
						this.renderer.render(this.scene, this.camera)
					}
				}, {
					key: "run",
					value: function() {
						var t = this;
						this.playVideo();
						var e = function e() {
							t.draw(),
								t.rafId = requestAnimationFrame(e)
						};
						this.rafId = requestAnimationFrame(e)
					}
				}, {
					key: "stop",
					value: function() {
						this.video.pause(),
							this.rafId && (cancelAnimationFrame(this.rafId),
								this.rafId = void 0)
					}
				}, {
					key: "togglePlay",
					value: function() {
						this.video.paused ? this.video.play() : this.video.pause()
					}
				}, {
					key: "destroy",
					value: function() {}
				}]),
				t
		}();
	e.default = g
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var o = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		a = n(10),
		s = i(a),
		l = s.default.SCREEN_WIDTH,
		c = s.default.SCREEN_HEIGHT,
		u = function() {
			function t(e) {
				r(this, t),
					this.container = e,
					this.containerWidth = l,
					this.containerHeight = c,
					this.init()
			}
			return o(t, [{
					key: "init",
					value: function() {
						this.video = document.createElement("video"),
							this.video.setAttribute("webkit-playsinline", "true"),
							this.video.setAttribute("x5-video-player-type", "h5"),
							this.video.setAttribute("x5-video-player-fullscreen", "true"),
							this.video.setAttribute("playsinline", "true"),
							this.video.setAttribute("crossorigin", "anonymous"),
							this.video.style.cssText = "\n            position: absolute;\n            left:50%; top:50%;\n        ",
							this.container.appendChild(this.video),
							f(this.video)
					}
				}, {
					key: "setVideo",
					value: function(t) {
						var e = this;
						return this.video.src = t,
							new Promise(function(t) {
								var n = function n() {
									e.video.removeEventListener("canplaythrough", n),
										t()
								};
								e.video.addEventListener("canplaythrough", n),
									e.video.load()
							})
					}
				}, {
					key: "playVideo",
					value: function() {
						var t = this.video;
						return t.play(),
							t.onended = null,
							new Promise(function(e) {
								function n() {
									t.removeEventListener("x5videoexitfullscreen", n),
										e()
								}
								t.onended = e,
									t.addEventListener("x5videoexitfullscreen", n)
							})
					}
				}, {
					key: "stop",
					value: function() {
						this.video.pause()
					}
				}]),
				t
		}(),
		h = 750,
		d = 1334,
		f = function(t) {
			var e = document.documentElement.getBoundingClientRect().width,
				n = document.documentElement.getBoundingClientRect().height,
				i = e / n,
				r = h / d;
			if(i > r) {
				t.style.width = "100%",
					t.style.marginLeft = -e / 2 + "px";
				var o = e / h * d;
				t.style.marginTop = -o / 2 + "px"
			} else {
				t.style.height = "100%",
					t.style.marginTop = -n / 2 + "px";
				var a = n / d * h;
				t.style.marginLeft = -a / 2 + "px"
			}
		};
	e.default = u
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}
	Object.defineProperty(e, "__esModule", {
			value: !0
		}),
		e.nativeBack = e.vibrate = e.goTickets = e.pushWindow = e.share = e.$$ = e.$ = e.log = void 0;
	var o = n(13),
		a = r(o),
		s = n(24),
		l = i(s),
		c = (e.log = function() {
				isDev
			},
			e.$ = function(t) {
				return document.querySelector(t)
			},
			e.$$ = function(t) {
				return document.querySelectorAll(t)
			},
			e.share = function() {
				var t = l.default.share,
					e = t.shareTitle,
					n = t.shareText,
					i = t.sharePic,
					r = t.shareUrl,
					o = {
						businessId: "2017zaowuinvite",
						title: e,
						text: n,
						image: i,
						url: r,
						scene: "other"
					};
				a.call("TBSharedModule", "showSharedMenu", o, function(t) {}, function(t) {})
			},
			e.pushWindow = function(t) {
				a.isAvailable ? a.call("Base", "openWindow", {
					url: t
				}, function(t) {}, function(t) {}) : location.href = t
			}
		);
	e.goTickets = function() {
			c(l.default.saleLink)
		},
		e.vibrate = function() {
			WindVane.isAvailable && WindVane.call("WVMotion", "vibrate", {})
		},
		e.nativeBack = function() {
			WindVane.call("WVNative", "nativeBack", {}, function() {}, function() {
				history.back()
			})
		}
}, function(t, e, n) {
	"use strict";

	function i(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}
	var r = n(9),
		o = i(r);
	o.DeviceOrientationControls = function(t) {
		var e = this;
		this.object = t,
			this.object.rotation.reorder("YXZ"),
			this.enabled = !0,
			this.deviceOrientation = {},
			this.screenOrientation = 0,
			this.alpha = 0,
			this.alphaOffsetAngle = 0,
			this.betaOffsetAngle = 0;
		var n = function(t) {
				e.deviceOrientation = t
			},
			i = function() {
				e.screenOrientation = window.orientation || 0
			},
			r = function() {
				var t = new o.Vector3(0, 0, 1),
					e = new o.Euler,
					n = new o.Quaternion,
					i = new o.Quaternion(-Math.sqrt(.5), 0, 0, Math.sqrt(.5));
				return function(r, o, a, s, l) {
					e.set(a, o, -s, "YXZ"),
						r.setFromEuler(e),
						r.multiply(i),
						r.multiply(n.setFromAxisAngle(t, -l))
				}
			}();
		this.connect = function() {
				i(),
					window.addEventListener("orientationchange", i, !1),
					window.addEventListener("deviceorientation", n, !1),
					e.enabled = !0
			},
			this.disconnect = function() {
				window.removeEventListener("orientationchange", i, !1),
					window.removeEventListener("deviceorientation", n, !1),
					e.enabled = !1
			},
			this.update = function(t, n, i) {
				if(e.enabled !== !1) {
					var a = e.deviceOrientation.alpha ? o.Math.degToRad(e.deviceOrientation.alpha) + this.alphaOffsetAngle : 0,
						s = e.deviceOrientation.beta ? o.Math.degToRad(e.deviceOrientation.beta) + this.betaOffsetAngle : 0,
						l = e.deviceOrientation.gamma ? o.Math.degToRad(e.deviceOrientation.gamma) : 0,
						c = e.screenOrientation ? o.Math.degToRad(e.screenOrientation) : 0;
					r(e.object.quaternion, a, s, l, c),
						this.alpha = a
				}
			},
			this.updateAlphaOffsetAngle = function(t) {
				this.alphaOffsetAngle = t,
					this.update()
			},
			this.updateBetaOffsetAngle = function(t) {
				this.betaOffsetAngle = t
			},
			this.dispose = function() {
				this.disconnect()
			},
			this.connect()
	}
}, function(t, e, n) {
	"use strict";

	function i(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function r(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function o() {
		"loaded" === _.state() && (_.play(),
			v.default.isAudioPlay = !0)
	}

	function a() {
		void 0 != v.default.isAudioPlay && (_.pause(),
			v.default.isAudioPlay = !1)
	}

	function s() {
		_ = new Howl({
			src: [u.default.urls.audio.rouet],
			loop: !0
		})
	}

	function l() {
		!_.playing() && v.default.isAudioPlay && o(),
			_.playing() && !v.default.isAudioPlay && a()
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var c = n(14),
		u = r(c),
		h = n(9),
		d = (i(h),
			n(30)),
		f = (r(d),
			n(10)),
		p = r(f),
		m = n(11),
		v = r(m),
		g = n(59),
		_ = (r(g),
			p.default.ENTER_DISTRICT,
			p.default.LEAVE_DISTRICT,
			void 0);
	e.default = {
		init: s,
		update: l,
		play: o,
		stop: a
	}
}, function(t, e, n) {
	var i, r;
	(function(n) {
		/*!
		 *  howler.js v2.0.3
		 *  howlerjs.com
		 *
		 *  (c) 2013-2017, James Simpson of GoldFire Studios
		 *  goldfirestudios.com
		 *
		 *  MIT License
		 */
		! function() {
			"use strict";
			var o = function() {
				this.init()
			};
			o.prototype = {
				init: function() {
					var t = this || a;
					return t._counter = 0,
						t._codecs = {},
						t._howls = [],
						t._muted = !1,
						t._volume = 1,
						t._canPlayEvent = "canplaythrough",
						t._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null,
						t.masterGain = null,
						t.noAudio = !1,
						t.usingWebAudio = !0,
						t.autoSuspend = !0,
						t.ctx = null,
						t.mobileAutoEnable = !0,
						t._setup(),
						t
				},
				volume: function(t) {
					var e = this || a;
					if(t = parseFloat(t),
						e.ctx || p(),
						"undefined" != typeof t && t >= 0 && t <= 1) {
						if(e._volume = t,
							e._muted)
							return e;
						e.usingWebAudio && (e.masterGain.gain.value = t);
						for(var n = 0; n < e._howls.length; n++)
							if(!e._howls[n]._webAudio)
								for(var i = e._howls[n]._getSoundIds(), r = 0; r < i.length; r++) {
									var o = e._howls[n]._soundById(i[r]);
									o && o._node && (o._node.volume = o._volume * t)
								}
						return e
					}
					return e._volume
				},
				mute: function(t) {
					var e = this || a;
					e.ctx || p(),
						e._muted = t,
						e.usingWebAudio && (e.masterGain.gain.value = t ? 0 : e._volume);
					for(var n = 0; n < e._howls.length; n++)
						if(!e._howls[n]._webAudio)
							for(var i = e._howls[n]._getSoundIds(), r = 0; r < i.length; r++) {
								var o = e._howls[n]._soundById(i[r]);
								o && o._node && (o._node.muted = !!t || o._muted)
							}
					return e
				},
				unload: function() {
					for(var t = this || a, e = t._howls.length - 1; e >= 0; e--)
						t._howls[e].unload();
					return t.usingWebAudio && t.ctx && "undefined" != typeof t.ctx.close && (t.ctx.close(),
							t.ctx = null,
							p()),
						t
				},
				codecs: function(t) {
					return(this || a)._codecs[t.replace(/^x-/, "")]
				},
				_setup: function() {
					var t = this || a;
					if(t.state = t.ctx ? t.ctx.state || "running" : "running",
						t._autoSuspend(), !t.usingWebAudio)
						if("undefined" != typeof Audio)
							try {
								var e = new Audio;
								"undefined" == typeof e.oncanplaythrough && (t._canPlayEvent = "canplay")
							} catch(e) {
								t.noAudio = !0
							}
					else
						t.noAudio = !0;
					try {
						var e = new Audio;
						e.muted && (t.noAudio = !0)
					} catch(t) {}
					return t.noAudio || t._setupCodecs(),
						t
				},
				_setupCodecs: function() {
					var t = this || a,
						e = null;
					try {
						e = "undefined" != typeof Audio ? new Audio : null
					} catch(e) {
						return t
					}
					if(!e || "function" != typeof e.canPlayType)
						return t;
					var n = e.canPlayType("audio/mpeg;").replace(/^no$/, ""),
						i = t._navigator && t._navigator.userAgent.match(/OPR\/([0-6].)/g),
						r = i && parseInt(i[0].split("/")[1], 10) < 33;
					return t._codecs = {
							mp3: !(r || !n && !e.canPlayType("audio/mp3;").replace(/^no$/, "")),
							mpeg: !!n,
							opus: !!e.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
							ogg: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
							oga: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
							wav: !!e.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
							aac: !!e.canPlayType("audio/aac;").replace(/^no$/, ""),
							caf: !!e.canPlayType("audio/x-caf;").replace(/^no$/, ""),
							m4a: !!(e.canPlayType("audio/x-m4a;") || e.canPlayType("audio/m4a;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
							mp4: !!(e.canPlayType("audio/x-mp4;") || e.canPlayType("audio/mp4;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
							weba: !!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
							webm: !!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
							dolby: !!e.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
							flac: !!(e.canPlayType("audio/x-flac;") || e.canPlayType("audio/flac;")).replace(/^no$/, "")
						},
						t
				},
				_enableMobileAudio: function() {
					var t = this || a,
						e = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(t._navigator && t._navigator.userAgent),
						n = !!("ontouchend" in window || t._navigator && t._navigator.maxTouchPoints > 0 || t._navigator && t._navigator.msMaxTouchPoints > 0);
					if(!t._mobileEnabled && t.ctx && (e || n)) {
						t._mobileEnabled = !1,
							t._mobileUnloaded || 44100 === t.ctx.sampleRate || (t._mobileUnloaded = !0,
								t.unload()),
							t._scratchBuffer = t.ctx.createBuffer(1, 1, 22050);
						var i = function() {
							var e = t.ctx.createBufferSource();
							e.buffer = t._scratchBuffer,
								e.connect(t.ctx.destination),
								"undefined" == typeof e.start ? e.noteOn(0) : e.start(0),
								e.onended = function() {
									e.disconnect(0),
										t._mobileEnabled = !0,
										t.mobileAutoEnable = !1,
										document.removeEventListener("touchend", i, !0)
								}
						};
						return document.addEventListener("touchend", i, !0),
							t
					}
				},
				_autoSuspend: function() {
					var t = this;
					if(t.autoSuspend && t.ctx && "undefined" != typeof t.ctx.suspend && a.usingWebAudio) {
						for(var e = 0; e < t._howls.length; e++)
							if(t._howls[e]._webAudio)
								for(var n = 0; n < t._howls[e]._sounds.length; n++)
									if(!t._howls[e]._sounds[n]._paused)
										return t;
						return t._suspendTimer && clearTimeout(t._suspendTimer),
							t._suspendTimer = setTimeout(function() {
								t.autoSuspend && (t._suspendTimer = null,
									t.state = "suspending",
									t.ctx.suspend().then(function() {
										t.state = "suspended",
											t._resumeAfterSuspend && (delete t._resumeAfterSuspend,
												t._autoResume())
									}))
							}, 3e4),
							t
					}
				},
				_autoResume: function() {
					var t = this;
					if(t.ctx && "undefined" != typeof t.ctx.resume && a.usingWebAudio)
						return "running" === t.state && t._suspendTimer ? (clearTimeout(t._suspendTimer),
								t._suspendTimer = null) : "suspended" === t.state ? (t.state = "resuming",
								t.ctx.resume().then(function() {
									t.state = "running";
									for(var e = 0; e < t._howls.length; e++)
										t._howls[e]._emit("resume")
								}),
								t._suspendTimer && (clearTimeout(t._suspendTimer),
									t._suspendTimer = null)) : "suspending" === t.state && (t._resumeAfterSuspend = !0),
							t
				}
			};
			var a = new o,
				s = function(t) {
					var e = this;
					return t.src && 0 !== t.src.length ? void e.init(t) : void console.error("An array of source files must be passed with any new Howl.")
				};
			s.prototype = {
				init: function(t) {
					var e = this;
					return a.ctx || p(),
						e._autoplay = t.autoplay || !1,
						e._format = "string" != typeof t.format ? t.format : [t.format],
						e._html5 = t.html5 || !1,
						e._muted = t.mute || !1,
						e._loop = t.loop || !1,
						e._pool = t.pool || 5,
						e._preload = "boolean" != typeof t.preload || t.preload,
						e._rate = t.rate || 1,
						e._sprite = t.sprite || {},
						e._src = "string" != typeof t.src ? t.src : [t.src],
						e._volume = void 0 !== t.volume ? t.volume : 1,
						e._duration = 0,
						e._state = "unloaded",
						e._sounds = [],
						e._endTimers = {},
						e._queue = [],
						e._onend = t.onend ? [{
							fn: t.onend
						}] : [],
						e._onfade = t.onfade ? [{
							fn: t.onfade
						}] : [],
						e._onload = t.onload ? [{
							fn: t.onload
						}] : [],
						e._onloaderror = t.onloaderror ? [{
							fn: t.onloaderror
						}] : [],
						e._onpause = t.onpause ? [{
							fn: t.onpause
						}] : [],
						e._onplay = t.onplay ? [{
							fn: t.onplay
						}] : [],
						e._onstop = t.onstop ? [{
							fn: t.onstop
						}] : [],
						e._onmute = t.onmute ? [{
							fn: t.onmute
						}] : [],
						e._onvolume = t.onvolume ? [{
							fn: t.onvolume
						}] : [],
						e._onrate = t.onrate ? [{
							fn: t.onrate
						}] : [],
						e._onseek = t.onseek ? [{
							fn: t.onseek
						}] : [],
						e._onresume = [],
						e._webAudio = a.usingWebAudio && !e._html5,
						"undefined" != typeof a.ctx && a.ctx && a.mobileAutoEnable && a._enableMobileAudio(),
						a._howls.push(e),
						e._autoplay && e._queue.push({
							event: "play",
							action: function() {
								e.play()
							}
						}),
						e._preload && e.load(),
						e
				},
				load: function() {
					var t = this,
						e = null;
					if(a.noAudio)
						return void t._emit("loaderror", null, "No audio support.");
					"string" == typeof t._src && (t._src = [t._src]);
					for(var n = 0; n < t._src.length; n++) {
						var i, r;
						if(t._format && t._format[n])
							i = t._format[n];
						else {
							if(r = t._src[n],
								"string" != typeof r) {
								t._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
								continue
							}
							i = /^data:audio\/([^;,]+);/i.exec(r),
								i || (i = /\.([^.]+)$/.exec(r.split("?", 1)[0])),
								i && (i = i[1].toLowerCase())
						}
						if(i || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'),
							i && a.codecs(i)) {
							e = t._src[n];
							break
						}
					}
					return e ? (t._src = e,
						t._state = "loading",
						"https:" === window.location.protocol && "http:" === e.slice(0, 5) && (t._html5 = !0,
							t._webAudio = !1),
						new l(t),
						t._webAudio && u(t),
						t) : void t._emit("loaderror", null, "No codec support for selected audio sources.")
				},
				play: function(t, e) {
					var n = this,
						i = null;
					if("number" == typeof t)
						i = t,
						t = null;
					else {
						if("string" == typeof t && "loaded" === n._state && !n._sprite[t])
							return null;
						if("undefined" == typeof t) {
							t = "__default";
							for(var r = 0, o = 0; o < n._sounds.length; o++)
								n._sounds[o]._paused && !n._sounds[o]._ended && (r++,
									i = n._sounds[o]._id);
							1 === r ? t = null : i = null
						}
					}
					var s = i ? n._soundById(i) : n._inactiveSound();
					if(!s)
						return null;
					if(i && !t && (t = s._sprite || "__default"),
						"loaded" !== n._state && !n._sprite[t])
						return n._queue.push({
								event: "play",
								action: function() {
									n.play(n._soundById(s._id) ? s._id : void 0)
								}
							}),
							s._id;
					if(i && !s._paused)
						return e || setTimeout(function() {
								n._emit("play", s._id)
							}, 0),
							s._id;
					n._webAudio && a._autoResume();
					var l = Math.max(0, s._seek > 0 ? s._seek : n._sprite[t][0] / 1e3),
						c = Math.max(0, (n._sprite[t][0] + n._sprite[t][1]) / 1e3 - l),
						u = 1e3 * c / Math.abs(s._rate);
					s._paused = !1,
						s._ended = !1,
						s._sprite = t,
						s._seek = l,
						s._start = n._sprite[t][0] / 1e3,
						s._stop = (n._sprite[t][0] + n._sprite[t][1]) / 1e3,
						s._loop = !(!s._loop && !n._sprite[t][2]);
					var h = s._node;
					if(n._webAudio) {
						var d = function() {
								n._refreshBuffer(s);
								var t = s._muted || n._muted ? 0 : s._volume;
								h.gain.setValueAtTime(t, a.ctx.currentTime),
									s._playStart = a.ctx.currentTime,
									"undefined" == typeof h.bufferSource.start ? s._loop ? h.bufferSource.noteGrainOn(0, l, 86400) : h.bufferSource.noteGrainOn(0, l, c) : s._loop ? h.bufferSource.start(0, l, 86400) : h.bufferSource.start(0, l, c),
									u !== 1 / 0 && (n._endTimers[s._id] = setTimeout(n._ended.bind(n, s), u)),
									e || setTimeout(function() {
										n._emit("play", s._id)
									}, 0)
							},
							f = "running" === a.state;
						if("loaded" === n._state && f)
							d();
						else {
							var p = f || "loaded" !== n._state ? "load" : "resume";
							n.once(p, d, f ? s._id : null),
								n._clearTimer(s._id)
						}
					} else {
						var m = function() {
								h.currentTime = l,
									h.muted = s._muted || n._muted || a._muted || h.muted,
									h.volume = s._volume * a.volume(),
									h.playbackRate = s._rate,
									h.play(),
									u !== 1 / 0 && (n._endTimers[s._id] = setTimeout(n._ended.bind(n, s), u)),
									e || n._emit("play", s._id)
							},
							v = "loaded" === n._state && (window && window.ejecta || !h.readyState && a._navigator.isCocoonJS);
						if(4 === h.readyState || v)
							m();
						else {
							var g = function() {
								m(),
									h.removeEventListener(a._canPlayEvent, g, !1)
							};
							h.addEventListener(a._canPlayEvent, g, !1),
								n._clearTimer(s._id)
						}
					}
					return s._id
				},
				pause: function(t) {
					var e = this;
					if("loaded" !== e._state)
						return e._queue.push({
								event: "pause",
								action: function() {
									e.pause(t)
								}
							}),
							e;
					for(var n = e._getSoundIds(t), i = 0; i < n.length; i++) {
						e._clearTimer(n[i]);
						var r = e._soundById(n[i]);
						if(r && !r._paused && (r._seek = e.seek(n[i]),
								r._rateSeek = 0,
								r._paused = !0,
								e._stopFade(n[i]),
								r._node))
							if(e._webAudio) {
								if(!r._node.bufferSource)
									return e;
								"undefined" == typeof r._node.bufferSource.stop ? r._node.bufferSource.noteOff(0) : r._node.bufferSource.stop(0),
									e._cleanBuffer(r._node)
							} else
								isNaN(r._node.duration) && r._node.duration !== 1 / 0 || r._node.pause();
						arguments[1] || e._emit("pause", r ? r._id : null)
					}
					return e
				},
				stop: function(t, e) {
					var n = this;
					if("loaded" !== n._state)
						return n._queue.push({
								event: "stop",
								action: function() {
									n.stop(t)
								}
							}),
							n;
					for(var i = n._getSoundIds(t), r = 0; r < i.length; r++) {
						n._clearTimer(i[r]);
						var o = n._soundById(i[r]);
						if(o && (o._seek = o._start || 0,
								o._rateSeek = 0,
								o._paused = !0,
								o._ended = !0,
								n._stopFade(i[r]),
								o._node))
							if(n._webAudio) {
								if(!o._node.bufferSource)
									return e || n._emit("stop", o._id),
										n;
								"undefined" == typeof o._node.bufferSource.stop ? o._node.bufferSource.noteOff(0) : o._node.bufferSource.stop(0),
									n._cleanBuffer(o._node)
							} else
								isNaN(o._node.duration) && o._node.duration !== 1 / 0 || (o._node.currentTime = o._start || 0,
									o._node.pause());
						o && !e && n._emit("stop", o._id)
					}
					return n
				},
				mute: function(t, e) {
					var n = this;
					if("loaded" !== n._state)
						return n._queue.push({
								event: "mute",
								action: function() {
									n.mute(t, e)
								}
							}),
							n;
					if("undefined" == typeof e) {
						if("boolean" != typeof t)
							return n._muted;
						n._muted = t
					}
					for(var i = n._getSoundIds(e), r = 0; r < i.length; r++) {
						var o = n._soundById(i[r]);
						o && (o._muted = t,
							n._webAudio && o._node ? o._node.gain.setValueAtTime(t ? 0 : o._volume, a.ctx.currentTime) : o._node && (o._node.muted = !!a._muted || t),
							n._emit("mute", o._id))
					}
					return n
				},
				volume: function() {
					var t, e, n = this,
						i = arguments;
					if(0 === i.length)
						return n._volume;
					if(1 === i.length || 2 === i.length && "undefined" == typeof i[1]) {
						var r = n._getSoundIds(),
							o = r.indexOf(i[0]);
						o >= 0 ? e = parseInt(i[0], 10) : t = parseFloat(i[0])
					} else
						i.length >= 2 && (t = parseFloat(i[0]),
							e = parseInt(i[1], 10));
					var s;
					if(!("undefined" != typeof t && t >= 0 && t <= 1))
						return s = e ? n._soundById(e) : n._sounds[0],
							s ? s._volume : 0;
					if("loaded" !== n._state)
						return n._queue.push({
								event: "volume",
								action: function() {
									n.volume.apply(n, i)
								}
							}),
							n;
					"undefined" == typeof e && (n._volume = t),
						e = n._getSoundIds(e);
					for(var l = 0; l < e.length; l++)
						s = n._soundById(e[l]),
						s && (s._volume = t,
							i[2] || n._stopFade(e[l]),
							n._webAudio && s._node && !s._muted ? s._node.gain.setValueAtTime(t, a.ctx.currentTime) : s._node && !s._muted && (s._node.volume = t * a.volume()),
							n._emit("volume", s._id));
					return n
				},
				fade: function(t, e, n, i) {
					var r = this,
						o = Math.abs(t - e),
						s = t > e ? "out" : "in",
						l = o / .01,
						c = l > 0 ? n / l : n;
					if(c < 4 && (l = Math.ceil(l / (4 / c)),
							c = 4),
						"loaded" !== r._state)
						return r._queue.push({
								event: "fade",
								action: function() {
									r.fade(t, e, n, i)
								}
							}),
							r;
					r.volume(t, i);
					for(var u = r._getSoundIds(i), h = 0; h < u.length; h++) {
						var d = r._soundById(u[h]);
						if(d) {
							if(i || r._stopFade(u[h]),
								r._webAudio && !d._muted) {
								var f = a.ctx.currentTime,
									p = f + n / 1e3;
								d._volume = t,
									d._node.gain.setValueAtTime(t, f),
									d._node.gain.linearRampToValueAtTime(e, p)
							}
							var m = t;
							d._interval = setInterval(function(n, o) {
									l > 0 && (m += "in" === s ? .01 : -.01),
										m = Math.max(0, m),
										m = Math.min(1, m),
										m = Math.round(100 * m) / 100,
										r._webAudio ? ("undefined" == typeof i && (r._volume = m),
											o._volume = m) : r.volume(m, n, !0),
										(e < t && m <= e || e > t && m >= e) && (clearInterval(o._interval),
											o._interval = null,
											r.volume(e, n),
											r._emit("fade", n))
								}
								.bind(r, u[h], d), c)
						}
					}
					return r
				},
				_stopFade: function(t) {
					var e = this,
						n = e._soundById(t);
					return n && n._interval && (e._webAudio && n._node.gain.cancelScheduledValues(a.ctx.currentTime),
							clearInterval(n._interval),
							n._interval = null,
							e._emit("fade", t)),
						e
				},
				loop: function() {
					var t, e, n, i = this,
						r = arguments;
					if(0 === r.length)
						return i._loop;
					if(1 === r.length) {
						if("boolean" != typeof r[0])
							return n = i._soundById(parseInt(r[0], 10)), !!n && n._loop;
						t = r[0],
							i._loop = t
					} else
						2 === r.length && (t = r[0],
							e = parseInt(r[1], 10));
					for(var o = i._getSoundIds(e), a = 0; a < o.length; a++)
						n = i._soundById(o[a]),
						n && (n._loop = t,
							i._webAudio && n._node && n._node.bufferSource && (n._node.bufferSource.loop = t,
								t && (n._node.bufferSource.loopStart = n._start || 0,
									n._node.bufferSource.loopEnd = n._stop)));
					return i
				},
				rate: function() {
					var t, e, n = this,
						i = arguments;
					if(0 === i.length)
						e = n._sounds[0]._id;
					else if(1 === i.length) {
						var r = n._getSoundIds(),
							o = r.indexOf(i[0]);
						o >= 0 ? e = parseInt(i[0], 10) : t = parseFloat(i[0])
					} else
						2 === i.length && (t = parseFloat(i[0]),
							e = parseInt(i[1], 10));
					var s;
					if("number" != typeof t)
						return s = n._soundById(e),
							s ? s._rate : n._rate;
					if("loaded" !== n._state)
						return n._queue.push({
								event: "rate",
								action: function() {
									n.rate.apply(n, i)
								}
							}),
							n;
					"undefined" == typeof e && (n._rate = t),
						e = n._getSoundIds(e);
					for(var l = 0; l < e.length; l++)
						if(s = n._soundById(e[l])) {
							s._rateSeek = n.seek(e[l]),
								s._playStart = n._webAudio ? a.ctx.currentTime : s._playStart,
								s._rate = t,
								n._webAudio && s._node && s._node.bufferSource ? s._node.bufferSource.playbackRate.value = t : s._node && (s._node.playbackRate = t);
							var c = n.seek(e[l]),
								u = (n._sprite[s._sprite][0] + n._sprite[s._sprite][1]) / 1e3 - c,
								h = 1e3 * u / Math.abs(s._rate);
							!n._endTimers[e[l]] && s._paused || (n._clearTimer(e[l]),
									n._endTimers[e[l]] = setTimeout(n._ended.bind(n, s), h)),
								n._emit("rate", s._id)
						}
					return n
				},
				seek: function() {
					var t, e, n = this,
						i = arguments;
					if(0 === i.length)
						e = n._sounds[0]._id;
					else if(1 === i.length) {
						var r = n._getSoundIds(),
							o = r.indexOf(i[0]);
						o >= 0 ? e = parseInt(i[0], 10) : (e = n._sounds[0]._id,
							t = parseFloat(i[0]))
					} else
						2 === i.length && (t = parseFloat(i[0]),
							e = parseInt(i[1], 10));
					if("undefined" == typeof e)
						return n;
					if("loaded" !== n._state)
						return n._queue.push({
								event: "seek",
								action: function() {
									n.seek.apply(n, i)
								}
							}),
							n;
					var s = n._soundById(e);
					if(s) {
						if(!("number" == typeof t && t >= 0)) {
							if(n._webAudio) {
								var l = n.playing(e) ? a.ctx.currentTime - s._playStart : 0,
									c = s._rateSeek ? s._rateSeek - s._seek : 0;
								return s._seek + (c + l * Math.abs(s._rate))
							}
							return s._node.currentTime
						}
						var u = n.playing(e);
						u && n.pause(e, !0),
							s._seek = t,
							s._ended = !1,
							n._clearTimer(e),
							u && n.play(e, !0), !n._webAudio && s._node && (s._node.currentTime = t),
							n._emit("seek", e)
					}
					return n
				},
				playing: function(t) {
					var e = this;
					if("number" == typeof t) {
						var n = e._soundById(t);
						return !!n && !n._paused
					}
					for(var i = 0; i < e._sounds.length; i++)
						if(!e._sounds[i]._paused)
							return !0;
					return !1
				},
				duration: function(t) {
					var e = this,
						n = e._duration,
						i = e._soundById(t);
					return i && (n = e._sprite[i._sprite][1] / 1e3),
						n
				},
				state: function() {
					return this._state
				},
				unload: function() {
					for(var t = this, e = t._sounds, n = 0; n < e.length; n++) {
						e[n]._paused || t.stop(e[n]._id),
							t._webAudio || (e[n]._node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA",
								e[n]._node.removeEventListener("error", e[n]._errorFn, !1),
								e[n]._node.removeEventListener(a._canPlayEvent, e[n]._loadFn, !1)),
							delete e[n]._node,
							t._clearTimer(e[n]._id);
						var i = a._howls.indexOf(t);
						i >= 0 && a._howls.splice(i, 1)
					}
					var r = !0;
					for(n = 0; n < a._howls.length; n++)
						if(a._howls[n]._src === t._src) {
							r = !1;
							break
						}
					return c && r && delete c[t._src],
						a.noAudio = !1,
						t._state = "unloaded",
						t._sounds = [],
						t = null,
						null
				},
				on: function(t, e, n, i) {
					var r = this,
						o = r["_on" + t];
					return "function" == typeof e && o.push(i ? {
							id: n,
							fn: e,
							once: i
						} : {
							id: n,
							fn: e
						}),
						r
				},
				off: function(t, e, n) {
					var i = this,
						r = i["_on" + t],
						o = 0;
					if(e) {
						for(o = 0; o < r.length; o++)
							if(e === r[o].fn && n === r[o].id) {
								r.splice(o, 1);
								break
							}
					} else if(t)
						i["_on" + t] = [];
					else {
						var a = Object.keys(i);
						for(o = 0; o < a.length; o++)
							0 === a[o].indexOf("_on") && Array.isArray(i[a[o]]) && (i[a[o]] = [])
					}
					return i
				},
				once: function(t, e, n) {
					var i = this;
					return i.on(t, e, n, 1),
						i
				},
				_emit: function(t, e, n) {
					for(var i = this, r = i["_on" + t], o = r.length - 1; o >= 0; o--)
						r[o].id && r[o].id !== e && "load" !== t || (setTimeout(function(t) {
									t.call(this, e, n)
								}
								.bind(i, r[o].fn), 0),
							r[o].once && i.off(t, r[o].fn, r[o].id));
					return i
				},
				_loadQueue: function() {
					var t = this;
					if(t._queue.length > 0) {
						var e = t._queue[0];
						t.once(e.event, function() {
								t._queue.shift(),
									t._loadQueue()
							}),
							e.action()
					}
					return t
				},
				_ended: function(t) {
					var e = this,
						n = t._sprite,
						i = !(!t._loop && !e._sprite[n][2]);
					if(e._emit("end", t._id), !e._webAudio && i && e.stop(t._id, !0).play(t._id),
						e._webAudio && i) {
						e._emit("play", t._id),
							t._seek = t._start || 0,
							t._rateSeek = 0,
							t._playStart = a.ctx.currentTime;
						var r = 1e3 * (t._stop - t._start) / Math.abs(t._rate);
						e._endTimers[t._id] = setTimeout(e._ended.bind(e, t), r)
					}
					return e._webAudio && !i && (t._paused = !0,
							t._ended = !0,
							t._seek = t._start || 0,
							t._rateSeek = 0,
							e._clearTimer(t._id),
							e._cleanBuffer(t._node),
							a._autoSuspend()),
						e._webAudio || i || e.stop(t._id),
						e
				},
				_clearTimer: function(t) {
					var e = this;
					return e._endTimers[t] && (clearTimeout(e._endTimers[t]),
							delete e._endTimers[t]),
						e
				},
				_soundById: function(t) {
					for(var e = this, n = 0; n < e._sounds.length; n++)
						if(t === e._sounds[n]._id)
							return e._sounds[n];
					return null
				},
				_inactiveSound: function() {
					var t = this;
					t._drain();
					for(var e = 0; e < t._sounds.length; e++)
						if(t._sounds[e]._ended)
							return t._sounds[e].reset();
					return new l(t)
				},
				_drain: function() {
					var t = this,
						e = t._pool,
						n = 0,
						i = 0;
					if(!(t._sounds.length < e)) {
						for(i = 0; i < t._sounds.length; i++)
							t._sounds[i]._ended && n++;
						for(i = t._sounds.length - 1; i >= 0; i--) {
							if(n <= e)
								return;
							t._sounds[i]._ended && (t._webAudio && t._sounds[i]._node && t._sounds[i]._node.disconnect(0),
								t._sounds.splice(i, 1),
								n--)
						}
					}
				},
				_getSoundIds: function(t) {
					var e = this;
					if("undefined" == typeof t) {
						for(var n = [], i = 0; i < e._sounds.length; i++)
							n.push(e._sounds[i]._id);
						return n
					}
					return [t]
				},
				_refreshBuffer: function(t) {
					var e = this;
					return t._node.bufferSource = a.ctx.createBufferSource(),
						t._node.bufferSource.buffer = c[e._src],
						t._panner ? t._node.bufferSource.connect(t._panner) : t._node.bufferSource.connect(t._node),
						t._node.bufferSource.loop = t._loop,
						t._loop && (t._node.bufferSource.loopStart = t._start || 0,
							t._node.bufferSource.loopEnd = t._stop),
						t._node.bufferSource.playbackRate.value = t._rate,
						e
				},
				_cleanBuffer: function(t) {
					var e = this;
					if(e._scratchBuffer) {
						t.bufferSource.onended = null,
							t.bufferSource.disconnect(0);
						try {
							t.bufferSource.buffer = e._scratchBuffer
						} catch(t) {}
					}
					return t.bufferSource = null,
						e
				}
			};
			var l = function(t) {
				this._parent = t,
					this.init()
			};
			l.prototype = {
				init: function() {
					var t = this,
						e = t._parent;
					return t._muted = e._muted,
						t._loop = e._loop,
						t._volume = e._volume,
						t._muted = e._muted,
						t._rate = e._rate,
						t._seek = 0,
						t._paused = !0,
						t._ended = !0,
						t._sprite = "__default",
						t._id = ++a._counter,
						e._sounds.push(t),
						t.create(),
						t
				},
				create: function() {
					var t = this,
						e = t._parent,
						n = a._muted || t._muted || t._parent._muted ? 0 : t._volume;
					return e._webAudio ? (t._node = "undefined" == typeof a.ctx.createGain ? a.ctx.createGainNode() : a.ctx.createGain(),
							t._node.gain.setValueAtTime(n, a.ctx.currentTime),
							t._node.paused = !0,
							t._node.connect(a.masterGain)) : (t._node = new Audio,
							t._errorFn = t._errorListener.bind(t),
							t._node.addEventListener("error", t._errorFn, !1),
							t._loadFn = t._loadListener.bind(t),
							t._node.addEventListener(a._canPlayEvent, t._loadFn, !1),
							t._node.src = e._src,
							t._node.preload = "auto",
							t._node.volume = n * a.volume(),
							t._node.load()),
						t
				},
				reset: function() {
					var t = this,
						e = t._parent;
					return t._muted = e._muted,
						t._loop = e._loop,
						t._volume = e._volume,
						t._muted = e._muted,
						t._rate = e._rate,
						t._seek = 0,
						t._rateSeek = 0,
						t._paused = !0,
						t._ended = !0,
						t._sprite = "__default",
						t._id = ++a._counter,
						t
				},
				_errorListener: function() {
					var t = this;
					t._parent._emit("loaderror", t._id, t._node.error ? t._node.error.code : 0),
						t._node.removeEventListener("error", t._errorListener, !1)
				},
				_loadListener: function() {
					var t = this,
						e = t._parent;
					e._duration = Math.ceil(10 * t._node.duration) / 10,
						0 === Object.keys(e._sprite).length && (e._sprite = {
							__default: [0, 1e3 * e._duration]
						}),
						"loaded" !== e._state && (e._state = "loaded",
							e._emit("load"),
							e._loadQueue()),
						t._node.removeEventListener(a._canPlayEvent, t._loadFn, !1)
				}
			};
			var c = {},
				u = function(t) {
					var e = t._src;
					if(c[e])
						return t._duration = c[e].duration,
							void f(t);
					if(/^data:[^;]+;base64,/.test(e)) {
						for(var n = atob(e.split(",")[1]), i = new Uint8Array(n.length), r = 0; r < n.length; ++r)
							i[r] = n.charCodeAt(r);
						d(i.buffer, t)
					} else {
						var o = new XMLHttpRequest;
						o.open("GET", e, !0),
							o.responseType = "arraybuffer",
							o.onload = function() {
								var e = (o.status + "")[0];
								return "0" !== e && "2" !== e && "3" !== e ? void t._emit("loaderror", null, "Failed loading audio file with status: " + o.status + ".") : void d(o.response, t)
							},
							o.onerror = function() {
								t._webAudio && (t._html5 = !0,
									t._webAudio = !1,
									t._sounds = [],
									delete c[e],
									t.load())
							},
							h(o)
					}
				},
				h = function(t) {
					try {
						t.send()
					} catch(e) {
						t.onerror()
					}
				},
				d = function(t, e) {
					a.ctx.decodeAudioData(t, function(t) {
						t && e._sounds.length > 0 && (c[e._src] = t,
							f(e, t))
					}, function() {
						e._emit("loaderror", null, "Decoding audio data failed.")
					})
				},
				f = function(t, e) {
					e && !t._duration && (t._duration = e.duration),
						0 === Object.keys(t._sprite).length && (t._sprite = {
							__default: [0, 1e3 * t._duration]
						}),
						"loaded" !== t._state && (t._state = "loaded",
							t._emit("load"),
							t._loadQueue())
				},
				p = function() {
					try {
						"undefined" != typeof AudioContext ? a.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? a.ctx = new webkitAudioContext : a.usingWebAudio = !1
					} catch(t) {
						a.usingWebAudio = !1
					}
					var t = /iP(hone|od|ad)/.test(a._navigator && a._navigator.platform),
						e = a._navigator && a._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
						n = e ? parseInt(e[1], 10) : null;
					if(t && n && n < 9) {
						var i = /safari/.test(a._navigator && a._navigator.userAgent.toLowerCase());
						(a._navigator && a._navigator.standalone && !i || a._navigator && !a._navigator.standalone && !i) && (a.usingWebAudio = !1)
					}
					a.usingWebAudio && (a.masterGain = "undefined" == typeof a.ctx.createGain ? a.ctx.createGainNode() : a.ctx.createGain(),
							a.masterGain.gain.value = 1,
							a.masterGain.connect(a.ctx.destination)),
						a._setup()
				};
			i = [],
				r = function() {
					return {
						Howler: a,
						Howl: s
					}
				}
				.apply(e, i), !(void 0 !== r && (t.exports = r)),
				e.Howler = a,
				e.Howl = s,
				"undefined" != typeof window ? (window.HowlerGlobal = o,
					window.Howler = a,
					window.Howl = s,
					window.Sound = l) : "undefined" != typeof n && (n.HowlerGlobal = o,
					n.Howler = a,
					n.Howl = s,
					n.Sound = l)
		}(),
		/*!
		 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
		 *  
		 *  howler.js v2.0.3
		 *  howlerjs.com
		 *
		 *  (c) 2013-2017, James Simpson of GoldFire Studios
		 *  goldfirestudios.com
		 *
		 *  MIT License
		 */
		function() {
			"use strict";
			HowlerGlobal.prototype._pos = [0, 0, 0],
				HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0],
				HowlerGlobal.prototype.stereo = function(t) {
					var e = this;
					if(!e.ctx || !e.ctx.listener)
						return e;
					for(var n = e._howls.length - 1; n >= 0; n--)
						e._howls[n].stereo(t);
					return e
				},
				HowlerGlobal.prototype.pos = function(t, e, n) {
					var i = this;
					return i.ctx && i.ctx.listener ? (e = "number" != typeof e ? i._pos[1] : e,
						n = "number" != typeof n ? i._pos[2] : n,
						"number" != typeof t ? i._pos : (i._pos = [t, e, n],
							i.ctx.listener.setPosition(i._pos[0], i._pos[1], i._pos[2]),
							i)) : i
				},
				HowlerGlobal.prototype.orientation = function(t, e, n, i, r, o) {
					var a = this;
					if(!a.ctx || !a.ctx.listener)
						return a;
					var s = a._orientation;
					return e = "number" != typeof e ? s[1] : e,
						n = "number" != typeof n ? s[2] : n,
						i = "number" != typeof i ? s[3] : i,
						r = "number" != typeof r ? s[4] : r,
						o = "number" != typeof o ? s[5] : o,
						"number" != typeof t ? s : (a._orientation = [t, e, n, i, r, o],
							a.ctx.listener.setOrientation(t, e, n, i, r, o),
							a)
				},
				Howl.prototype.init = function(t) {
					return function(e) {
						var n = this;
						return n._orientation = e.orientation || [1, 0, 0],
							n._stereo = e.stereo || null,
							n._pos = e.pos || null,
							n._pannerAttr = {
								coneInnerAngle: "undefined" != typeof e.coneInnerAngle ? e.coneInnerAngle : 360,
								coneOuterAngle: "undefined" != typeof e.coneOuterAngle ? e.coneOuterAngle : 360,
								coneOuterGain: "undefined" != typeof e.coneOuterGain ? e.coneOuterGain : 0,
								distanceModel: "undefined" != typeof e.distanceModel ? e.distanceModel : "inverse",
								maxDistance: "undefined" != typeof e.maxDistance ? e.maxDistance : 1e4,
								panningModel: "undefined" != typeof e.panningModel ? e.panningModel : "HRTF",
								refDistance: "undefined" != typeof e.refDistance ? e.refDistance : 1,
								rolloffFactor: "undefined" != typeof e.rolloffFactor ? e.rolloffFactor : 1
							},
							n._onstereo = e.onstereo ? [{
								fn: e.onstereo
							}] : [],
							n._onpos = e.onpos ? [{
								fn: e.onpos
							}] : [],
							n._onorientation = e.onorientation ? [{
								fn: e.onorientation
							}] : [],
							t.call(this, e)
					}
				}(Howl.prototype.init),
				Howl.prototype.stereo = function(e, n) {
					var i = this;
					if(!i._webAudio)
						return i;
					if("loaded" !== i._state)
						return i._queue.push({
								event: "stereo",
								action: function() {
									i.stereo(e, n)
								}
							}),
							i;
					var r = "undefined" == typeof Howler.ctx.createStereoPanner ? "spatial" : "stereo";
					if("undefined" == typeof n) {
						if("number" != typeof e)
							return i._stereo;
						i._stereo = e,
							i._pos = [e, 0, 0]
					}
					for(var o = i._getSoundIds(n), a = 0; a < o.length; a++) {
						var s = i._soundById(o[a]);
						if(s) {
							if("number" != typeof e)
								return s._stereo;
							s._stereo = e,
								s._pos = [e, 0, 0],
								s._node && (s._pannerAttr.panningModel = "equalpower",
									s._panner && s._panner.pan || t(s, r),
									"spatial" === r ? s._panner.setPosition(e, 0, 0) : s._panner.pan.value = e),
								i._emit("stereo", s._id)
						}
					}
					return i
				},
				Howl.prototype.pos = function(e, n, i, r) {
					var o = this;
					if(!o._webAudio)
						return o;
					if("loaded" !== o._state)
						return o._queue.push({
								event: "pos",
								action: function() {
									o.pos(e, n, i, r)
								}
							}),
							o;
					if(n = "number" != typeof n ? 0 : n,
						i = "number" != typeof i ? -.5 : i,
						"undefined" == typeof r) {
						if("number" != typeof e)
							return o._pos;
						o._pos = [e, n, i]
					}
					for(var a = o._getSoundIds(r), s = 0; s < a.length; s++) {
						var l = o._soundById(a[s]);
						if(l) {
							if("number" != typeof e)
								return l._pos;
							l._pos = [e, n, i],
								l._node && (l._panner && !l._panner.pan || t(l, "spatial"),
									l._panner.setPosition(e, n, i)),
								o._emit("pos", l._id)
						}
					}
					return o
				},
				Howl.prototype.orientation = function(e, n, i, r) {
					var o = this;
					if(!o._webAudio)
						return o;
					if("loaded" !== o._state)
						return o._queue.push({
								event: "orientation",
								action: function() {
									o.orientation(e, n, i, r)
								}
							}),
							o;
					if(n = "number" != typeof n ? o._orientation[1] : n,
						i = "number" != typeof i ? o._orientation[2] : i,
						"undefined" == typeof r) {
						if("number" != typeof e)
							return o._orientation;
						o._orientation = [e, n, i]
					}
					for(var a = o._getSoundIds(r), s = 0; s < a.length; s++) {
						var l = o._soundById(a[s]);
						if(l) {
							if("number" != typeof e)
								return l._orientation;
							l._orientation = [e, n, i],
								l._node && (l._panner || (l._pos || (l._pos = o._pos || [0, 0, -.5]),
										t(l, "spatial")),
									l._panner.setOrientation(e, n, i)),
								o._emit("orientation", l._id)
						}
					}
					return o
				},
				Howl.prototype.pannerAttr = function() {
					var e, n, i, r = this,
						o = arguments;
					if(!r._webAudio)
						return r;
					if(0 === o.length)
						return r._pannerAttr;
					if(1 === o.length) {
						if("object" != typeof o[0])
							return i = r._soundById(parseInt(o[0], 10)),
								i ? i._pannerAttr : r._pannerAttr;
						e = o[0],
							"undefined" == typeof n && (r._pannerAttr = {
								coneInnerAngle: "undefined" != typeof e.coneInnerAngle ? e.coneInnerAngle : r._coneInnerAngle,
								coneOuterAngle: "undefined" != typeof e.coneOuterAngle ? e.coneOuterAngle : r._coneOuterAngle,
								coneOuterGain: "undefined" != typeof e.coneOuterGain ? e.coneOuterGain : r._coneOuterGain,
								distanceModel: "undefined" != typeof e.distanceModel ? e.distanceModel : r._distanceModel,
								maxDistance: "undefined" != typeof e.maxDistance ? e.maxDistance : r._maxDistance,
								panningModel: "undefined" != typeof e.panningModel ? e.panningModel : r._panningModel,
								refDistance: "undefined" != typeof e.refDistance ? e.refDistance : r._refDistance,
								rolloffFactor: "undefined" != typeof e.rolloffFactor ? e.rolloffFactor : r._rolloffFactor
							})
					} else
						2 === o.length && (e = o[0],
							n = parseInt(o[1], 10));
					for(var a = r._getSoundIds(n), s = 0; s < a.length; s++)
						if(i = r._soundById(a[s])) {
							var l = i._pannerAttr;
							l = {
								coneInnerAngle: "undefined" != typeof e.coneInnerAngle ? e.coneInnerAngle : l.coneInnerAngle,
								coneOuterAngle: "undefined" != typeof e.coneOuterAngle ? e.coneOuterAngle : l.coneOuterAngle,
								coneOuterGain: "undefined" != typeof e.coneOuterGain ? e.coneOuterGain : l.coneOuterGain,
								distanceModel: "undefined" != typeof e.distanceModel ? e.distanceModel : l.distanceModel,
								maxDistance: "undefined" != typeof e.maxDistance ? e.maxDistance : l.maxDistance,
								panningModel: "undefined" != typeof e.panningModel ? e.panningModel : l.panningModel,
								refDistance: "undefined" != typeof e.refDistance ? e.refDistance : l.refDistance,
								rolloffFactor: "undefined" != typeof e.rolloffFactor ? e.rolloffFactor : l.rolloffFactor
							};
							var c = i._panner;
							c ? (c.coneInnerAngle = l.coneInnerAngle,
								c.coneOuterAngle = l.coneOuterAngle,
								c.coneOuterGain = l.coneOuterGain,
								c.distanceModel = l.distanceModel,
								c.maxDistance = l.maxDistance,
								c.panningModel = l.panningModel,
								c.refDistance = l.refDistance,
								c.rolloffFactor = l.rolloffFactor) : (i._pos || (i._pos = r._pos || [0, 0, -.5]),
								t(i, "spatial"))
						}
					return r
				},
				Sound.prototype.init = function(t) {
					return function() {
						var e = this,
							n = e._parent;
						e._orientation = n._orientation,
							e._stereo = n._stereo,
							e._pos = n._pos,
							e._pannerAttr = n._pannerAttr,
							t.call(this),
							e._stereo ? n.stereo(e._stereo) : e._pos && n.pos(e._pos[0], e._pos[1], e._pos[2], e._id)
					}
				}(Sound.prototype.init),
				Sound.prototype.reset = function(t) {
					return function() {
						var e = this,
							n = e._parent;
						return e._orientation = n._orientation,
							e._pos = n._pos,
							e._pannerAttr = n._pannerAttr,
							t.call(this)
					}
				}(Sound.prototype.reset);
			var t = function(t, e) {
				e = e || "spatial",
					"spatial" === e ? (t._panner = Howler.ctx.createPanner(),
						t._panner.coneInnerAngle = t._pannerAttr.coneInnerAngle,
						t._panner.coneOuterAngle = t._pannerAttr.coneOuterAngle,
						t._panner.coneOuterGain = t._pannerAttr.coneOuterGain,
						t._panner.distanceModel = t._pannerAttr.distanceModel,
						t._panner.maxDistance = t._pannerAttr.maxDistance,
						t._panner.panningModel = t._pannerAttr.panningModel,
						t._panner.refDistance = t._pannerAttr.refDistance,
						t._panner.rolloffFactor = t._pannerAttr.rolloffFactor,
						t._panner.setPosition(t._pos[0], t._pos[1], t._pos[2]),
						t._panner.setOrientation(t._orientation[0], t._orientation[1], t._orientation[2])) : (t._panner = Howler.ctx.createStereoPanner(),
						t._panner.pan.value = t._stereo),
					t._panner.connect(t._node),
					t._paused || t._parent.pause(t._id, !0).play(t._id)
			}
		}()
	}).call(e, function() {
		return this
	}())
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function o(t, e) {
		O = _.default.getCamera();
		var n = p.default.isIOS && !p.default.ip6;
		n ? (E = new d.DeviceOrientationControls(O),
				S = new d.DeviceOrientationControls(P),
				X = new d.DeviceOrientationControls(A)) : b.default.touchControl$.subscribe(function(t) {
				R ? c(t) : u(t)
			}),
			p.default.isDev & !M && (M = new d.OrbitControls(t, e)),
			v.default.on(T, function() {
				t.aspect = window.innerWidth / window.innerHeight,
					t.updateProjectionMatrix()
			})
	}

	function a() {
		p.default.isDev && M.update();
		var t = p.default.isIOS && !p.default.ip6;
		if(t)
			if(p.default.lookingAround) {
				S.update();
				var e = S.object.quaternion;
				s(e)
			} else {
				X.update();
				var n = X.object.quaternion;
				l(n)
			}
		else
			R = !p.default.lookingAround
	}

	function s(t) {
		var e = new d.Vector3(0, 0, -1);
		e.applyQuaternion(t),
			e.z < 0 && E.update()
	}

	function l(t) {
		var e = new d.Vector3(0, 0, -1);
		e.applyQuaternion(t);
		var n = e.y > 0 ? 0 : e.y,
			i = 2 * n + 1;
		p.default.expectedControlX = e.x,
			p.default.expectedControlY = i
	}

	function c(t) {
		var e = t.x,
			n = t.y;
		p.default.expectedControlX = e,
			p.default.expectedControlY = n
	}

	function u(t) {
		var e = t.x,
			n = t.y;
		O.rotation.y = -Math.PI / 2 * e,
			O.rotation.x = Math.PI / 2 * n
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var h = n(9),
		d = r(h),
		f = n(11),
		p = i(f),
		m = n(30),
		v = i(m),
		g = n(8),
		_ = i(g);
	n(61),
		n(57);
	var y = (n(62),
			n(63)),
		b = i(y),
		x = n(10),
		w = i(x),
		T = (w.default.CHANGE_SPEED_X,
			w.default.CHANGE_SPEED_Y,
			w.default.WINDOW_RESIZE),
		M = void 0,
		E = void 0,
		S = void 0,
		X = void 0,
		A = (.25 * Math.PI,
			new d.Object3D),
		P = new d.Object3D,
		R = !0,
		O = void 0;
	e.default = {
		init: o,
		update: a
	}
}, function(t, e, n) {
	"use strict";

	function i(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var r = n(9),
		o = i(r);
	o.OrbitControls = function(t, e) {
			function n() {
				return 2 * Math.PI / 60 / 60 * I.autoRotateSpeed
			}

			function i() {
				return Math.pow(.95, I.zoomSpeed)
			}

			function r(t) {
				j.theta -= t
			}

			function a(t) {
				j.phi -= t
			}

			function s(t) {
				I.object instanceof o.PerspectiveCamera ? V /= t : I.object instanceof o.OrthographicCamera ? (I.object.zoom = Math.max(I.minZoom, Math.min(I.maxZoom, I.object.zoom * t)),
					I.object.updateProjectionMatrix(),
					H = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
					I.enableZoom = !1)
			}

			function l(t) {
				I.object instanceof o.PerspectiveCamera ? V *= t : I.object instanceof o.OrthographicCamera ? (I.object.zoom = Math.max(I.minZoom, Math.min(I.maxZoom, I.object.zoom / t)),
					I.object.updateProjectionMatrix(),
					H = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
					I.enableZoom = !1)
			}

			function c(t) {
				W.set(t.clientX, t.clientY)
			}

			function u(t) {
				K.set(t.clientX, t.clientY)
			}

			function h(t) {
				Z.set(t.clientX, t.clientY)
			}

			function d(t) {
				Y.set(t.clientX, t.clientY),
					q.subVectors(Y, W);
				var e = I.domElement === document ? I.domElement.body : I.domElement;
				r(2 * Math.PI * q.x / e.clientWidth * I.rotateSpeed),
					a(2 * Math.PI * q.y / e.clientHeight * I.rotateSpeed),
					W.copy(Y),
					I.update()
			}

			function f(t) {
				$.set(t.clientX, t.clientY),
					tt.subVectors($, K),
					tt.y > 0 ? s(i()) : tt.y < 0 && l(i()),
					K.copy($),
					I.update()
			}

			function p(t) {
				Q.set(t.clientX, t.clientY),
					J.subVectors(Q, Z),
					it(J.x, J.y),
					Z.copy(Q),
					I.update()
			}

			function m(t) {}

			function v(t) {
				t.deltaY < 0 ? l(i()) : t.deltaY > 0 && s(i()),
					I.update()
			}

			function g(t) {
				switch(t.keyCode) {
					case I.keys.UP:
						it(0, I.keyPanSpeed),
							I.update();
						break;
					case I.keys.BOTTOM:
						it(0, -I.keyPanSpeed),
							I.update();
						break;
					case I.keys.LEFT:
						it(I.keyPanSpeed, 0),
							I.update();
						break;
					case I.keys.RIGHT:
						it(-I.keyPanSpeed, 0),
							I.update()
				}
			}

			function _(t) {
				W.set(t.touches[0].pageX, t.touches[0].pageY)
			}

			function y(t) {
				var e = t.touches[0].pageX - t.touches[1].pageX,
					n = t.touches[0].pageY - t.touches[1].pageY,
					i = Math.sqrt(e * e + n * n);
				K.set(0, i)
			}

			function b(t) {
				Z.set(t.touches[0].pageX, t.touches[0].pageY)
			}

			function x(t) {
				Y.set(t.touches[0].pageX, t.touches[0].pageY),
					q.subVectors(Y, W);
				var e = I.domElement === document ? I.domElement.body : I.domElement;
				r(2 * Math.PI * q.x / e.clientWidth * I.rotateSpeed),
					a(2 * Math.PI * q.y / e.clientHeight * I.rotateSpeed),
					W.copy(Y),
					I.update()
			}

			function w(t) {
				var e = t.touches[0].pageX - t.touches[1].pageX,
					n = t.touches[0].pageY - t.touches[1].pageY,
					r = Math.sqrt(e * e + n * n);
				$.set(0, r),
					tt.subVectors($, K),
					tt.y > 0 ? l(i()) : tt.y < 0 && s(i()),
					K.copy($),
					I.update()
			}

			function T(t) {
				Q.set(t.touches[0].pageX, t.touches[0].pageY),
					J.subVectors(Q, Z),
					it(J.x, J.y),
					Z.copy(Q),
					I.update()
			}

			function M(t) {}

			function E(t) {
				if(I.enabled !== !1) {
					switch(t.preventDefault(),
						t.button) {
						case I.mouseButtons.ORBIT:
							if(I.enableRotate === !1)
								return;
							c(t),
								N = z.ROTATE;
							break;
						case I.mouseButtons.ZOOM:
							if(I.enableZoom === !1)
								return;
							u(t),
								N = z.DOLLY;
							break;
						case I.mouseButtons.PAN:
							if(I.enablePan === !1)
								return;
							h(t),
								N = z.PAN
					}
					N !== z.NONE && (document.addEventListener("mousemove", S, !1),
						document.addEventListener("mouseup", X, !1),
						I.dispatchEvent(B))
				}
			}

			function S(t) {
				if(I.enabled !== !1)
					switch(t.preventDefault(),
						N) {
						case z.ROTATE:
							if(I.enableRotate === !1)
								return;
							d(t);
							break;
						case z.DOLLY:
							if(I.enableZoom === !1)
								return;
							f(t);
							break;
						case z.PAN:
							if(I.enablePan === !1)
								return;
							p(t)
					}
			}

			function X(t) {
				I.enabled !== !1 && (m(t),
					document.removeEventListener("mousemove", S, !1),
					document.removeEventListener("mouseup", X, !1),
					I.dispatchEvent(F),
					N = z.NONE)
			}

			function A(t) {
				I.enabled === !1 || I.enableZoom === !1 || N !== z.NONE && N !== z.ROTATE || (t.preventDefault(),
					t.stopPropagation(),
					v(t),
					I.dispatchEvent(B),
					I.dispatchEvent(F))
			}

			function P(t) {
				I.enabled !== !1 && I.enableKeys !== !1 && I.enablePan !== !1 && g(t)
			}

			function R(t) {
				if(I.enabled !== !1) {
					switch(t.touches.length) {
						case 1:
							if(I.enableRotate === !1)
								return;
							_(t),
								N = z.TOUCH_ROTATE;
							break;
						case 2:
							if(I.enableZoom === !1)
								return;
							y(t),
								N = z.TOUCH_DOLLY;
							break;
						case 3:
							if(I.enablePan === !1)
								return;
							b(t),
								N = z.TOUCH_PAN;
							break;
						default:
							N = z.NONE
					}
					N !== z.NONE && I.dispatchEvent(B)
				}
			}

			function O(t) {
				if(I.enabled !== !1)
					switch(t.preventDefault(),
						t.stopPropagation(),
						t.touches.length) {
						case 1:
							if(I.enableRotate === !1)
								return;
							if(N !== z.TOUCH_ROTATE)
								return;
							x(t);
							break;
						case 2:
							if(I.enableZoom === !1)
								return;
							if(N !== z.TOUCH_DOLLY)
								return;
							w(t);
							break;
						case 3:
							if(I.enablePan === !1)
								return;
							if(N !== z.TOUCH_PAN)
								return;
							T(t);
							break;
						default:
							N = z.NONE
					}
			}

			function C(t) {
				I.enabled !== !1 && (M(t),
					I.dispatchEvent(F),
					N = z.NONE)
			}

			function L(t) {
				t.preventDefault()
			}
			this.object = t,
				this.domElement = void 0 !== e ? e : document,
				this.enabled = !0,
				this.target = new o.Vector3,
				this.minDistance = 0,
				this.maxDistance = 1 / 0,
				this.minZoom = 0,
				this.maxZoom = 1 / 0,
				this.minPolarAngle = 0,
				this.maxPolarAngle = Math.PI,
				this.minAzimuthAngle = -(1 / 0),
				this.maxAzimuthAngle = 1 / 0,
				this.enableDamping = !1,
				this.dampingFactor = .25,
				this.enableZoom = !0,
				this.zoomSpeed = 1,
				this.enableRotate = !0,
				this.rotateSpeed = 1,
				this.enablePan = !0,
				this.keyPanSpeed = 7,
				this.autoRotate = !1,
				this.autoRotateSpeed = 2,
				this.enableKeys = !0,
				this.keys = {
					LEFT: 37,
					UP: 38,
					RIGHT: 39,
					BOTTOM: 40
				},
				this.mouseButtons = {
					ORBIT: o.MOUSE.LEFT,
					ZOOM: o.MOUSE.MIDDLE,
					PAN: o.MOUSE.RIGHT
				},
				this.target0 = this.target.clone(),
				this.position0 = this.object.position.clone(),
				this.zoom0 = this.object.zoom,
				this.getPolarAngle = function() {
					return U.phi
				},
				this.getAzimuthalAngle = function() {
					return U.theta
				},
				this.saveState = function() {
					I.target0.copy(I.target),
						I.position0.copy(I.object.position),
						I.zoom0 = I.object.zoom
				},
				this.reset = function() {
					I.target.copy(I.target0),
						I.object.position.copy(I.position0),
						I.object.zoom = I.zoom0,
						I.object.updateProjectionMatrix(),
						I.dispatchEvent(D),
						I.update(),
						N = z.NONE
				},
				this.update = function() {
					var e = new o.Vector3,
						i = (new o.Quaternion).setFromUnitVectors(t.up, new o.Vector3(0, 1, 0)),
						a = i.clone().inverse(),
						s = new o.Vector3,
						l = new o.Quaternion;
					return function() {
						var t = I.object.position;
						return e.copy(t).sub(I.target),
							e.applyQuaternion(i),
							U.setFromVector3(e),
							I.autoRotate && N === z.NONE && r(n()),
							U.theta += j.theta,
							U.phi += j.phi,
							U.theta = Math.max(I.minAzimuthAngle, Math.min(I.maxAzimuthAngle, U.theta)),
							U.phi = Math.max(I.minPolarAngle, Math.min(I.maxPolarAngle, U.phi)),
							U.makeSafe(),
							U.radius *= V,
							U.radius = Math.max(I.minDistance, Math.min(I.maxDistance, U.radius)),
							I.target.add(G),
							e.setFromSpherical(U),
							e.applyQuaternion(a),
							t.copy(I.target).add(e),
							I.object.lookAt(I.target),
							I.enableDamping === !0 ? (j.theta *= 1 - I.dampingFactor,
								j.phi *= 1 - I.dampingFactor) : j.set(0, 0, 0),
							V = 1,
							G.set(0, 0, 0), !!(H || s.distanceToSquared(I.object.position) > k || 8 * (1 - l.dot(I.object.quaternion)) > k) && (I.dispatchEvent(D),
								s.copy(I.object.position),
								l.copy(I.object.quaternion),
								H = !1, !0)
					}
				}(),
				this.dispose = function() {
					I.domElement.removeEventListener("contextmenu", L, !1),
						I.domElement.removeEventListener("mousedown", E, !1),
						I.domElement.removeEventListener("wheel", A, !1),
						I.domElement.removeEventListener("touchstart", R, !1),
						I.domElement.removeEventListener("touchend", C, !1),
						I.domElement.removeEventListener("touchmove", O, !1),
						document.removeEventListener("mousemove", S, !1),
						document.removeEventListener("mouseup", X, !1),
						window.removeEventListener("keydown", P, !1)
				};
			var I = this,
				D = {
					type: "change"
				},
				B = {
					type: "start"
				},
				F = {
					type: "end"
				},
				z = {
					NONE: -1,
					ROTATE: 0,
					DOLLY: 1,
					PAN: 2,
					TOUCH_ROTATE: 3,
					TOUCH_DOLLY: 4,
					TOUCH_PAN: 5
				},
				N = z.NONE,
				k = 1e-6,
				U = new o.Spherical,
				j = new o.Spherical,
				V = 1,
				G = new o.Vector3,
				H = !1,
				W = new o.Vector2,
				Y = new o.Vector2,
				q = new o.Vector2,
				Z = new o.Vector2,
				Q = new o.Vector2,
				J = new o.Vector2,
				K = new o.Vector2,
				$ = new o.Vector2,
				tt = new o.Vector2,
				et = function() {
					var t = new o.Vector3;
					return function(e, n) {
						t.setFromMatrixColumn(n, 0),
							t.multiplyScalar(-e),
							G.add(t)
					}
				}(),
				nt = function() {
					var t = new o.Vector3;
					return function(e, n) {
						t.setFromMatrixColumn(n, 1),
							t.multiplyScalar(e),
							G.add(t)
					}
				}(),
				it = function() {
					var t = new o.Vector3;
					return function(e, n) {
						var i = I.domElement === document ? I.domElement.body : I.domElement;
						if(I.object instanceof o.PerspectiveCamera) {
							var r = I.object.position;
							t.copy(r).sub(I.target);
							var a = t.length();
							a *= Math.tan(I.object.fov / 2 * Math.PI / 180),
								et(2 * e * a / i.clientHeight, I.object.matrix),
								nt(2 * n * a / i.clientHeight, I.object.matrix)
						} else
							I.object instanceof o.OrthographicCamera ? (et(e * (I.object.right - I.object.left) / I.object.zoom / i.clientWidth, I.object.matrix),
								nt(n * (I.object.top - I.object.bottom) / I.object.zoom / i.clientHeight, I.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
								I.enablePan = !1)
					}
				}();
			I.domElement.addEventListener("contextmenu", L, !1),
				I.domElement.addEventListener("mousedown", E, !1),
				I.domElement.addEventListener("wheel", A, !1),
				I.domElement.addEventListener("touchstart", R, !1),
				I.domElement.addEventListener("touchend", C, !1),
				I.domElement.addEventListener("touchmove", O, !1),
				window.addEventListener("keydown", P, !1),
				this.update()
		},
		o.OrbitControls.prototype = Object.create(o.EventDispatcher.prototype),
		o.OrbitControls.prototype.constructor = o.OrbitControls,
		Object.defineProperties(o.OrbitControls.prototype, {
			center: {
				get: function() {
					return console.warn("THREE.OrbitControls: .center has been renamed to .target"),
						this.target
				}
			},
			noZoom: {
				get: function() {
					return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), !this.enableZoom
				},
				set: function(t) {
					console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),
						this.enableZoom = !t
				}
			},
			noRotate: {
				get: function() {
					return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), !this.enableRotate
				},
				set: function(t) {
					console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),
						this.enableRotate = !t
				}
			},
			noPan: {
				get: function() {
					return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), !this.enablePan
				},
				set: function(t) {
					console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),
						this.enablePan = !t
				}
			},
			noKeys: {
				get: function() {
					return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), !this.enableKeys
				},
				set: function(t) {
					console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),
						this.enableKeys = !t
				}
			},
			staticMoving: {
				get: function() {
					return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), !this.enableDamping
				},
				set: function(t) {
					console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),
						this.enableDamping = !t
				}
			},
			dynamicDampingFactor: {
				get: function() {
					return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),
						this.dampingFactor
				},
				set: function(t) {
					console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),
						this.dampingFactor = t
				}
			}
		}),
		e.default = o.OrbitControls
}, function(t, e, n) {
	! function(e, n) {
		t.exports = n()
	}(this, function() {
		return function(t) {
			function e(i) {
				if(n[i])
					return n[i].exports;
				var r = n[i] = {
					exports: {},
					id: i,
					loaded: !1
				};
				return t[i].call(r.exports, r, r.exports, e),
					r.loaded = !0,
					r.exports
			}
			var n = {};
			return e.m = t,
				e.c = n,
				e.p = "",
				e(0)
		}([function(t, e, n) {
			"use strict";

			function i(t) {
				return t && t.__esModule ? t : {
					default: t
				}
			}

			function r(t) {
				var e = (new f.Vector3).set(0, 0, -1).applyQuaternion(t);
				return e.x = d._Math.radToDeg(Math.acos(e.x)),
					e.y = d._Math.radToDeg(Math.acos(e.y)),
					e.z = d._Math.radToDeg(Math.acos(e.z)),
					e
			}

			function o(t) {
				var e = {},
					n = (new f.Vector3).set(0, 0, -1).applyQuaternion(t);
				return e.x = d._Math.radToDeg(Math.acos(n.x)),
					n.z <= 0 && e.x >= 0 && e.x <= 90 ? e.x = 90 - e.x : n.z > 0 && e.x >= 0 && e.x <= 90 ? e.x = e.x + 90 : n.z <= 0 && e.x > 90 ? e.x = 90 - e.x : n.z > 0 && e.x > 90 && (e.x = e.x - 270),
					e.y = d._Math.radToDeg(Math.acos(n.y)),
					e.z = d._Math.radToDeg(Math.acos(n.z)),
					e
			}
			Object.defineProperty(e, "__esModule", {
					value: !0
				}),
				e.libOrientation = void 0;
			var a = n(1),
				s = i(a),
				l = n(2),
				c = i(l),
				u = n(21),
				h = n(22),
				d = n(49),
				f = n(48),
				p = function() {
					function t(e) {
						var n = this;
						(0,
							s.default)(this, t),
						this.config = e,
							this._euler = new u.Euler,
							this._isStable = !1,
							this.quaternion = new h.Quaternion,
							this.directionHistory = [],
							this._q1 = new h.Quaternion(-Math.sqrt(.5), 0, 0, Math.sqrt(.5)),
							window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent.bind(this), !1),
							setTimeout(function() {
								n._isStable = !0
							}, 300)
					}
					return(0,
							c.default)(t, [{
							key: "onDeviceOrientationChangeEvent",
							value: function(t) {
								var e = this.config.angles.alpha ? d._Math.degToRad(this.config.angles.alpha) : d._Math.degToRad(t.alpha),
									n = this.config.angles.beta ? d._Math.degToRad(this.config.angles.beta) : d._Math.degToRad(t.beta),
									i = this.config.angles.gamma ? d._Math.degToRad(this.config.angles.gamma) : d._Math.degToRad(t.gamma);
								if(this._euler.set(n, e, -i, "YXZ"), !this.quaternion && this._isStable)
									this.quaternion.setFromEuler(this._euler),
									this.quaternion.multiply(this._q1),
									this.directionHistory.push((new h.Quaternion).copy(this.quaternion));
								else {
									var r = (new h.Quaternion).copy(this.quaternion),
										o = (new h.Quaternion).setFromEuler(this._euler);
									if(o.multiply(this._q1),
										Math.abs(o.y - r.y) > .15 && (this.directionHistory.push(h.Quaternion.slerp(r, o, new h.Quaternion, .3)),
											this.directionHistory.push(h.Quaternion.slerp(r, o, new h.Quaternion, .6))),
										Math.abs(this.quaternion.y - o.y) >= 1e-5 && this.directionHistory.push(o),
										this.quaternion = o,
										this.directionHistory.length > 10) {
										var a = this.directionHistory.length;
										this.directionHistory = this.directionHistory.slice(a - 10, a)
									}
								}
							}
						}, {
							key: "getDirectionHistory",
							value: function() {
								return this.directionHistory
							}
						}]),
						t
				}();
			e.libOrientation = {
				DeviceOrientationControls: p,
				formatDirectionByDegNorm: o,
				formatDirectionByDeg: r,
				Euler: u.Euler,
				Quaternion: h.Quaternion,
				Math: d._Math
			}
		}, function(t, e) {
			"use strict";
			e.__esModule = !0,
				e.default = function(t, e) {
					if(!(t instanceof e))
						throw new TypeError("Cannot call a class as a function")
				}
		}, function(t, e, n) {
			"use strict";

			function i(t) {
				return t && t.__esModule ? t : {
					default: t
				}
			}
			e.__esModule = !0;
			var r = n(3),
				o = i(r);
			e.default = function() {
				function t(t, e) {
					for(var n = 0; n < e.length; n++) {
						var i = e[n];
						i.enumerable = i.enumerable || !1,
							i.configurable = !0,
							"value" in i && (i.writable = !0),
							(0,
								o.default)(t, i.key, i)
					}
				}
				return function(e, n, i) {
					return n && t(e.prototype, n),
						i && t(e, i),
						e
				}
			}()
		}, function(t, e, n) {
			t.exports = {
				default: n(4),
				__esModule: !0
			}
		}, function(t, e, n) {
			n(5);
			var i = n(8).Object;
			t.exports = function(t, e, n) {
				return i.defineProperty(t, e, n)
			}
		}, function(t, e, n) {
			var i = n(6);
			i(i.S + i.F * !n(16), "Object", {
				defineProperty: n(12).f
			})
		}, function(t, e, n) {
			var i = n(7),
				r = n(8),
				o = n(9),
				a = n(11),
				s = "prototype",
				l = function(t, e, n) {
					var c, u, h, d = t & l.F,
						f = t & l.G,
						p = t & l.S,
						m = t & l.P,
						v = t & l.B,
						g = t & l.W,
						_ = f ? r : r[e] || (r[e] = {}),
						y = _[s],
						b = f ? i : p ? i[e] : (i[e] || {})[s];
					f && (n = e);
					for(c in n)
						u = !d && b && void 0 !== b[c],
						u && c in _ || (h = u ? b[c] : n[c],
							_[c] = f && "function" != typeof b[c] ? n[c] : v && u ? o(h, i) : g && b[c] == h ? function(t) {
								var e = function(e, n, i) {
									if(this instanceof t) {
										switch(arguments.length) {
											case 0:
												return new t;
											case 1:
												return new t(e);
											case 2:
												return new t(e, n)
										}
										return new t(e, n, i)
									}
									return t.apply(this, arguments)
								};
								return e[s] = t[s],
									e
							}(h) : m && "function" == typeof h ? o(Function.call, h) : h,
							m && ((_.virtual || (_.virtual = {}))[c] = h,
								t & l.R && y && !y[c] && a(y, c, h)))
				};
			l.F = 1,
				l.G = 2,
				l.S = 4,
				l.P = 8,
				l.B = 16,
				l.W = 32,
				l.U = 64,
				l.R = 128,
				t.exports = l
		}, function(t, e) {
			var n = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
			"number" == typeof __g && (__g = n)
		}, function(t, e) {
			var n = t.exports = {
				version: "2.4.0"
			};
			"number" == typeof __e && (__e = n)
		}, function(t, e, n) {
			var i = n(10);
			t.exports = function(t, e, n) {
				if(i(t),
					void 0 === e)
					return t;
				switch(n) {
					case 1:
						return function(n) {
							return t.call(e, n)
						};
					case 2:
						return function(n, i) {
							return t.call(e, n, i)
						};
					case 3:
						return function(n, i, r) {
							return t.call(e, n, i, r)
						}
				}
				return function() {
					return t.apply(e, arguments)
				}
			}
		}, function(t, e) {
			t.exports = function(t) {
				if("function" != typeof t)
					throw TypeError(t + " is not a function!");
				return t
			}
		}, function(t, e, n) {
			var i = n(12),
				r = n(20);
			t.exports = n(16) ? function(t, e, n) {
					return i.f(t, e, r(1, n))
				} :
				function(t, e, n) {
					return t[e] = n,
						t
				}
		}, function(t, e, n) {
			var i = n(13),
				r = n(15),
				o = n(19),
				a = Object.defineProperty;
			e.f = n(16) ? Object.defineProperty : function(t, e, n) {
				if(i(t),
					e = o(e, !0),
					i(n),
					r)
					try {
						return a(t, e, n)
					} catch(t) {}
				if("get" in n || "set" in n)
					throw TypeError("Accessors not supported!");
				return "value" in n && (t[e] = n.value),
					t
			}
		}, function(t, e, n) {
			var i = n(14);
			t.exports = function(t) {
				if(!i(t))
					throw TypeError(t + " is not an object!");
				return t
			}
		}, function(t, e) {
			t.exports = function(t) {
				return "object" == typeof t ? null !== t : "function" == typeof t
			}
		}, function(t, e, n) {
			t.exports = !n(16) && !n(17)(function() {
				return 7 != Object.defineProperty(n(18)("div"), "a", {
					get: function() {
						return 7
					}
				}).a
			})
		}, function(t, e, n) {
			t.exports = !n(17)(function() {
				return 7 != Object.defineProperty({}, "a", {
					get: function() {
						return 7
					}
				}).a
			})
		}, function(t, e) {
			t.exports = function(t) {
				try {
					return !!t()
				} catch(t) {
					return !0
				}
			}
		}, function(t, e, n) {
			var i = n(14),
				r = n(7).document,
				o = i(r) && i(r.createElement);
			t.exports = function(t) {
				return o ? r.createElement(t) : {}
			}
		}, function(t, e, n) {
			var i = n(14);
			t.exports = function(t, e) {
				if(!i(t))
					return t;
				var n, r;
				if(e && "function" == typeof(n = t.toString) && !i(r = n.call(t)))
					return r;
				if("function" == typeof(n = t.valueOf) && !i(r = n.call(t)))
					return r;
				if(!e && "function" == typeof(n = t.toString) && !i(r = n.call(t)))
					return r;
				throw TypeError("Can't convert object to primitive value")
			}
		}, function(t, e) {
			t.exports = function(t, e) {
				return {
					enumerable: !(1 & t),
					configurable: !(2 & t),
					writable: !(4 & t),
					value: e
				}
			}
		}, function(t, e, n) {
			"use strict";

			function i(t, e, n, r) {
				this._x = t || 0,
					this._y = e || 0,
					this._z = n || 0,
					this._order = r || i.DefaultOrder
			}
			Object.defineProperty(e, "__esModule", {
					value: !0
				}),
				e.Euler = void 0;
			var r = n(22),
				o = n(48),
				a = n(50),
				s = n(49);
			i.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"],
				i.DefaultOrder = "XYZ",
				i.prototype = {
					constructor: i,
					isEuler: !0,
					get x() {
						return this._x
					},
					set x(t) {
						this._x = t,
							this.onChangeCallback()
					},
					get y() {
						return this._y
					},
					set y(t) {
						this._y = t,
							this.onChangeCallback()
					},
					get z() {
						return this._z
					},
					set z(t) {
						this._z = t,
							this.onChangeCallback()
					},
					get order() {
						return this._order
					},
					set order(t) {
						this._order = t,
							this.onChangeCallback()
					},
					set: function(t, e, n, i) {
						return this._x = t,
							this._y = e,
							this._z = n,
							this._order = i || this._order,
							this.onChangeCallback(),
							this
					},
					clone: function() {
						return new this.constructor(this._x, this._y, this._z, this._order)
					},
					copy: function(t) {
						return this._x = t._x,
							this._y = t._y,
							this._z = t._z,
							this._order = t._order,
							this.onChangeCallback(),
							this
					},
					setFromRotationMatrix: function(t, e, n) {
						var i = s._Math.clamp,
							r = t.elements,
							o = r[0],
							a = r[4],
							l = r[8],
							c = r[1],
							u = r[5],
							h = r[9],
							d = r[2],
							f = r[6],
							p = r[10];
						return e = e || this._order,
							"XYZ" === e ? (this._y = Math.asin(i(l, -1, 1)),
								Math.abs(l) < .99999 ? (this._x = Math.atan2(-h, p),
									this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(f, u),
									this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-i(h, -1, 1)),
								Math.abs(h) < .99999 ? (this._y = Math.atan2(l, p),
									this._z = Math.atan2(c, u)) : (this._y = Math.atan2(-d, o),
									this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(i(f, -1, 1)),
								Math.abs(f) < .99999 ? (this._y = Math.atan2(-d, p),
									this._z = Math.atan2(-a, u)) : (this._y = 0,
									this._z = Math.atan2(c, o))) : "ZYX" === e ? (this._y = Math.asin(-i(d, -1, 1)),
								Math.abs(d) < .99999 ? (this._x = Math.atan2(f, p),
									this._z = Math.atan2(c, o)) : (this._x = 0,
									this._z = Math.atan2(-a, u))) : "YZX" === e ? (this._z = Math.asin(i(c, -1, 1)),
								Math.abs(c) < .99999 ? (this._x = Math.atan2(-h, u),
									this._y = Math.atan2(-d, o)) : (this._x = 0,
									this._y = Math.atan2(l, p))) : "XZY" === e ? (this._z = Math.asin(-i(a, -1, 1)),
								Math.abs(a) < .99999 ? (this._x = Math.atan2(f, u),
									this._y = Math.atan2(l, o)) : (this._x = Math.atan2(-h, p),
									this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e),
							this._order = e,
							n !== !1 && this.onChangeCallback(),
							this
					},
					setFromQuaternion: function() {
						var t;
						return function(e, n, i) {
							return void 0 === t && (t = new a.Matrix4),
								t.makeRotationFromQuaternion(e),
								this.setFromRotationMatrix(t, n, i)
						}
					}(),
					setFromVector3: function(t, e) {
						return this.set(t.x, t.y, t.z, e || this._order)
					},
					reorder: function() {
						var t = new r.Quaternion;
						return function(e) {
							return t.setFromEuler(this),
								this.setFromQuaternion(t, e)
						}
					}(),
					equals: function(t) {
						return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
					},
					fromArray: function(t) {
						return this._x = t[0],
							this._y = t[1],
							this._z = t[2],
							void 0 !== t[3] && (this._order = t[3]),
							this.onChangeCallback(),
							this
					},
					toArray: function(t, e) {
						return void 0 === t && (t = []),
							void 0 === e && (e = 0),
							t[e] = this._x,
							t[e + 1] = this._y,
							t[e + 2] = this._z,
							t[e + 3] = this._order,
							t
					},
					toVector3: function(t) {
						return t ? t.set(this._x, this._y, this._z) : new o.Vector3(this._x, this._y, this._z)
					},
					onChange: function(t) {
						return this.onChangeCallback = t,
							this
					},
					onChangeCallback: function() {}
				},
				e.Euler = i
		}, function(t, e, n) {
			"use strict";

			function i(t) {
				return t && t.__esModule ? t : {
					default: t
				}
			}

			function r(t, e, n, i) {
				this._x = t || 0,
					this._y = e || 0,
					this._z = n || 0,
					this._w = void 0 !== i ? i : 1
			}
			Object.defineProperty(e, "__esModule", {
					value: !0
				}),
				e.Quaternion = void 0;
			var o = n(23),
				a = i(o),
				s = n(26),
				l = i(s),
				c = n(48);
			r.prototype = {
					constructor: r,
					get x() {
						return this._x
					},
					set x(t) {
						this._x = t,
							this.onChangeCallback()
					},
					get y() {
						return this._y
					},
					set y(t) {
						this._y = t,
							this.onChangeCallback()
					},
					get z() {
						return this._z
					},
					set z(t) {
						this._z = t,
							this.onChangeCallback()
					},
					get w() {
						return this._w
					},
					set w(t) {
						this._w = t,
							this.onChangeCallback()
					},
					set: function(t, e, n, i) {
						return this._x = t,
							this._y = e,
							this._z = n,
							this._w = i,
							this.onChangeCallback(),
							this
					},
					clone: function() {
						return new this.constructor(this._x, this._y, this._z, this._w)
					},
					copy: function(t) {
						return this._x = t.x,
							this._y = t.y,
							this._z = t.z,
							this._w = t.w,
							this.onChangeCallback(),
							this
					},
					setFromEuler: function(t, e) {
						if((t && t.isEuler) === !1)
							throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
						var n = Math.cos(t._x / 2),
							i = Math.cos(t._y / 2),
							r = Math.cos(t._z / 2),
							o = Math.sin(t._x / 2),
							a = Math.sin(t._y / 2),
							s = Math.sin(t._z / 2),
							l = t.order;
						return "XYZ" === l ? (this._x = o * i * r + n * a * s,
								this._y = n * a * r - o * i * s,
								this._z = n * i * s + o * a * r,
								this._w = n * i * r - o * a * s) : "YXZ" === l ? (this._x = o * i * r + n * a * s,
								this._y = n * a * r - o * i * s,
								this._z = n * i * s - o * a * r,
								this._w = n * i * r + o * a * s) : "ZXY" === l ? (this._x = o * i * r - n * a * s,
								this._y = n * a * r + o * i * s,
								this._z = n * i * s + o * a * r,
								this._w = n * i * r - o * a * s) : "ZYX" === l ? (this._x = o * i * r - n * a * s,
								this._y = n * a * r + o * i * s,
								this._z = n * i * s - o * a * r,
								this._w = n * i * r + o * a * s) : "YZX" === l ? (this._x = o * i * r + n * a * s,
								this._y = n * a * r + o * i * s,
								this._z = n * i * s - o * a * r,
								this._w = n * i * r - o * a * s) : "XZY" === l && (this._x = o * i * r - n * a * s,
								this._y = n * a * r - o * i * s,
								this._z = n * i * s + o * a * r,
								this._w = n * i * r + o * a * s),
							e !== !1 && this.onChangeCallback(),
							this
					},
					setFromAxisAngle: function(t, e) {
						var n = e / 2,
							i = Math.sin(n);
						return this._x = t.x * i,
							this._y = t.y * i,
							this._z = t.z * i,
							this._w = Math.cos(n),
							this.onChangeCallback(),
							this
					},
					setFromRotationMatrix: function(t) {
						var e, n = t.elements,
							i = n[0],
							r = n[4],
							o = n[8],
							a = n[1],
							s = n[5],
							l = n[9],
							c = n[2],
							u = n[6],
							h = n[10],
							d = i + s + h;
						return d > 0 ? (e = .5 / Math.sqrt(d + 1),
								this._w = .25 / e,
								this._x = (u - l) * e,
								this._y = (o - c) * e,
								this._z = (a - r) * e) : i > s && i > h ? (e = 2 * Math.sqrt(1 + i - s - h),
								this._w = (u - l) / e,
								this._x = .25 * e,
								this._y = (r + a) / e,
								this._z = (o + c) / e) : s > h ? (e = 2 * Math.sqrt(1 + s - i - h),
								this._w = (o - c) / e,
								this._x = (r + a) / e,
								this._y = .25 * e,
								this._z = (l + u) / e) : (e = 2 * Math.sqrt(1 + h - i - s),
								this._w = (a - r) / e,
								this._x = (o + c) / e,
								this._y = (l + u) / e,
								this._z = .25 * e),
							this.onChangeCallback(),
							this
					},
					setFromUnitVectors: function() {
						var t, e, n = 1e-6;
						return function(i, r) {
							return void 0 === t && (t = new c.Vector3),
								e = i.dot(r) + 1,
								e < n ? (e = 0,
									Math.abs(i.x) > Math.abs(i.z) ? t.set(-i.y, i.x, 0) : t.set(0, -i.z, i.y)) : t.crossVectors(i, r),
								this._x = t.x,
								this._y = t.y,
								this._z = t.z,
								this._w = e,
								this.normalize()
						}
					}(),
					inverse: function() {
						return this.conjugate().normalize()
					},
					conjugate: function() {
						return this._x *= -1,
							this._y *= -1,
							this._z *= -1,
							this.onChangeCallback(),
							this
					},
					dot: function(t) {
						return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
					},
					lengthSq: function() {
						return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
					},
					length: function() {
						return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
					},
					normalize: function() {
						var t = this.length();
						return 0 === t ? (this._x = 0,
								this._y = 0,
								this._z = 0,
								this._w = 1) : (t = 1 / t,
								this._x = this._x * t,
								this._y = this._y * t,
								this._z = this._z * t,
								this._w = this._w * t),
							this.onChangeCallback(),
							this
					},
					multiply: function(t, e) {
						return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
							this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
					},
					premultiply: function(t) {
						return this.multiplyQuaternions(t, this)
					},
					multiplyQuaternions: function(t, e) {
						var n = t._x,
							i = t._y,
							r = t._z,
							o = t._w,
							a = e._x,
							s = e._y,
							l = e._z,
							c = e._w;
						return this._x = n * c + o * a + i * l - r * s,
							this._y = i * c + o * s + r * a - n * l,
							this._z = r * c + o * l + n * s - i * a,
							this._w = o * c - n * a - i * s - r * l,
							this.onChangeCallback(),
							this
					},
					slerp: function(t, e) {
						if(0 === e)
							return this;
						if(1 === e)
							return this.copy(t);
						var n = this._x,
							i = this._y,
							r = this._z,
							o = this._w,
							a = o * t._w + n * t._x + i * t._y + r * t._z;
						if(a < 0 ? (this._w = -t._w,
								this._x = -t._x,
								this._y = -t._y,
								this._z = -t._z,
								a = -a) : this.copy(t),
							a >= 1)
							return this._w = o,
								this._x = n,
								this._y = i,
								this._z = r,
								this;
						var s = Math.sqrt(1 - a * a);
						if(Math.abs(s) < .001)
							return this._w = .5 * (o + this._w),
								this._x = .5 * (n + this._x),
								this._y = .5 * (i + this._y),
								this._z = .5 * (r + this._z),
								this;
						var l = Math.atan2(s, a),
							c = Math.sin((1 - e) * l) / s,
							u = Math.sin(e * l) / s;
						return this._w = o * c + this._w * u,
							this._x = n * c + this._x * u,
							this._y = i * c + this._y * u,
							this._z = r * c + this._z * u,
							this.onChangeCallback(),
							this
					},
					equals: function(t) {
						return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
					},
					fromArray: function(t, e) {
						return void 0 === e && (e = 0),
							this._x = t[e],
							this._y = t[e + 1],
							this._z = t[e + 2],
							this._w = t[e + 3],
							this.onChangeCallback(),
							this
					},
					toArray: function(t, e) {
						return void 0 === t && (t = []),
							void 0 === e && (e = 0),
							t[e] = this._x,
							t[e + 1] = this._y,
							t[e + 2] = this._z,
							t[e + 3] = this._w,
							t
					},
					onChange: function(t) {
						return this.onChangeCallback = t,
							this
					},
					onChangeCallback: function() {}
				},
				(0,
					l.default)(r, {
					slerp: function(t, e, n, i) {
						return n.copy(t).slerp(e, i)
					},
					slerpFlat: function(t, e, n, i, r, o, s) {
						var l = n[i + 0],
							c = n[i + 1],
							u = n[i + 2],
							h = n[i + 3],
							d = r[o + 0],
							f = r[o + 1],
							p = r[o + 2],
							m = r[o + 3];
						if(h !== m || l !== d || c !== f || u !== p) {
							var v = 1 - s,
								g = l * d + c * f + u * p + h * m,
								_ = g >= 0 ? 1 : -1,
								y = 1 - g * g;
							if(y > a.default) {
								var b = Math.sqrt(y),
									x = Math.atan2(b, g * _);
								v = Math.sin(v * x) / b,
									s = Math.sin(s * x) / b
							}
							var w = s * _;
							if(l = l * v + d * w,
								c = c * v + f * w,
								u = u * v + p * w,
								h = h * v + m * w,
								v === 1 - s) {
								var T = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
								l *= T,
									c *= T,
									u *= T,
									h *= T
							}
						}
						t[e] = l,
							t[e + 1] = c,
							t[e + 2] = u,
							t[e + 3] = h
					}
				}),
				e.Quaternion = r
		}, function(t, e, n) {
			t.exports = {
				default: n(24),
				__esModule: !0
			}
		}, function(t, e, n) {
			n(25),
				t.exports = Math.pow(2, -52)
		}, function(t, e, n) {
			var i = n(6);
			i(i.S, "Number", {
				EPSILON: Math.pow(2, -52)
			})
		}, function(t, e, n) {
			t.exports = {
				default: n(27),
				__esModule: !0
			}
		}, function(t, e, n) {
			n(28),
				t.exports = n(8).Object.assign
		}, function(t, e, n) {
			var i = n(6);
			i(i.S + i.F, "Object", {
				assign: n(29)
			})
		}, function(t, e, n) {
			"use strict";
			var i = n(30),
				r = n(45),
				o = n(46),
				a = n(47),
				s = n(34),
				l = Object.assign;
			t.exports = !l || n(17)(function() {
					var t = {},
						e = {},
						n = Symbol(),
						i = "abcdefghijklmnopqrst";
					return t[n] = 7,
						i.split("").forEach(function(t) {
							e[t] = t
						}),
						7 != l({}, t)[n] || Object.keys(l({}, e)).join("") != i
				}) ? function(t, e) {
					for(var n = a(t), l = arguments.length, c = 1, u = r.f, h = o.f; l > c;)
						for(var d, f = s(arguments[c++]), p = u ? i(f).concat(u(f)) : i(f), m = p.length, v = 0; m > v;)
							h.call(f, d = p[v++]) && (n[d] = f[d]);
					return n
				} :
				l
		}, function(t, e, n) {
			var i = n(31),
				r = n(44);
			t.exports = Object.keys || function(t) {
				return i(t, r)
			}
		}, function(t, e, n) {
			var i = n(32),
				r = n(33),
				o = n(37)(!1),
				a = n(41)("IE_PROTO");
			t.exports = function(t, e) {
				var n, s = r(t),
					l = 0,
					c = [];
				for(n in s)
					n != a && i(s, n) && c.push(n);
				for(; e.length > l;)
					i(s, n = e[l++]) && (~o(c, n) || c.push(n));
				return c
			}
		}, function(t, e) {
			var n = {}.hasOwnProperty;
			t.exports = function(t, e) {
				return n.call(t, e)
			}
		}, function(t, e, n) {
			var i = n(34),
				r = n(36);
			t.exports = function(t) {
				return i(r(t))
			}
		}, function(t, e, n) {
			var i = n(35);
			t.exports = Object("z").propertyIsEnumerable(0) ? Object : function(t) {
				return "String" == i(t) ? t.split("") : Object(t)
			}
		}, function(t, e) {
			var n = {}.toString;
			t.exports = function(t) {
				return n.call(t).slice(8, -1)
			}
		}, function(t, e) {
			t.exports = function(t) {
				if(void 0 == t)
					throw TypeError("Can't call method on  " + t);
				return t
			}
		}, function(t, e, n) {
			var i = n(33),
				r = n(38),
				o = n(40);
			t.exports = function(t) {
				return function(e, n, a) {
					var s, l = i(e),
						c = r(l.length),
						u = o(a, c);
					if(t && n != n) {
						for(; c > u;)
							if(s = l[u++],
								s != s)
								return !0
					} else
						for(; c > u; u++)
							if((t || u in l) && l[u] === n)
								return t || u || 0;
					return !t && -1
				}
			}
		}, function(t, e, n) {
			var i = n(39),
				r = Math.min;
			t.exports = function(t) {
				return t > 0 ? r(i(t), 9007199254740991) : 0
			}
		}, function(t, e) {
			var n = Math.ceil,
				i = Math.floor;
			t.exports = function(t) {
				return isNaN(t = +t) ? 0 : (t > 0 ? i : n)(t)
			}
		}, function(t, e, n) {
			var i = n(39),
				r = Math.max,
				o = Math.min;
			t.exports = function(t, e) {
				return t = i(t),
					t < 0 ? r(t + e, 0) : o(t, e)
			}
		}, function(t, e, n) {
			var i = n(42)("keys"),
				r = n(43);
			t.exports = function(t) {
				return i[t] || (i[t] = r(t))
			}
		}, function(t, e, n) {
			var i = n(7),
				r = "__core-js_shared__",
				o = i[r] || (i[r] = {});
			t.exports = function(t) {
				return o[t] || (o[t] = {})
			}
		}, function(t, e) {
			var n = 0,
				i = Math.random();
			t.exports = function(t) {
				return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++n + i).toString(36))
			}
		}, function(t, e) {
			t.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
		}, function(t, e) {
			e.f = Object.getOwnPropertySymbols
		}, function(t, e) {
			e.f = {}.propertyIsEnumerable
		}, function(t, e, n) {
			var i = n(36);
			t.exports = function(t) {
				return Object(i(t))
			}
		}, function(t, e, n) {
			"use strict";

			function i(t, e, n) {
				this.x = t || 0,
					this.y = e || 0,
					this.z = n || 0
			}
			Object.defineProperty(e, "__esModule", {
					value: !0
				}),
				e.Vector3 = void 0;
			var r = n(49),
				o = n(50),
				a = n(22);
			i.prototype = {
					constructor: i,
					isVector3: !0,
					set: function(t, e, n) {
						return this.x = t,
							this.y = e,
							this.z = n,
							this
					},
					setScalar: function(t) {
						return this.x = t,
							this.y = t,
							this.z = t,
							this
					},
					setX: function(t) {
						return this.x = t,
							this
					},
					setY: function(t) {
						return this.y = t,
							this
					},
					setZ: function(t) {
						return this.z = t,
							this
					},
					setComponent: function(t, e) {
						switch(t) {
							case 0:
								this.x = e;
								break;
							case 1:
								this.y = e;
								break;
							case 2:
								this.z = e;
								break;
							default:
								throw new Error("index is out of range: " + t)
						}
						return this
					},
					getComponent: function(t) {
						switch(t) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							case 2:
								return this.z;
							default:
								throw new Error("index is out of range: " + t)
						}
					},
					clone: function() {
						return new this.constructor(this.x, this.y, this.z)
					},
					copy: function(t) {
						return this.x = t.x,
							this.y = t.y,
							this.z = t.z,
							this
					},
					add: function(t, e) {
						return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
							this.addVectors(t, e)) : (this.x += t.x,
							this.y += t.y,
							this.z += t.z,
							this)
					},
					addScalar: function(t) {
						return this.x += t,
							this.y += t,
							this.z += t,
							this
					},
					addVectors: function(t, e) {
						return this.x = t.x + e.x,
							this.y = t.y + e.y,
							this.z = t.z + e.z,
							this
					},
					addScaledVector: function(t, e) {
						return this.x += t.x * e,
							this.y += t.y * e,
							this.z += t.z * e,
							this
					},
					sub: function(t, e) {
						return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
							this.subVectors(t, e)) : (this.x -= t.x,
							this.y -= t.y,
							this.z -= t.z,
							this)
					},
					subScalar: function(t) {
						return this.x -= t,
							this.y -= t,
							this.z -= t,
							this
					},
					subVectors: function(t, e) {
						return this.x = t.x - e.x,
							this.y = t.y - e.y,
							this.z = t.z - e.z,
							this
					},
					multiply: function(t, e) {
						return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
							this.multiplyVectors(t, e)) : (this.x *= t.x,
							this.y *= t.y,
							this.z *= t.z,
							this)
					},
					multiplyScalar: function(t) {
						return isFinite(t) ? (this.x *= t,
								this.y *= t,
								this.z *= t) : (this.x = 0,
								this.y = 0,
								this.z = 0),
							this
					},
					multiplyVectors: function(t, e) {
						return this.x = t.x * e.x,
							this.y = t.y * e.y,
							this.z = t.z * e.z,
							this
					},
					applyEuler: function() {
						var t;
						return function(e) {
							return(e && e.isEuler) === !1 && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
								void 0 === t && (t = new a.Quaternion),
								this.applyQuaternion(t.setFromEuler(e))
						}
					}(),
					applyAxisAngle: function() {
						var t;
						return function(e, n) {
							return void 0 === t && (t = new a.Quaternion),
								this.applyQuaternion(t.setFromAxisAngle(e, n))
						}
					}(),
					applyMatrix3: function(t) {
						var e = this.x,
							n = this.y,
							i = this.z,
							r = t.elements;
						return this.x = r[0] * e + r[3] * n + r[6] * i,
							this.y = r[1] * e + r[4] * n + r[7] * i,
							this.z = r[2] * e + r[5] * n + r[8] * i,
							this
					},
					applyMatrix4: function(t) {
						var e = this.x,
							n = this.y,
							i = this.z,
							r = t.elements;
						return this.x = r[0] * e + r[4] * n + r[8] * i + r[12],
							this.y = r[1] * e + r[5] * n + r[9] * i + r[13],
							this.z = r[2] * e + r[6] * n + r[10] * i + r[14],
							this
					},
					applyProjection: function(t) {
						var e = this.x,
							n = this.y,
							i = this.z,
							r = t.elements,
							o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
						return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o,
							this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o,
							this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o,
							this
					},
					applyQuaternion: function(t) {
						var e = this.x,
							n = this.y,
							i = this.z,
							r = t.x,
							o = t.y,
							a = t.z,
							s = t.w,
							l = s * e + o * i - a * n,
							c = s * n + a * e - r * i,
							u = s * i + r * n - o * e,
							h = -r * e - o * n - a * i;
						return this.x = l * s + h * -r + c * -a - u * -o,
							this.y = c * s + h * -o + u * -r - l * -a,
							this.z = u * s + h * -a + l * -o - c * -r,
							this
					},
					project: function() {
						var t;
						return function(e) {
							return void 0 === t && (t = new o.Matrix4),
								t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)),
								this.applyProjection(t)
						}
					}(),
					unproject: function() {
						var t;
						return function(e) {
							return void 0 === t && (t = new o.Matrix4),
								t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)),
								this.applyProjection(t)
						}
					}(),
					transformDirection: function(t) {
						var e = this.x,
							n = this.y,
							i = this.z,
							r = t.elements;
						return this.x = r[0] * e + r[4] * n + r[8] * i,
							this.y = r[1] * e + r[5] * n + r[9] * i,
							this.z = r[2] * e + r[6] * n + r[10] * i,
							this.normalize()
					},
					divide: function(t) {
						return this.x /= t.x,
							this.y /= t.y,
							this.z /= t.z,
							this
					},
					divideScalar: function(t) {
						return this.multiplyScalar(1 / t)
					},
					min: function(t) {
						return this.x = Math.min(this.x, t.x),
							this.y = Math.min(this.y, t.y),
							this.z = Math.min(this.z, t.z),
							this
					},
					max: function(t) {
						return this.x = Math.max(this.x, t.x),
							this.y = Math.max(this.y, t.y),
							this.z = Math.max(this.z, t.z),
							this
					},
					clamp: function(t, e) {
						return this.x = Math.max(t.x, Math.min(e.x, this.x)),
							this.y = Math.max(t.y, Math.min(e.y, this.y)),
							this.z = Math.max(t.z, Math.min(e.z, this.z)),
							this
					},
					clampScalar: function() {
						var t, e;
						return function(n, r) {
							return void 0 === t && (t = new i,
									e = new i),
								t.set(n, n, n),
								e.set(r, r, r),
								this.clamp(t, e)
						}
					}(),
					clampLength: function(t, e) {
						var n = this.length();
						return this.multiplyScalar(Math.max(t, Math.min(e, n)) / n)
					},
					floor: function() {
						return this.x = Math.floor(this.x),
							this.y = Math.floor(this.y),
							this.z = Math.floor(this.z),
							this
					},
					ceil: function() {
						return this.x = Math.ceil(this.x),
							this.y = Math.ceil(this.y),
							this.z = Math.ceil(this.z),
							this
					},
					round: function() {
						return this.x = Math.round(this.x),
							this.y = Math.round(this.y),
							this.z = Math.round(this.z),
							this
					},
					roundToZero: function() {
						return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
							this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
							this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
							this
					},
					negate: function() {
						return this.x = -this.x,
							this.y = -this.y,
							this.z = -this.z,
							this
					},
					dot: function(t) {
						return this.x * t.x + this.y * t.y + this.z * t.z
					},
					lengthSq: function() {
						return this.x * this.x + this.y * this.y + this.z * this.z
					},
					length: function() {
						return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
					},
					lengthManhattan: function() {
						return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
					},
					normalize: function() {
						return this.divideScalar(this.length())
					},
					setLength: function(t) {
						return this.multiplyScalar(t / this.length())
					},
					lerp: function(t, e) {
						return this.x += (t.x - this.x) * e,
							this.y += (t.y - this.y) * e,
							this.z += (t.z - this.z) * e,
							this
					},
					lerpVectors: function(t, e, n) {
						return this.subVectors(e, t).multiplyScalar(n).add(t)
					},
					cross: function(t, e) {
						if(void 0 !== e)
							return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
								this.crossVectors(t, e);
						var n = this.x,
							i = this.y,
							r = this.z;
						return this.x = i * t.z - r * t.y,
							this.y = r * t.x - n * t.z,
							this.z = n * t.y - i * t.x,
							this
					},
					crossVectors: function(t, e) {
						var n = t.x,
							i = t.y,
							r = t.z,
							o = e.x,
							a = e.y,
							s = e.z;
						return this.x = i * s - r * a,
							this.y = r * o - n * s,
							this.z = n * a - i * o,
							this
					},
					projectOnVector: function(t) {
						var e = t.dot(this) / t.lengthSq();
						return this.copy(t).multiplyScalar(e)
					},
					projectOnPlane: function() {
						var t;
						return function(e) {
							return void 0 === t && (t = new i),
								t.copy(this).projectOnVector(e),
								this.sub(t)
						}
					}(),
					reflect: function() {
						var t;
						return function(e) {
							return void 0 === t && (t = new i),
								this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
						}
					}(),
					angleTo: function(t) {
						var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
						return Math.acos(r._Math.clamp(e, -1, 1))
					},
					distanceTo: function(t) {
						return Math.sqrt(this.distanceToSquared(t))
					},
					distanceToSquared: function(t) {
						var e = this.x - t.x,
							n = this.y - t.y,
							i = this.z - t.z;
						return e * e + n * n + i * i
					},
					distanceToManhattan: function(t) {
						return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
					},
					setFromSpherical: function(t) {
						var e = Math.sin(t.phi) * t.radius;
						return this.x = e * Math.sin(t.theta),
							this.y = Math.cos(t.phi) * t.radius,
							this.z = e * Math.cos(t.theta),
							this
					},
					setFromMatrixPosition: function(t) {
						return this.setFromMatrixColumn(t, 3)
					},
					setFromMatrixScale: function(t) {
						var e = this.setFromMatrixColumn(t, 0).length(),
							n = this.setFromMatrixColumn(t, 1).length(),
							i = this.setFromMatrixColumn(t, 2).length();
						return this.x = e,
							this.y = n,
							this.z = i,
							this
					},
					setFromMatrixColumn: function(t, e) {
						if("number" == typeof t) {
							console.warn("THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).");
							var n = t;
							t = e,
								e = n
						}
						return this.fromArray(t.elements, 4 * e)
					},
					equals: function(t) {
						return t.x === this.x && t.y === this.y && t.z === this.z
					},
					fromArray: function(t, e) {
						return void 0 === e && (e = 0),
							this.x = t[e],
							this.y = t[e + 1],
							this.z = t[e + 2],
							this
					},
					toArray: function(t, e) {
						return void 0 === t && (t = []),
							void 0 === e && (e = 0),
							t[e] = this.x,
							t[e + 1] = this.y,
							t[e + 2] = this.z,
							t
					},
					fromAttribute: function(t, e, n) {
						return void 0 === n && (n = 0),
							e = e * t.itemSize + n,
							this.x = t.array[e],
							this.y = t.array[e + 1],
							this.z = t.array[e + 2],
							this
					}
				},
				e.Vector3 = i
		}, function(t, e) {
			"use strict";
			Object.defineProperty(e, "__esModule", {
				value: !0
			});
			var n = {
				DEG2RAD: Math.PI / 180,
				RAD2DEG: 180 / Math.PI,
				generateUUID: function() {
					var t, e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
						n = new Array(36),
						i = 0;
					return function() {
						for(var r = 0; r < 36; r++)
							8 === r || 13 === r || 18 === r || 23 === r ? n[r] = "-" : 14 === r ? n[r] = "4" : (i <= 2 && (i = 33554432 + 16777216 * Math.random() | 0),
								t = 15 & i,
								i >>= 4,
								n[r] = e[19 === r ? 3 & t | 8 : t]);
						return n.join("")
					}
				}(),
				clamp: function(t, e, n) {
					return Math.max(e, Math.min(n, t))
				},
				euclideanModulo: function(t, e) {
					return(t % e + e) % e
				},
				mapLinear: function(t, e, n, i, r) {
					return i + (t - e) * (r - i) / (n - e)
				},
				lerp: function(t, e, n) {
					return(1 - n) * t + n * e
				},
				smoothstep: function(t, e, n) {
					return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e),
						t * t * (3 - 2 * t))
				},
				smootherstep: function(t, e, n) {
					return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e),
						t * t * t * (t * (6 * t - 15) + 10))
				},
				randInt: function(t, e) {
					return t + Math.floor(Math.random() * (e - t + 1))
				},
				randFloat: function(t, e) {
					return t + Math.random() * (e - t)
				},
				randFloatSpread: function(t) {
					return t * (.5 - Math.random())
				},
				degToRad: function(t) {
					return t * n.DEG2RAD
				},
				radToDeg: function(t) {
					return t * n.RAD2DEG
				},
				isPowerOfTwo: function(t) {
					return 0 === (t & t - 1) && 0 !== t
				},
				nearestPowerOfTwo: function(t) {
					return Math.pow(2, Math.round(Math.log(t) / Math.LN2))
				},
				nextPowerOfTwo: function(t) {
					return t--,
						t |= t >> 1,
						t |= t >> 2,
						t |= t >> 4,
						t |= t >> 8,
						t |= t >> 16,
						t++,
						t
				}
			};
			e._Math = n
		}, function(t, e, n) {
			"use strict";

			function i() {
				this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
					arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
			}
			Object.defineProperty(e, "__esModule", {
					value: !0
				}),
				e.Matrix4 = void 0;
			var r = n(49),
				o = n(48);
			i.prototype = {
					constructor: i,
					isMatrix4: !0,
					set: function(t, e, n, i, r, o, a, s, l, c, u, h, d, f, p, m) {
						var v = this.elements;
						return v[0] = t,
							v[4] = e,
							v[8] = n,
							v[12] = i,
							v[1] = r,
							v[5] = o,
							v[9] = a,
							v[13] = s,
							v[2] = l,
							v[6] = c,
							v[10] = u,
							v[14] = h,
							v[3] = d,
							v[7] = f,
							v[11] = p,
							v[15] = m,
							this
					},
					identity: function() {
						return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
							this
					},
					clone: function() {
						return(new i).fromArray(this.elements)
					},
					copy: function(t) {
						return this.elements.set(t.elements),
							this
					},
					copyPosition: function(t) {
						var e = this.elements,
							n = t.elements;
						return e[12] = n[12],
							e[13] = n[13],
							e[14] = n[14],
							this
					},
					extractBasis: function(t, e, n) {
						return t.setFromMatrixColumn(this, 0),
							e.setFromMatrixColumn(this, 1),
							n.setFromMatrixColumn(this, 2),
							this
					},
					makeBasis: function(t, e, n) {
						return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1),
							this
					},
					extractRotation: function() {
						var t;
						return function(e) {
							void 0 === t && (t = new o.Vector3);
							var n = this.elements,
								i = e.elements,
								r = 1 / t.setFromMatrixColumn(e, 0).length(),
								a = 1 / t.setFromMatrixColumn(e, 1).length(),
								s = 1 / t.setFromMatrixColumn(e, 2).length();
							return n[0] = i[0] * r,
								n[1] = i[1] * r,
								n[2] = i[2] * r,
								n[4] = i[4] * a,
								n[5] = i[5] * a,
								n[6] = i[6] * a,
								n[8] = i[8] * s,
								n[9] = i[9] * s,
								n[10] = i[10] * s,
								this
						}
					}(),
					makeRotationFromEuler: function(t) {
						(t && t.isEuler) === !1 && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
						var e = this.elements,
							n = t.x,
							i = t.y,
							r = t.z,
							o = Math.cos(n),
							a = Math.sin(n),
							s = Math.cos(i),
							l = Math.sin(i),
							c = Math.cos(r),
							u = Math.sin(r);
						if("XYZ" === t.order) {
							var h = o * c,
								d = o * u,
								f = a * c,
								p = a * u;
							e[0] = s * c,
								e[4] = -s * u,
								e[8] = l,
								e[1] = d + f * l,
								e[5] = h - p * l,
								e[9] = -a * s,
								e[2] = p - h * l,
								e[6] = f + d * l,
								e[10] = o * s
						} else if("YXZ" === t.order) {
							var m = s * c,
								v = s * u,
								g = l * c,
								_ = l * u;
							e[0] = m + _ * a,
								e[4] = g * a - v,
								e[8] = o * l,
								e[1] = o * u,
								e[5] = o * c,
								e[9] = -a,
								e[2] = v * a - g,
								e[6] = _ + m * a,
								e[10] = o * s
						} else if("ZXY" === t.order) {
							var m = s * c,
								v = s * u,
								g = l * c,
								_ = l * u;
							e[0] = m - _ * a,
								e[4] = -o * u,
								e[8] = g + v * a,
								e[1] = v + g * a,
								e[5] = o * c,
								e[9] = _ - m * a,
								e[2] = -o * l,
								e[6] = a,
								e[10] = o * s
						} else if("ZYX" === t.order) {
							var h = o * c,
								d = o * u,
								f = a * c,
								p = a * u;
							e[0] = s * c,
								e[4] = f * l - d,
								e[8] = h * l + p,
								e[1] = s * u,
								e[5] = p * l + h,
								e[9] = d * l - f,
								e[2] = -l,
								e[6] = a * s,
								e[10] = o * s
						} else if("YZX" === t.order) {
							var y = o * s,
								b = o * l,
								x = a * s,
								w = a * l;
							e[0] = s * c,
								e[4] = w - y * u,
								e[8] = x * u + b,
								e[1] = u,
								e[5] = o * c,
								e[9] = -a * c,
								e[2] = -l * c,
								e[6] = b * u + x,
								e[10] = y - w * u
						} else if("XZY" === t.order) {
							var y = o * s,
								b = o * l,
								x = a * s,
								w = a * l;
							e[0] = s * c,
								e[4] = -u,
								e[8] = l * c,
								e[1] = y * u + w,
								e[5] = o * c,
								e[9] = b * u - x,
								e[2] = x * u - b,
								e[6] = a * c,
								e[10] = w * u + y
						}
						return e[3] = 0,
							e[7] = 0,
							e[11] = 0,
							e[12] = 0,
							e[13] = 0,
							e[14] = 0,
							e[15] = 1,
							this
					},
					makeRotationFromQuaternion: function(t) {
						var e = this.elements,
							n = t.x,
							i = t.y,
							r = t.z,
							o = t.w,
							a = n + n,
							s = i + i,
							l = r + r,
							c = n * a,
							u = n * s,
							h = n * l,
							d = i * s,
							f = i * l,
							p = r * l,
							m = o * a,
							v = o * s,
							g = o * l;
						return e[0] = 1 - (d + p),
							e[4] = u - g,
							e[8] = h + v,
							e[1] = u + g,
							e[5] = 1 - (c + p),
							e[9] = f - m,
							e[2] = h - v,
							e[6] = f + m,
							e[10] = 1 - (c + d),
							e[3] = 0,
							e[7] = 0,
							e[11] = 0,
							e[12] = 0,
							e[13] = 0,
							e[14] = 0,
							e[15] = 1,
							this
					},
					lookAt: function() {
						var t, e, n;
						return function(i, r, a) {
							void 0 === t && (t = new o.Vector3,
								e = new o.Vector3,
								n = new o.Vector3);
							var s = this.elements;
							return n.subVectors(i, r).normalize(),
								0 === n.lengthSq() && (n.z = 1),
								t.crossVectors(a, n).normalize(),
								0 === t.lengthSq() && (n.z += 1e-4,
									t.crossVectors(a, n).normalize()),
								e.crossVectors(n, t),
								s[0] = t.x,
								s[4] = e.x,
								s[8] = n.x,
								s[1] = t.y,
								s[5] = e.y,
								s[9] = n.y,
								s[2] = t.z,
								s[6] = e.z,
								s[10] = n.z,
								this
						}
					}(),
					multiply: function(t, e) {
						return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
							this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
					},
					premultiply: function(t) {
						return this.multiplyMatrices(t, this)
					},
					multiplyMatrices: function(t, e) {
						var n = t.elements,
							i = e.elements,
							r = this.elements,
							o = n[0],
							a = n[4],
							s = n[8],
							l = n[12],
							c = n[1],
							u = n[5],
							h = n[9],
							d = n[13],
							f = n[2],
							p = n[6],
							m = n[10],
							v = n[14],
							g = n[3],
							_ = n[7],
							y = n[11],
							b = n[15],
							x = i[0],
							w = i[4],
							T = i[8],
							M = i[12],
							E = i[1],
							S = i[5],
							X = i[9],
							A = i[13],
							P = i[2],
							R = i[6],
							O = i[10],
							C = i[14],
							L = i[3],
							I = i[7],
							D = i[11],
							B = i[15];
						return r[0] = o * x + a * E + s * P + l * L,
							r[4] = o * w + a * S + s * R + l * I,
							r[8] = o * T + a * X + s * O + l * D,
							r[12] = o * M + a * A + s * C + l * B,
							r[1] = c * x + u * E + h * P + d * L,
							r[5] = c * w + u * S + h * R + d * I,
							r[9] = c * T + u * X + h * O + d * D,
							r[13] = c * M + u * A + h * C + d * B,
							r[2] = f * x + p * E + m * P + v * L,
							r[6] = f * w + p * S + m * R + v * I,
							r[10] = f * T + p * X + m * O + v * D,
							r[14] = f * M + p * A + m * C + v * B,
							r[3] = g * x + _ * E + y * P + b * L,
							r[7] = g * w + _ * S + y * R + b * I,
							r[11] = g * T + _ * X + y * O + b * D,
							r[15] = g * M + _ * A + y * C + b * B,
							this
					},
					multiplyToArray: function(t, e, n) {
						var i = this.elements;
						return this.multiplyMatrices(t, e),
							n[0] = i[0],
							n[1] = i[1],
							n[2] = i[2],
							n[3] = i[3],
							n[4] = i[4],
							n[5] = i[5],
							n[6] = i[6],
							n[7] = i[7],
							n[8] = i[8],
							n[9] = i[9],
							n[10] = i[10],
							n[11] = i[11],
							n[12] = i[12],
							n[13] = i[13],
							n[14] = i[14],
							n[15] = i[15],
							this
					},
					multiplyScalar: function(t) {
						var e = this.elements;
						return e[0] *= t,
							e[4] *= t,
							e[8] *= t,
							e[12] *= t,
							e[1] *= t,
							e[5] *= t,
							e[9] *= t,
							e[13] *= t,
							e[2] *= t,
							e[6] *= t,
							e[10] *= t,
							e[14] *= t,
							e[3] *= t,
							e[7] *= t,
							e[11] *= t,
							e[15] *= t,
							this
					},
					applyToVector3Array: function() {
						var t;
						return function(e, n, i) {
							void 0 === t && (t = new o.Vector3),
								void 0 === n && (n = 0),
								void 0 === i && (i = e.length);
							for(var r = 0, a = n; r < i; r += 3,
								a += 3)
								t.fromArray(e, a),
								t.applyMatrix4(this),
								t.toArray(e, a);
							return e
						}
					}(),
					applyToBuffer: function() {
						var t;
						return function(e, n, i) {
							void 0 === t && (t = new o.Vector3),
								void 0 === n && (n = 0),
								void 0 === i && (i = e.length / e.itemSize);
							for(var r = 0, a = n; r < i; r++,
								a++)
								t.x = e.getX(a),
								t.y = e.getY(a),
								t.z = e.getZ(a),
								t.applyMatrix4(this),
								e.setXYZ(a, t.x, t.y, t.z);
							return e
						}
					}(),
					determinant: function() {
						var t = this.elements,
							e = t[0],
							n = t[4],
							i = t[8],
							r = t[12],
							o = t[1],
							a = t[5],
							s = t[9],
							l = t[13],
							c = t[2],
							u = t[6],
							h = t[10],
							d = t[14],
							f = t[3],
							p = t[7],
							m = t[11],
							v = t[15];
						return f * (+r * s * u - i * l * u - r * a * h + n * l * h + i * a * d - n * s * d) + p * (+e * s * d - e * l * h + r * o * h - i * o * d + i * l * c - r * s * c) + m * (+e * l * u - e * a * d - r * o * u + n * o * d + r * a * c - n * l * c) + v * (-i * a * c - e * s * u + e * a * h + i * o * u - n * o * h + n * s * c)
					},
					transpose: function() {
						var t, e = this.elements;
						return t = e[1],
							e[1] = e[4],
							e[4] = t,
							t = e[2],
							e[2] = e[8],
							e[8] = t,
							t = e[6],
							e[6] = e[9],
							e[9] = t,
							t = e[3],
							e[3] = e[12],
							e[12] = t,
							t = e[7],
							e[7] = e[13],
							e[13] = t,
							t = e[11],
							e[11] = e[14],
							e[14] = t,
							this
					},
					setPosition: function(t) {
						var e = this.elements;
						return e[12] = t.x,
							e[13] = t.y,
							e[14] = t.z,
							this
					},
					getInverse: function(t, e) {
						var n = this.elements,
							i = t.elements,
							r = i[0],
							o = i[1],
							a = i[2],
							s = i[3],
							l = i[4],
							c = i[5],
							u = i[6],
							h = i[7],
							d = i[8],
							f = i[9],
							p = i[10],
							m = i[11],
							v = i[12],
							g = i[13],
							_ = i[14],
							y = i[15],
							b = f * _ * h - g * p * h + g * u * m - c * _ * m - f * u * y + c * p * y,
							x = v * p * h - d * _ * h - v * u * m + l * _ * m + d * u * y - l * p * y,
							w = d * g * h - v * f * h + v * c * m - l * g * m - d * c * y + l * f * y,
							T = v * f * u - d * g * u - v * c * p + l * g * p + d * c * _ - l * f * _,
							M = r * b + o * x + a * w + s * T;
						if(0 === M) {
							var E = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
							if(e === !0)
								throw new Error(E);
							return console.warn(E),
								this.identity()
						}
						var S = 1 / M;
						return n[0] = b * S,
							n[1] = (g * p * s - f * _ * s - g * a * m + o * _ * m + f * a * y - o * p * y) * S,
							n[2] = (c * _ * s - g * u * s + g * a * h - o * _ * h - c * a * y + o * u * y) * S,
							n[3] = (f * u * s - c * p * s - f * a * h + o * p * h + c * a * m - o * u * m) * S,
							n[4] = x * S,
							n[5] = (d * _ * s - v * p * s + v * a * m - r * _ * m - d * a * y + r * p * y) * S,
							n[6] = (v * u * s - l * _ * s - v * a * h + r * _ * h + l * a * y - r * u * y) * S,
							n[7] = (l * p * s - d * u * s + d * a * h - r * p * h - l * a * m + r * u * m) * S,
							n[8] = w * S,
							n[9] = (v * f * s - d * g * s - v * o * m + r * g * m + d * o * y - r * f * y) * S,
							n[10] = (l * g * s - v * c * s + v * o * h - r * g * h - l * o * y + r * c * y) * S,
							n[11] = (d * c * s - l * f * s - d * o * h + r * f * h + l * o * m - r * c * m) * S,
							n[12] = T * S,
							n[13] = (d * g * a - v * f * a + v * o * p - r * g * p - d * o * _ + r * f * _) * S,
							n[14] = (v * c * a - l * g * a - v * o * u + r * g * u + l * o * _ - r * c * _) * S,
							n[15] = (l * f * a - d * c * a + d * o * u - r * f * u - l * o * p + r * c * p) * S,
							this
					},
					scale: function(t) {
						var e = this.elements,
							n = t.x,
							i = t.y,
							r = t.z;
						return e[0] *= n,
							e[4] *= i,
							e[8] *= r,
							e[1] *= n,
							e[5] *= i,
							e[9] *= r,
							e[2] *= n,
							e[6] *= i,
							e[10] *= r,
							e[3] *= n,
							e[7] *= i,
							e[11] *= r,
							this
					},
					getMaxScaleOnAxis: function() {
						var t = this.elements,
							e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
							n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
							i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
						return Math.sqrt(Math.max(e, n, i))
					},
					makeTranslation: function(t, e, n) {
						return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
							this
					},
					makeRotationX: function(t) {
						var e = Math.cos(t),
							n = Math.sin(t);
						return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1),
							this
					},
					makeRotationY: function(t) {
						var e = Math.cos(t),
							n = Math.sin(t);
						return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1),
							this
					},
					makeRotationZ: function(t) {
						var e = Math.cos(t),
							n = Math.sin(t);
						return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
							this
					},
					makeRotationAxis: function(t, e) {
						var n = Math.cos(e),
							i = Math.sin(e),
							r = 1 - n,
							o = t.x,
							a = t.y,
							s = t.z,
							l = r * o,
							c = r * a;
						return this.set(l * o + n, l * a - i * s, l * s + i * a, 0, l * a + i * s, c * a + n, c * s - i * o, 0, l * s - i * a, c * s + i * o, r * s * s + n, 0, 0, 0, 0, 1),
							this
					},
					makeScale: function(t, e, n) {
						return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
							this
					},
					makeShear: function(t, e, n) {
						return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1),
							this
					},
					compose: function(t, e, n) {
						return this.makeRotationFromQuaternion(e),
							this.scale(n),
							this.setPosition(t),
							this
					},
					decompose: function() {
						var t, e;
						return function(n, r, a) {
							void 0 === t && (t = new o.Vector3,
								e = new i);
							var s = this.elements,
								l = t.set(s[0], s[1], s[2]).length(),
								c = t.set(s[4], s[5], s[6]).length(),
								u = t.set(s[8], s[9], s[10]).length(),
								h = this.determinant();
							h < 0 && (l = -l),
								n.x = s[12],
								n.y = s[13],
								n.z = s[14],
								e.elements.set(this.elements);
							var d = 1 / l,
								f = 1 / c,
								p = 1 / u;
							return e.elements[0] *= d,
								e.elements[1] *= d,
								e.elements[2] *= d,
								e.elements[4] *= f,
								e.elements[5] *= f,
								e.elements[6] *= f,
								e.elements[8] *= p,
								e.elements[9] *= p,
								e.elements[10] *= p,
								r.setFromRotationMatrix(e),
								a.x = l,
								a.y = c,
								a.z = u,
								this
						}
					}(),
					makeFrustum: function(t, e, n, i, r, o) {
						var a = this.elements,
							s = 2 * r / (e - t),
							l = 2 * r / (i - n),
							c = (e + t) / (e - t),
							u = (i + n) / (i - n),
							h = -(o + r) / (o - r),
							d = -2 * o * r / (o - r);
						return a[0] = s,
							a[4] = 0,
							a[8] = c,
							a[12] = 0,
							a[1] = 0,
							a[5] = l,
							a[9] = u,
							a[13] = 0,
							a[2] = 0,
							a[6] = 0,
							a[10] = h,
							a[14] = d,
							a[3] = 0,
							a[7] = 0,
							a[11] = -1,
							a[15] = 0,
							this
					},
					makePerspective: function(t, e, n, i) {
						var o = n * Math.tan(r._Math.DEG2RAD * t * .5),
							a = -o,
							s = a * e,
							l = o * e;
						return this.makeFrustum(s, l, a, o, n, i)
					},
					makeOrthographic: function(t, e, n, i, r, o) {
						var a = this.elements,
							s = 1 / (e - t),
							l = 1 / (n - i),
							c = 1 / (o - r),
							u = (e + t) * s,
							h = (n + i) * l,
							d = (o + r) * c;
						return a[0] = 2 * s,
							a[4] = 0,
							a[8] = 0,
							a[12] = -u,
							a[1] = 0,
							a[5] = 2 * l,
							a[9] = 0,
							a[13] = -h,
							a[2] = 0,
							a[6] = 0,
							a[10] = -2 * c,
							a[14] = -d,
							a[3] = 0,
							a[7] = 0,
							a[11] = 0,
							a[15] = 1,
							this
					},
					equals: function(t) {
						for(var e = this.elements, n = t.elements, i = 0; i < 16; i++)
							if(e[i] !== n[i])
								return !1;
						return !0
					},
					fromArray: function(t, e) {
						void 0 === e && (e = 0);
						for(var n = 0; n < 16; n++)
							this.elements[n] = t[n + e];
						return this
					},
					toArray: function(t, e) {
						void 0 === t && (t = []),
							void 0 === e && (e = 0);
						var n = this.elements;
						return t[e] = n[0],
							t[e + 1] = n[1],
							t[e + 2] = n[2],
							t[e + 3] = n[3],
							t[e + 4] = n[4],
							t[e + 5] = n[5],
							t[e + 6] = n[6],
							t[e + 7] = n[7],
							t[e + 8] = n[8],
							t[e + 9] = n[9],
							t[e + 10] = n[10],
							t[e + 11] = n[11],
							t[e + 12] = n[12],
							t[e + 13] = n[13],
							t[e + 14] = n[14],
							t[e + 15] = n[15],
							t
					}
				},
				e.Matrix4 = i
		}])
	})
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var o = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		a = n(64),
		s = i(a),
		l = n(11),
		c = (i(l),
			document.querySelector("#control-board")),
		u = function() {
			function t(e) {
				r(this, t),
					this.touchStream = new s.default(e),
					this.init(),
					this.startX = 0,
					this.startY = 0,
					this.tempX = 0,
					this.tempY = 0
			}
			return o(t, [{
					key: "init",
					value: function() {
						var t = this,
							e = this.touchStream,
							n = document.body.getBoundingClientRect().width;
						e.touchmove$.subscribe(function(t) {
							t.stopPropagation(),
								t.preventDefault()
						});
						this.touchControl$ = e.pan$.map(function(e) {
							var i = e.x,
								r = e.y,
								o = t.startX + i / (n / 2),
								a = t.startY + -r / (n / 2);
							return o <= -1 ? o = -1 : o > 1 && (o = 1),
								a <= -1 ? a = -1 : a > 1 && (a = 1),
								t.tempX = o,
								t.tempY = a, {
									x: o,
									y: a
								}
						});
						e.touchend$.subscribe(function() {
							t.startX = t.tempX,
								t.startY = t.tempY
						})
					}
				}]),
				t
		}(),
		h = new u(c);
	e.default = h
}, function(t, e, n) {
	! function(e, i) {
		t.exports = i(n(65), n(79), n(82), n(84), n(86), n(93), n(107))
	}(this, function(t, e, n, i, r, o, a) {
		return function(t) {
			function e(i) {
				if(n[i])
					return n[i].exports;
				var r = n[i] = {
					exports: {},
					id: i,
					loaded: !1
				};
				return t[i].call(r.exports, r, r.exports, e),
					r.loaded = !0,
					r.exports
			}
			var n = {};
			return e.m = t,
				e.c = n,
				e.p = "/Users/hhj/Desktop/mjproject/lib-touchstream/build",
				e(0)
		}([function(t, e, n) {
			"use strict";
			Object.defineProperty(e, "__esModule", {
				value: !0
			});
			var i = n(1);
			n(2),
				n(3),
				n(4),
				n(5),
				n(6),
				n(7);
			var r = function(t) {
					return {
						x: t.touches[0].clientX,
						y: t.touches[0].clientY
					}
				},
				o = function(t, e) {
					return {
						x: e.x - t.x,
						y: e.y - t.y
					}
				},
				a = function() {
					function t(t) {
						this.target = t,
							this.initBasic(),
							this.initSenior()
					}
					return t.prototype.initBasic = function() {
							var t = this.target;
							this.touchstart$ = i.Observable.fromEvent(t, "touchstart").share(),
								this.touchmove$ = i.Observable.fromEvent(t, "touchmove").share(),
								this.touchend$ = i.Observable.fromEvent(t, "touchend").share()
						},
						t.prototype.initSenior = function() {
							var t = this,
								e = (t.target,
									t.touchstart$),
								n = t.touchmove$,
								i = t.touchend$,
								a = e.map(function(t) {
									return {
										point: r(t),
										time: Date.now()
									}
								}).share(),
								s = i.map(function(t) {
									return {
										time: Date.now()
									}
								}).share(),
								l = n.map(function(t) {
									return {
										point: r(t),
										time: Date.now()
									}
								}).share();
							this.pan$ = l.withLatestFrom(a, function(t, e) {
									return o(e.point, t.point)
								}).share(),
								this.panend$ = s.withLatestFrom(l, a, function(t, e, n) {
									return {
										end: t,
										last: e,
										start: n
									}
								}).filter(function(t) {
									var e = t.end,
										n = t.last,
										i = t.start;
									return n.time > i.time && n.time < e.time
								}).map(function(t) {
									var e = (t.end,
											t.last),
										n = t.start,
										i = e.point.x - n.point.x,
										r = e.point.y - n.point.y,
										o = Date.now() - n.time;
									return {
										distanceX: i,
										distanceY: r,
										deltaTime: o,
										velocityX: i / o,
										velocityY: r / o
									}
								}).share()
						},
						t
				}();
			e.default = a
		}, function(e, n) {
			e.exports = t
		}, function(t, n) {
			t.exports = e
		}, function(t, e) {
			t.exports = n
		}, function(t, e) {
			t.exports = i
		}, function(t, e) {
			t.exports = r
		}, function(t, e) {
			t.exports = o
		}, function(t, e) {
			t.exports = a
		}])
	})
}, function(t, e, n) {
	"use strict";
	var i = n(66),
		r = n(67),
		o = n(78),
		a = function() {
			function t(t) {
				this._isScalar = !1,
					t && (this._subscribe = t)
			}
			return t.prototype.lift = function(e) {
					var n = new t;
					return n.source = this,
						n.operator = e,
						n
				},
				t.prototype.subscribe = function(t, e, n) {
					var i = this.operator,
						o = r.toSubscriber(t, e, n);
					if(i ? i.call(o, this.source) : o.add(this.source ? this._subscribe(o) : this._trySubscribe(o)),
						o.syncErrorThrowable && (o.syncErrorThrowable = !1,
							o.syncErrorThrown))
						throw o.syncErrorValue;
					return o
				},
				t.prototype._trySubscribe = function(t) {
					try {
						return this._subscribe(t)
					} catch(e) {
						t.syncErrorThrown = !0,
							t.syncErrorValue = e,
							t.error(e)
					}
				},
				t.prototype.forEach = function(t, e) {
					var n = this;
					if(e || (i.root.Rx && i.root.Rx.config && i.root.Rx.config.Promise ? e = i.root.Rx.config.Promise : i.root.Promise && (e = i.root.Promise)), !e)
						throw new Error("no Promise impl found");
					return new e(function(e, i) {
						var r;
						r = n.subscribe(function(e) {
							if(r)
								try {
									t(e)
								} catch(t) {
									i(t),
										r.unsubscribe()
								}
							else
								t(e)
						}, i, e)
					})
				},
				t.prototype._subscribe = function(t) {
					return this.source.subscribe(t)
				},
				t.prototype[o.observable] = function() {
					return this
				},
				t.create = function(e) {
					return new t(e)
				},
				t
		}();
	e.Observable = a
}, function(t, e) {
	(function(t) {
		"use strict";
		var n = "undefined" != typeof window && window,
			i = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self,
			r = "undefined" != typeof t && t,
			o = n || r || i;
		e.root = o,
			function() {
				if(!o)
					throw new Error("RxJS could not find any global context (window, self, global)")
			}()
	}).call(e, function() {
		return this
	}())
}, function(t, e, n) {
	"use strict";

	function i(t, e, n) {
		if(t) {
			if(t instanceof r.Subscriber)
				return t;
			if(t[o.rxSubscriber])
				return t[o.rxSubscriber]()
		}
		return t || e || n ? new r.Subscriber(t, e, n) : new r.Subscriber(a.empty)
	}
	var r = n(68),
		o = n(77),
		a = n(76);
	e.toSubscriber = i
}, function(t, e, n) {
	"use strict";
	var i = this && this.__extends || function(t, e) {
			function n() {
				this.constructor = t
			}
			for(var i in e)
				e.hasOwnProperty(i) && (t[i] = e[i]);
			t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
				new n)
		},
		r = n(69),
		o = n(70),
		a = n(76),
		s = n(77),
		l = function(t) {
			function e(n, i, r) {
				switch(t.call(this),
					this.syncErrorValue = null,
					this.syncErrorThrown = !1,
					this.syncErrorThrowable = !1,
					this.isStopped = !1,
					arguments.length) {
					case 0:
						this.destination = a.empty;
						break;
					case 1:
						if(!n) {
							this.destination = a.empty;
							break
						}
						if("object" == typeof n) {
							n instanceof e ? (this.destination = n,
								this.destination.add(this)) : (this.syncErrorThrowable = !0,
								this.destination = new c(this, n));
							break
						}
					default:
						this.syncErrorThrowable = !0,
							this.destination = new c(this, n, i, r)
				}
			}
			return i(e, t),
				e.prototype[s.rxSubscriber] = function() {
					return this
				},
				e.create = function(t, n, i) {
					var r = new e(t, n, i);
					return r.syncErrorThrowable = !1,
						r
				},
				e.prototype.next = function(t) {
					this.isStopped || this._next(t)
				},
				e.prototype.error = function(t) {
					this.isStopped || (this.isStopped = !0,
						this._error(t))
				},
				e.prototype.complete = function() {
					this.isStopped || (this.isStopped = !0,
						this._complete())
				},
				e.prototype.unsubscribe = function() {
					this.closed || (this.isStopped = !0,
						t.prototype.unsubscribe.call(this))
				},
				e.prototype._next = function(t) {
					this.destination.next(t)
				},
				e.prototype._error = function(t) {
					this.destination.error(t),
						this.unsubscribe()
				},
				e.prototype._complete = function() {
					this.destination.complete(),
						this.unsubscribe()
				},
				e.prototype._unsubscribeAndRecycle = function() {
					var t = this,
						e = t._parent,
						n = t._parents;
					return this._parent = null,
						this._parents = null,
						this.unsubscribe(),
						this.closed = !1,
						this.isStopped = !1,
						this._parent = e,
						this._parents = n,
						this
				},
				e
		}(o.Subscription);
	e.Subscriber = l;
	var c = function(t) {
		function e(e, n, i, o) {
			t.call(this),
				this._parentSubscriber = e;
			var s, l = this;
			r.isFunction(n) ? s = n : n && (s = n.next,
					i = n.error,
					o = n.complete,
					n !== a.empty && (l = Object.create(n),
						r.isFunction(l.unsubscribe) && this.add(l.unsubscribe.bind(l)),
						l.unsubscribe = this.unsubscribe.bind(this))),
				this._context = l,
				this._next = s,
				this._error = i,
				this._complete = o
		}
		return i(e, t),
			e.prototype.next = function(t) {
				if(!this.isStopped && this._next) {
					var e = this._parentSubscriber;
					e.syncErrorThrowable ? this.__tryOrSetError(e, this._next, t) && this.unsubscribe() : this.__tryOrUnsub(this._next, t)
				}
			},
			e.prototype.error = function(t) {
				if(!this.isStopped) {
					var e = this._parentSubscriber;
					if(this._error)
						e.syncErrorThrowable ? (this.__tryOrSetError(e, this._error, t),
							this.unsubscribe()) : (this.__tryOrUnsub(this._error, t),
							this.unsubscribe());
					else {
						if(!e.syncErrorThrowable)
							throw this.unsubscribe(),
								t;
						e.syncErrorValue = t,
							e.syncErrorThrown = !0,
							this.unsubscribe()
					}
				}
			},
			e.prototype.complete = function() {
				var t = this;
				if(!this.isStopped) {
					var e = this._parentSubscriber;
					if(this._complete) {
						var n = function() {
							return t._complete.call(t._context)
						};
						e.syncErrorThrowable ? (this.__tryOrSetError(e, n),
							this.unsubscribe()) : (this.__tryOrUnsub(n),
							this.unsubscribe())
					} else
						this.unsubscribe()
				}
			},
			e.prototype.__tryOrUnsub = function(t, e) {
				try {
					t.call(this._context, e)
				} catch(t) {
					throw this.unsubscribe(),
						t
				}
			},
			e.prototype.__tryOrSetError = function(t, e, n) {
				try {
					e.call(this._context, n)
				} catch(e) {
					return t.syncErrorValue = e,
						t.syncErrorThrown = !0, !0
				}
				return !1
			},
			e.prototype._unsubscribe = function() {
				var t = this._parentSubscriber;
				this._context = null,
					this._parentSubscriber = null,
					t.unsubscribe();
			},
			e
	}(l)
}, function(t, e) {
	"use strict";

	function n(t) {
		return "function" == typeof t
	}
	e.isFunction = n
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t.reduce(function(t, e) {
			return t.concat(e instanceof c.UnsubscriptionError ? e.errors : e)
		}, [])
	}
	var r = n(71),
		o = n(72),
		a = n(69),
		s = n(73),
		l = n(74),
		c = n(75),
		u = function() {
			function t(t) {
				this.closed = !1,
					this._parent = null,
					this._parents = null,
					this._subscriptions = null,
					t && (this._unsubscribe = t)
			}
			return t.prototype.unsubscribe = function() {
					var t, e = !1;
					if(!this.closed) {
						var n = this,
							u = n._parent,
							h = n._parents,
							d = n._unsubscribe,
							f = n._subscriptions;
						this.closed = !0,
							this._parent = null,
							this._parents = null,
							this._subscriptions = null;
						for(var p = -1, m = h ? h.length : 0; u;)
							u.remove(this),
							u = ++p < m && h[p] || null;
						if(a.isFunction(d)) {
							var v = s.tryCatch(d).call(this);
							v === l.errorObject && (e = !0,
								t = t || (l.errorObject.e instanceof c.UnsubscriptionError ? i(l.errorObject.e.errors) : [l.errorObject.e]))
						}
						if(r.isArray(f))
							for(p = -1,
								m = f.length; ++p < m;) {
								var g = f[p];
								if(o.isObject(g)) {
									var v = s.tryCatch(g.unsubscribe).call(g);
									if(v === l.errorObject) {
										e = !0,
											t = t || [];
										var _ = l.errorObject.e;
										_ instanceof c.UnsubscriptionError ? t = t.concat(i(_.errors)) : t.push(_)
									}
								}
							}
						if(e)
							throw new c.UnsubscriptionError(t)
					}
				},
				t.prototype.add = function(e) {
					if(!e || e === t.EMPTY)
						return t.EMPTY;
					if(e === this)
						return this;
					var n = e;
					switch(typeof e) {
						case "function":
							n = new t(e);
						case "object":
							if(n.closed || "function" != typeof n.unsubscribe)
								return n;
							if(this.closed)
								return n.unsubscribe(),
									n;
							if("function" != typeof n._addParent) {
								var i = n;
								n = new t,
									n._subscriptions = [i]
							}
							break;
						default:
							throw new Error("unrecognized teardown " + e + " added to Subscription.")
					}
					var r = this._subscriptions || (this._subscriptions = []);
					return r.push(n),
						n._addParent(this),
						n
				},
				t.prototype.remove = function(t) {
					var e = this._subscriptions;
					if(e) {
						var n = e.indexOf(t);
						n !== -1 && e.splice(n, 1)
					}
				},
				t.prototype._addParent = function(t) {
					var e = this,
						n = e._parent,
						i = e._parents;
					n && n !== t ? i ? i.indexOf(t) === -1 && i.push(t) : this._parents = [t] : this._parent = t
				},
				t.EMPTY = function(t) {
					return t.closed = !0,
						t
				}(new t),
				t
		}();
	e.Subscription = u
}, function(t, e) {
	"use strict";
	e.isArray = Array.isArray || function(t) {
		return t && "number" == typeof t.length
	}
}, function(t, e) {
	"use strict";

	function n(t) {
		return null != t && "object" == typeof t
	}
	e.isObject = n
}, function(t, e, n) {
	"use strict";

	function i() {
		try {
			return o.apply(this, arguments)
		} catch(t) {
			return a.errorObject.e = t,
				a.errorObject
		}
	}

	function r(t) {
		return o = t,
			i
	}
	var o, a = n(74);
	e.tryCatch = r
}, function(t, e) {
	"use strict";
	e.errorObject = {
		e: {}
	}
}, function(t, e) {
	"use strict";
	var n = this && this.__extends || function(t, e) {
			function n() {
				this.constructor = t
			}
			for(var i in e)
				e.hasOwnProperty(i) && (t[i] = e[i]);
			t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
				new n)
		},
		i = function(t) {
			function e(e) {
				t.call(this),
					this.errors = e;
				var n = Error.call(this, e ? e.length + " errors occurred during unsubscription:\n  " + e.map(function(t, e) {
					return e + 1 + ") " + t.toString()
				}).join("\n  ") : "");
				this.name = n.name = "UnsubscriptionError",
					this.stack = n.stack,
					this.message = n.message
			}
			return n(e, t),
				e
		}(Error);
	e.UnsubscriptionError = i
}, function(t, e) {
	"use strict";
	e.empty = {
		closed: !0,
		next: function(t) {},
		error: function(t) {
			throw t
		},
		complete: function() {}
	}
}, function(t, e, n) {
	"use strict";
	var i = n(66),
		r = i.root.Symbol;
	e.rxSubscriber = "function" == typeof r && "function" == typeof r.for ? r.for("rxSubscriber") : "@@rxSubscriber",
		e.$$rxSubscriber = e.rxSubscriber
}, function(t, e, n) {
	"use strict";

	function i(t) {
		var e, n = t.Symbol;
		return "function" == typeof n ? n.observable ? e = n.observable : (e = n("observable"),
				n.observable = e) : e = "@@observable",
			e
	}
	var r = n(66);
	e.getSymbolObservable = i,
		e.observable = i(r.root),
		e.$$observable = e.observable
}, function(t, e, n) {
	"use strict";
	var i = n(65),
		r = n(80);
	i.Observable.fromEvent = r.fromEvent
}, function(t, e, n) {
	"use strict";
	var i = n(81);
	e.fromEvent = i.FromEventObservable.create
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return !!t && "function" == typeof t.addListener && "function" == typeof t.removeListener
	}

	function r(t) {
		return !!t && "function" == typeof t.on && "function" == typeof t.off
	}

	function o(t) {
		return !!t && "[object NodeList]" === p.call(t)
	}

	function a(t) {
		return !!t && "[object HTMLCollection]" === p.call(t)
	}

	function s(t) {
		return !!t && "function" == typeof t.addEventListener && "function" == typeof t.removeEventListener
	}
	var l = this && this.__extends || function(t, e) {
			function n() {
				this.constructor = t
			}
			for(var i in e)
				e.hasOwnProperty(i) && (t[i] = e[i]);
			t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
				new n)
		},
		c = n(65),
		u = n(73),
		h = n(69),
		d = n(74),
		f = n(70),
		p = Object.prototype.toString,
		m = function(t) {
			function e(e, n, i, r) {
				t.call(this),
					this.sourceObj = e,
					this.eventName = n,
					this.selector = i,
					this.options = r
			}
			return l(e, t),
				e.create = function(t, n, i, r) {
					return h.isFunction(i) && (r = i,
							i = void 0),
						new e(t, n, r, i)
				},
				e.setupSubscription = function(t, n, l, c, u) {
					var h;
					if(o(t) || a(t))
						for(var d = 0, p = t.length; d < p; d++)
							e.setupSubscription(t[d], n, l, c, u);
					else if(s(t)) {
						var m = t;
						t.addEventListener(n, l, u),
							h = function() {
								return m.removeEventListener(n, l)
							}
					} else if(r(t)) {
						var v = t;
						t.on(n, l),
							h = function() {
								return v.off(n, l)
							}
					} else {
						if(!i(t))
							throw new TypeError("Invalid event target");
						var g = t;
						t.addListener(n, l),
							h = function() {
								return g.removeListener(n, l)
							}
					}
					c.add(new f.Subscription(h))
				},
				e.prototype._subscribe = function(t) {
					var n = this.sourceObj,
						i = this.eventName,
						r = this.options,
						o = this.selector,
						a = o ? function() {
							for(var e = [], n = 0; n < arguments.length; n++)
								e[n - 0] = arguments[n];
							var i = u.tryCatch(o).apply(void 0, e);
							i === d.errorObject ? t.error(d.errorObject.e) : t.next(i)
						} :
						function(e) {
							return t.next(e)
						};
					e.setupSubscription(n, i, a, t, r)
				},
				e
		}(c.Observable);
	e.FromEventObservable = m
}, function(t, e, n) {
	"use strict";
	var i = n(65),
		r = n(83);
	i.Observable.prototype.map = r.map
}, function(t, e, n) {
	"use strict";

	function i(t, e) {
		if("function" != typeof t)
			throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
		return this.lift(new a(t, e))
	}
	var r = this && this.__extends || function(t, e) {
			function n() {
				this.constructor = t
			}
			for(var i in e)
				e.hasOwnProperty(i) && (t[i] = e[i]);
			t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
				new n)
		},
		o = n(68);
	e.map = i;
	var a = function() {
		function t(t, e) {
			this.project = t,
				this.thisArg = e
		}
		return t.prototype.call = function(t, e) {
				return e.subscribe(new s(t, this.project, this.thisArg))
			},
			t
	}();
	e.MapOperator = a;
	var s = function(t) {
		function e(e, n, i) {
			t.call(this, e),
				this.project = n,
				this.count = 0,
				this.thisArg = i || this
		}
		return r(e, t),
			e.prototype._next = function(t) {
				var e;
				try {
					e = this.project.call(this.thisArg, t, this.count++)
				} catch(t) {
					return void this.destination.error(t)
				}
				this.destination.next(e)
			},
			e
	}(o.Subscriber)
}, function(t, e, n) {
	"use strict";
	var i = n(65),
		r = n(85);
	i.Observable.prototype.filter = r.filter
}, function(t, e, n) {
	"use strict";

	function i(t, e) {
		return this.lift(new a(t, e))
	}
	var r = this && this.__extends || function(t, e) {
			function n() {
				this.constructor = t
			}
			for(var i in e)
				e.hasOwnProperty(i) && (t[i] = e[i]);
			t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
				new n)
		},
		o = n(68);
	e.filter = i;
	var a = function() {
			function t(t, e) {
				this.predicate = t,
					this.thisArg = e
			}
			return t.prototype.call = function(t, e) {
					return e.subscribe(new s(t, this.predicate, this.thisArg))
				},
				t
		}(),
		s = function(t) {
			function e(e, n, i) {
				t.call(this, e),
					this.predicate = n,
					this.thisArg = i,
					this.count = 0,
					this.predicate = n
			}
			return r(e, t),
				e.prototype._next = function(t) {
					var e;
					try {
						e = this.predicate.call(this.thisArg, t, this.count++)
					} catch(t) {
						return void this.destination.error(t)
					}
					e && this.destination.next(t)
				},
				e
		}(o.Subscriber)
}, function(t, e, n) {
	"use strict";
	var i = n(65),
		r = n(87);
	i.Observable.prototype.share = r.share
}, function(t, e, n) {
	"use strict";

	function i() {
		return new a.Subject
	}

	function r() {
		return o.multicast.call(this, i).refCount()
	}
	var o = n(88),
		a = n(90);
	e.share = r
}, function(t, e, n) {
	"use strict";

	function i(t, e) {
		var n;
		if(n = "function" == typeof t ? t : function() {
				return t
			},
			"function" == typeof e)
			return this.lift(new o(n, e));
		var i = Object.create(this, r.connectableObservableDescriptor);
		return i.source = this,
			i.subjectFactory = n,
			i
	}
	var r = n(89);
	e.multicast = i;
	var o = function() {
		function t(t, e) {
			this.subjectFactory = t,
				this.selector = e
		}
		return t.prototype.call = function(t, e) {
				var n = this.selector,
					i = this.subjectFactory(),
					r = n(i).subscribe(t);
				return r.add(e.subscribe(i)),
					r
			},
			t
	}();
	e.MulticastOperator = o
}, function(t, e, n) {
	"use strict";
	var i = this && this.__extends || function(t, e) {
			function n() {
				this.constructor = t
			}
			for(var i in e)
				e.hasOwnProperty(i) && (t[i] = e[i]);
			t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
				new n)
		},
		r = n(90),
		o = n(65),
		a = n(68),
		s = n(70),
		l = function(t) {
			function e(e, n) {
				t.call(this),
					this.source = e,
					this.subjectFactory = n,
					this._refCount = 0,
					this._isComplete = !1
			}
			return i(e, t),
				e.prototype._subscribe = function(t) {
					return this.getSubject().subscribe(t)
				},
				e.prototype.getSubject = function() {
					var t = this._subject;
					return t && !t.isStopped || (this._subject = this.subjectFactory()),
						this._subject
				},
				e.prototype.connect = function() {
					var t = this._connection;
					return t || (this._isComplete = !1,
							t = this._connection = new s.Subscription,
							t.add(this.source.subscribe(new u(this.getSubject(), this))),
							t.closed ? (this._connection = null,
								t = s.Subscription.EMPTY) : this._connection = t),
						t
				},
				e.prototype.refCount = function() {
					return this.lift(new h(this))
				},
				e
		}(o.Observable);
	e.ConnectableObservable = l;
	var c = l.prototype;
	e.connectableObservableDescriptor = {
		operator: {
			value: null
		},
		_refCount: {
			value: 0,
			writable: !0
		},
		_subject: {
			value: null,
			writable: !0
		},
		_connection: {
			value: null,
			writable: !0
		},
		_subscribe: {
			value: c._subscribe
		},
		_isComplete: {
			value: c._isComplete,
			writable: !0
		},
		getSubject: {
			value: c.getSubject
		},
		connect: {
			value: c.connect
		},
		refCount: {
			value: c.refCount
		}
	};
	var u = function(t) {
			function e(e, n) {
				t.call(this, e),
					this.connectable = n
			}
			return i(e, t),
				e.prototype._error = function(e) {
					this._unsubscribe(),
						t.prototype._error.call(this, e)
				},
				e.prototype._complete = function() {
					this.connectable._isComplete = !0,
						this._unsubscribe(),
						t.prototype._complete.call(this)
				},
				e.prototype._unsubscribe = function() {
					var t = this.connectable;
					if(t) {
						this.connectable = null;
						var e = t._connection;
						t._refCount = 0,
							t._subject = null,
							t._connection = null,
							e && e.unsubscribe()
					}
				},
				e
		}(r.SubjectSubscriber),
		h = function() {
			function t(t) {
				this.connectable = t
			}
			return t.prototype.call = function(t, e) {
					var n = this.connectable;
					n._refCount++;
					var i = new d(t, n),
						r = e.subscribe(i);
					return i.closed || (i.connection = n.connect()),
						r
				},
				t
		}(),
		d = function(t) {
			function e(e, n) {
				t.call(this, e),
					this.connectable = n
			}
			return i(e, t),
				e.prototype._unsubscribe = function() {
					var t = this.connectable;
					if(!t)
						return void(this.connection = null);
					this.connectable = null;
					var e = t._refCount;
					if(e <= 0)
						return void(this.connection = null);
					if(t._refCount = e - 1,
						e > 1)
						return void(this.connection = null);
					var n = this.connection,
						i = t._connection;
					this.connection = null, !i || n && i !== n || i.unsubscribe()
				},
				e
		}(a.Subscriber)
}, function(t, e, n) {
	"use strict";
	var i = this && this.__extends || function(t, e) {
			function n() {
				this.constructor = t
			}
			for(var i in e)
				e.hasOwnProperty(i) && (t[i] = e[i]);
			t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
				new n)
		},
		r = n(65),
		o = n(68),
		a = n(70),
		s = n(91),
		l = n(92),
		c = n(77),
		u = function(t) {
			function e(e) {
				t.call(this, e),
					this.destination = e
			}
			return i(e, t),
				e
		}(o.Subscriber);
	e.SubjectSubscriber = u;
	var h = function(t) {
		function e() {
			t.call(this),
				this.observers = [],
				this.closed = !1,
				this.isStopped = !1,
				this.hasError = !1,
				this.thrownError = null
		}
		return i(e, t),
			e.prototype[c.rxSubscriber] = function() {
				return new u(this)
			},
			e.prototype.lift = function(t) {
				var e = new d(this, this);
				return e.operator = t,
					e
			},
			e.prototype.next = function(t) {
				if(this.closed)
					throw new s.ObjectUnsubscribedError;
				if(!this.isStopped)
					for(var e = this.observers, n = e.length, i = e.slice(), r = 0; r < n; r++)
						i[r].next(t)
			},
			e.prototype.error = function(t) {
				if(this.closed)
					throw new s.ObjectUnsubscribedError;
				this.hasError = !0,
					this.thrownError = t,
					this.isStopped = !0;
				for(var e = this.observers, n = e.length, i = e.slice(), r = 0; r < n; r++)
					i[r].error(t);
				this.observers.length = 0
			},
			e.prototype.complete = function() {
				if(this.closed)
					throw new s.ObjectUnsubscribedError;
				this.isStopped = !0;
				for(var t = this.observers, e = t.length, n = t.slice(), i = 0; i < e; i++)
					n[i].complete();
				this.observers.length = 0
			},
			e.prototype.unsubscribe = function() {
				this.isStopped = !0,
					this.closed = !0,
					this.observers = null
			},
			e.prototype._trySubscribe = function(e) {
				if(this.closed)
					throw new s.ObjectUnsubscribedError;
				return t.prototype._trySubscribe.call(this, e)
			},
			e.prototype._subscribe = function(t) {
				if(this.closed)
					throw new s.ObjectUnsubscribedError;
				return this.hasError ? (t.error(this.thrownError),
					a.Subscription.EMPTY) : this.isStopped ? (t.complete(),
					a.Subscription.EMPTY) : (this.observers.push(t),
					new l.SubjectSubscription(this, t))
			},
			e.prototype.asObservable = function() {
				var t = new r.Observable;
				return t.source = this,
					t
			},
			e.create = function(t, e) {
				return new d(t, e)
			},
			e
	}(r.Observable);
	e.Subject = h;
	var d = function(t) {
		function e(e, n) {
			t.call(this),
				this.destination = e,
				this.source = n
		}
		return i(e, t),
			e.prototype.next = function(t) {
				var e = this.destination;
				e && e.next && e.next(t)
			},
			e.prototype.error = function(t) {
				var e = this.destination;
				e && e.error && this.destination.error(t)
			},
			e.prototype.complete = function() {
				var t = this.destination;
				t && t.complete && this.destination.complete()
			},
			e.prototype._subscribe = function(t) {
				var e = this.source;
				return e ? this.source.subscribe(t) : a.Subscription.EMPTY
			},
			e
	}(h);
	e.AnonymousSubject = d
}, function(t, e) {
	"use strict";
	var n = this && this.__extends || function(t, e) {
			function n() {
				this.constructor = t
			}
			for(var i in e)
				e.hasOwnProperty(i) && (t[i] = e[i]);
			t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
				new n)
		},
		i = function(t) {
			function e() {
				var e = t.call(this, "object unsubscribed");
				this.name = e.name = "ObjectUnsubscribedError",
					this.stack = e.stack,
					this.message = e.message
			}
			return n(e, t),
				e
		}(Error);
	e.ObjectUnsubscribedError = i
}, function(t, e, n) {
	"use strict";
	var i = this && this.__extends || function(t, e) {
			function n() {
				this.constructor = t
			}
			for(var i in e)
				e.hasOwnProperty(i) && (t[i] = e[i]);
			t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
				new n)
		},
		r = n(70),
		o = function(t) {
			function e(e, n) {
				t.call(this),
					this.subject = e,
					this.subscriber = n,
					this.closed = !1
			}
			return i(e, t),
				e.prototype.unsubscribe = function() {
					if(!this.closed) {
						this.closed = !0;
						var t = this.subject,
							e = t.observers;
						if(this.subject = null,
							e && 0 !== e.length && !t.isStopped && !t.closed) {
							var n = e.indexOf(this.subscriber);
							n !== -1 && e.splice(n, 1)
						}
					}
				},
				e
		}(r.Subscription);
	e.SubjectSubscription = o
}, function(t, e, n) {
	"use strict";
	var i = n(65),
		r = n(94);
	i.Observable.prototype.throttleTime = r.throttleTime
}, function(t, e, n) {
	"use strict";

	function i(t, e, n) {
		return void 0 === e && (e = s.async),
			void 0 === n && (n = l.defaultThrottleConfig),
			this.lift(new c(t, e, n.leading, n.trailing))
	}

	function r(t) {
		var e = t.subscriber;
		e.clearThrottle()
	}
	var o = this && this.__extends || function(t, e) {
			function n() {
				this.constructor = t
			}
			for(var i in e)
				e.hasOwnProperty(i) && (t[i] = e[i]);
			t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
				new n)
		},
		a = n(68),
		s = n(95),
		l = n(100);
	e.throttleTime = i;
	var c = function() {
			function t(t, e, n, i) {
				this.duration = t,
					this.scheduler = e,
					this.leading = n,
					this.trailing = i
			}
			return t.prototype.call = function(t, e) {
					return e.subscribe(new u(t, this.duration, this.scheduler, this.leading, this.trailing))
				},
				t
		}(),
		u = function(t) {
			function e(e, n, i, r, o) {
				t.call(this, e),
					this.duration = n,
					this.scheduler = i,
					this.leading = r,
					this.trailing = o,
					this._hasTrailingValue = !1,
					this._trailingValue = null
			}
			return o(e, t),
				e.prototype._next = function(t) {
					this.throttled ? this.trailing && (this._trailingValue = t,
						this._hasTrailingValue = !0) : (this.add(this.throttled = this.scheduler.schedule(r, this.duration, {
							subscriber: this
						})),
						this.leading && this.destination.next(t))
				},
				e.prototype.clearThrottle = function() {
					var t = this.throttled;
					t && (this.trailing && this._hasTrailingValue && (this.destination.next(this._trailingValue),
							this._trailingValue = null,
							this._hasTrailingValue = !1),
						t.unsubscribe(),
						this.remove(t),
						this.throttled = null)
				},
				e
		}(a.Subscriber)
}, function(t, e, n) {
	"use strict";
	var i = n(96),
		r = n(98);
	e.async = new r.AsyncScheduler(i.AsyncAction)
}, function(t, e, n) {
	"use strict";
	var i = this && this.__extends || function(t, e) {
			function n() {
				this.constructor = t
			}
			for(var i in e)
				e.hasOwnProperty(i) && (t[i] = e[i]);
			t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
				new n)
		},
		r = n(66),
		o = n(97),
		a = function(t) {
			function e(e, n) {
				t.call(this, e, n),
					this.scheduler = e,
					this.work = n,
					this.pending = !1
			}
			return i(e, t),
				e.prototype.schedule = function(t, e) {
					if(void 0 === e && (e = 0),
						this.closed)
						return this;
					this.state = t,
						this.pending = !0;
					var n = this.id,
						i = this.scheduler;
					return null != n && (this.id = this.recycleAsyncId(i, n, e)),
						this.delay = e,
						this.id = this.id || this.requestAsyncId(i, this.id, e),
						this
				},
				e.prototype.requestAsyncId = function(t, e, n) {
					return void 0 === n && (n = 0),
						r.root.setInterval(t.flush.bind(t, this), n)
				},
				e.prototype.recycleAsyncId = function(t, e, n) {
					return void 0 === n && (n = 0),
						null !== n && this.delay === n && this.pending === !1 ? e : r.root.clearInterval(e) && void 0 || void 0
				},
				e.prototype.execute = function(t, e) {
					if(this.closed)
						return new Error("executing a cancelled action");
					this.pending = !1;
					var n = this._execute(t, e);
					return n ? n : void(this.pending === !1 && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)))
				},
				e.prototype._execute = function(t, e) {
					var n = !1,
						i = void 0;
					try {
						this.work(t)
					} catch(t) {
						n = !0,
							i = !!t && t || new Error(t)
					}
					if(n)
						return this.unsubscribe(),
							i
				},
				e.prototype._unsubscribe = function() {
					var t = this.id,
						e = this.scheduler,
						n = e.actions,
						i = n.indexOf(this);
					this.work = null,
						this.state = null,
						this.pending = !1,
						this.scheduler = null,
						i !== -1 && n.splice(i, 1),
						null != t && (this.id = this.recycleAsyncId(e, t, null)),
						this.delay = null
				},
				e
		}(o.Action);
	e.AsyncAction = a
}, function(t, e, n) {
	"use strict";
	var i = this && this.__extends || function(t, e) {
			function n() {
				this.constructor = t
			}
			for(var i in e)
				e.hasOwnProperty(i) && (t[i] = e[i]);
			t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
				new n)
		},
		r = n(70),
		o = function(t) {
			function e(e, n) {
				t.call(this)
			}
			return i(e, t),
				e.prototype.schedule = function(t, e) {
					return void 0 === e && (e = 0),
						this
				},
				e
		}(r.Subscription);
	e.Action = o
}, function(t, e, n) {
	"use strict";
	var i = this && this.__extends || function(t, e) {
			function n() {
				this.constructor = t
			}
			for(var i in e)
				e.hasOwnProperty(i) && (t[i] = e[i]);
			t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
				new n)
		},
		r = n(99),
		o = function(t) {
			function e() {
				t.apply(this, arguments),
					this.actions = [],
					this.active = !1,
					this.scheduled = void 0
			}
			return i(e, t),
				e.prototype.flush = function(t) {
					var e = this.actions;
					if(this.active)
						return void e.push(t);
					var n;
					this.active = !0;
					do
						if(n = t.execute(t.state, t.delay))
							break;
					while (t = e.shift());
					if(this.active = !1,
						n) {
						for(; t = e.shift();)
							t.unsubscribe();
						throw n
					}
				},
				e
		}(r.Scheduler);
	e.AsyncScheduler = o
}, function(t, e) {
	"use strict";
	var n = function() {
		function t(e, n) {
			void 0 === n && (n = t.now),
				this.SchedulerAction = e,
				this.now = n
		}
		return t.prototype.schedule = function(t, e, n) {
				return void 0 === e && (e = 0),
					new this.SchedulerAction(this, t).schedule(n, e)
			},
			t.now = Date.now ? Date.now : function() {
				return +new Date
			},
			t
	}();
	e.Scheduler = n
}, function(t, e, n) {
	"use strict";

	function i(t, n) {
		return void 0 === n && (n = e.defaultThrottleConfig),
			this.lift(new s(t, n.leading, n.trailing))
	}
	var r = this && this.__extends || function(t, e) {
			function n() {
				this.constructor = t
			}
			for(var i in e)
				e.hasOwnProperty(i) && (t[i] = e[i]);
			t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
				new n)
		},
		o = n(101),
		a = n(102);
	e.defaultThrottleConfig = {
			leading: !0,
			trailing: !1
		},
		e.throttle = i;
	var s = function() {
			function t(t, e, n) {
				this.durationSelector = t,
					this.leading = e,
					this.trailing = n
			}
			return t.prototype.call = function(t, e) {
					return e.subscribe(new l(t, this.durationSelector, this.leading, this.trailing))
				},
				t
		}(),
		l = function(t) {
			function e(e, n, i, r) {
				t.call(this, e),
					this.destination = e,
					this.durationSelector = n,
					this._leading = i,
					this._trailing = r,
					this._hasTrailingValue = !1
			}
			return r(e, t),
				e.prototype._next = function(t) {
					if(this.throttled)
						this._trailing && (this._hasTrailingValue = !0,
							this._trailingValue = t);
					else {
						var e = this.tryDurationSelector(t);
						e && this.add(this.throttled = a.subscribeToResult(this, e)),
							this._leading && (this.destination.next(t),
								this._trailing && (this._hasTrailingValue = !0,
									this._trailingValue = t))
					}
				},
				e.prototype.tryDurationSelector = function(t) {
					try {
						return this.durationSelector(t)
					} catch(t) {
						return this.destination.error(t),
							null
					}
				},
				e.prototype._unsubscribe = function() {
					var t = this,
						e = t.throttled;
					t._trailingValue,
						t._hasTrailingValue,
						t._trailing;
					this._trailingValue = null,
						this._hasTrailingValue = !1,
						e && (this.remove(e),
							this.throttled = null,
							e.unsubscribe())
				},
				e.prototype._sendTrailing = function() {
					var t = this,
						e = t.destination,
						n = t.throttled,
						i = t._trailing,
						r = t._trailingValue,
						o = t._hasTrailingValue;
					n && i && o && (e.next(r),
						this._trailingValue = null,
						this._hasTrailingValue = !1)
				},
				e.prototype.notifyNext = function(t, e, n, i, r) {
					this._sendTrailing(),
						this._unsubscribe()
				},
				e.prototype.notifyComplete = function() {
					this._sendTrailing(),
						this._unsubscribe()
				},
				e
		}(o.OuterSubscriber)
}, function(t, e, n) {
	"use strict";
	var i = this && this.__extends || function(t, e) {
			function n() {
				this.constructor = t
			}
			for(var i in e)
				e.hasOwnProperty(i) && (t[i] = e[i]);
			t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
				new n)
		},
		r = n(68),
		o = function(t) {
			function e() {
				t.apply(this, arguments)
			}
			return i(e, t),
				e.prototype.notifyNext = function(t, e, n, i, r) {
					this.destination.next(e)
				},
				e.prototype.notifyError = function(t, e) {
					this.destination.error(t)
				},
				e.prototype.notifyComplete = function(t) {
					this.destination.complete()
				},
				e
		}(r.Subscriber);
	e.OuterSubscriber = o
}, function(t, e, n) {
	"use strict";

	function i(t, e, n, i) {
		var d = new u.InnerSubscriber(t, n, i);
		if(d.closed)
			return null;
		if(e instanceof l.Observable)
			return e._isScalar ? (d.next(e.value),
				d.complete(),
				null) : e.subscribe(d);
		if(o.isArrayLike(e)) {
			for(var f = 0, p = e.length; f < p && !d.closed; f++)
				d.next(e[f]);
			d.closed || d.complete()
		} else {
			if(a.isPromise(e))
				return e.then(function(t) {
						d.closed || (d.next(t),
							d.complete())
					}, function(t) {
						return d.error(t)
					}).then(null, function(t) {
						r.root.setTimeout(function() {
							throw t
						})
					}),
					d;
			if(e && "function" == typeof e[c.iterator])
				for(var m = e[c.iterator]();;) {
					var v = m.next();
					if(v.done) {
						d.complete();
						break
					}
					if(d.next(v.value),
						d.closed)
						break
				}
			else if(e && "function" == typeof e[h.observable]) {
				var g = e[h.observable]();
				if("function" == typeof g.subscribe)
					return g.subscribe(new u.InnerSubscriber(t, n, i));
				d.error(new TypeError("Provided object does not correctly implement Symbol.observable"))
			} else {
				var _ = s.isObject(e) ? "an invalid object" : "'" + e + "'",
					y = "You provided " + _ + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
				d.error(new TypeError(y))
			}
		}
		return null
	}
	var r = n(66),
		o = n(103),
		a = n(104),
		s = n(72),
		l = n(65),
		c = n(105),
		u = n(106),
		h = n(78);
	e.subscribeToResult = i
}, function(t, e) {
	"use strict";
	e.isArrayLike = function(t) {
		return t && "number" == typeof t.length
	}
}, function(t, e) {
	"use strict";

	function n(t) {
		return t && "function" != typeof t.subscribe && "function" == typeof t.then
	}
	e.isPromise = n
}, function(t, e, n) {
	"use strict";

	function i(t) {
		var e = t.Symbol;
		if("function" == typeof e)
			return e.iterator || (e.iterator = e("iterator polyfill")),
				e.iterator;
		var n = t.Set;
		if(n && "function" == typeof(new n)["@@iterator"])
			return "@@iterator";
		var i = t.Map;
		if(i)
			for(var r = Object.getOwnPropertyNames(i.prototype), o = 0; o < r.length; ++o) {
				var a = r[o];
				if("entries" !== a && "size" !== a && i.prototype[a] === i.prototype.entries)
					return a
			}
		return "@@iterator"
	}
	var r = n(66);
	e.symbolIteratorPonyfill = i,
		e.iterator = i(r.root),
		e.$$iterator = e.iterator
}, function(t, e, n) {
	"use strict";
	var i = this && this.__extends || function(t, e) {
			function n() {
				this.constructor = t
			}
			for(var i in e)
				e.hasOwnProperty(i) && (t[i] = e[i]);
			t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
				new n)
		},
		r = n(68),
		o = function(t) {
			function e(e, n, i) {
				t.call(this),
					this.parent = e,
					this.outerValue = n,
					this.outerIndex = i,
					this.index = 0
			}
			return i(e, t),
				e.prototype._next = function(t) {
					this.parent.notifyNext(this.outerValue, t, this.outerIndex, this.index++, this)
				},
				e.prototype._error = function(t) {
					this.parent.notifyError(t, this),
						this.unsubscribe()
				},
				e.prototype._complete = function() {
					this.parent.notifyComplete(this),
						this.unsubscribe()
				},
				e
		}(r.Subscriber);
	e.InnerSubscriber = o
}, function(t, e, n) {
	"use strict";
	var i = n(65),
		r = n(108);
	i.Observable.prototype.withLatestFrom = r.withLatestFrom
}, function(t, e, n) {
	"use strict";

	function i() {
		for(var t = [], e = 0; e < arguments.length; e++)
			t[e - 0] = arguments[e];
		var n;
		"function" == typeof t[t.length - 1] && (n = t.pop());
		var i = t;
		return this.lift(new s(i, n))
	}
	var r = this && this.__extends || function(t, e) {
			function n() {
				this.constructor = t
			}
			for(var i in e)
				e.hasOwnProperty(i) && (t[i] = e[i]);
			t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
				new n)
		},
		o = n(101),
		a = n(102);
	e.withLatestFrom = i;
	var s = function() {
			function t(t, e) {
				this.observables = t,
					this.project = e
			}
			return t.prototype.call = function(t, e) {
					return e.subscribe(new l(t, this.observables, this.project))
				},
				t
		}(),
		l = function(t) {
			function e(e, n, i) {
				t.call(this, e),
					this.observables = n,
					this.project = i,
					this.toRespond = [];
				var r = n.length;
				this.values = new Array(r);
				for(var o = 0; o < r; o++)
					this.toRespond.push(o);
				for(var o = 0; o < r; o++) {
					var s = n[o];
					this.add(a.subscribeToResult(this, s, s, o))
				}
			}
			return r(e, t),
				e.prototype.notifyNext = function(t, e, n, i, r) {
					this.values[n] = e;
					var o = this.toRespond;
					if(o.length > 0) {
						var a = o.indexOf(n);
						a !== -1 && o.splice(a, 1)
					}
				},
				e.prototype.notifyComplete = function() {},
				e.prototype._next = function(t) {
					if(0 === this.toRespond.length) {
						var e = [t].concat(this.values);
						this.project ? this._tryProject(e) : this.destination.next(e)
					}
				},
				e.prototype._tryProject = function(t) {
					var e;
					try {
						e = this.project.apply(this, t)
					} catch(t) {
						return void this.destination.error(t)
					}
					this.destination.next(e)
				},
				e
		}(o.OuterSubscriber)
}, function(t, e) {
	"use strict";

	function n(t) {
		var e = "";
		return Object.keys(t).forEach(function(n) {
				e += n + "=" + t[n] + "&"
			}),
			e = e.slice(0, e.length - 1)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var i = function(t, e) {
		var i = {
				enterPortal: {
					point: "/144321.00001.144321",
					encode: "H47641322",
					type: "EXP"
				}
			},
			r = i[t],
			o = "",
			a = window.goldlog;
		try {
			e && (o = n(e)),
				r && a.record(r.point, r.type, o, r.encode)
		} catch(t) {}
	};
	e.default = i
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r() {
		f.style.visibility = "visible",
			f.style.opacity = 1,
			p.addEventListener("click", a, !1),
			m.addEventListener("click", s, !1),
			v.addEventListener("click", l, !1)
	}

	function o() {
		f.style.opacity = 0,
			setTimeout(function() {
				return f.style.visibility = "hidden"
			}, 300),
			p.removeEventListener("click", a, !1),
			m.removeEventListener("click", s, !1),
			v.removeEventListener("click", l, !1)
	}

	function a() {
		u.default.trigger(g)
	}

	function s() {
		u.default.trigger(_)
	}

	function l() {
		u.default.trigger(y)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var c = n(30),
		u = i(c),
		h = n(10),
		d = i(h),
		f = document.querySelector("#buttons"),
		p = f.querySelector(".button-ticket"),
		m = f.querySelector(".button-share"),
		v = f.querySelector(".button-replay"),
		g = d.default.TICKET_CLICK,
		_ = d.default.SHARE_CLICK,
		y = d.default.REPLAY_CLICK;
	e.default = {
		show: r,
		hide: o
	}
}, function(t, e) {
	"use strict";

	function n() {
		r.style.visibility = "visible",
			r.style.opacity = 1,
			o.addEventListener("tap", i, !1)
	}

	function i() {
		r.style.opacity = 0,
			setTimeout(function() {
				return r.style.visibility = "hidden"
			}, 300)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var r = document.querySelector("#tickets"),
		o = r.querySelector(".close-tickets");
	e.default = {
		show: n,
		hide: i
	}
}, function(t, e) {
	"use strict";

	function n() {
		r.style.visibility = "visible",
			r.style.opacity = 1
	}

	function i() {
		r.style.opacity = 0,
			setTimeout(function() {
				return r.style.visibility = "hidden"
			}, 300)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var r = document.querySelector("#share-tips");
	e.default = {
		show: n,
		hide: i
	}
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r() {
		u.style.visibility = "visible",
			u.style.opacity = 1,
			setTimeout(function() {
				o(c.default.exploreCount)
			}, 200)
	}

	function o(t) {
		for(var e = 0; e < t; e++)
			d[e].classList.add("lighted");
		h.style.webkitTransform = "translateX(" + p[t].pos + "%)",
			f.style.backgroundImage = "url(" + p[t].tipPic + ")"
	}

	function a() {
		u.style.opacity = 0,
			setTimeout(function() {
				return u.style.visibility = "hidden"
			}, 300)
	}

	function s() {
		r(),
			setTimeout(function() {
				a()
			}, 2e3)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var l = n(11),
		c = i(l),
		u = document.querySelector("#progress"),
		h = u.querySelector(".progress-bar-fullfilled"),
		d = u.querySelectorAll(".progress-bar-light"),
		f = u.querySelector(".progress-tips"),
		p = [{
			pos: -100,
			tipPic: "./img/TB1EUJyRVXXXXcKXFXXXXXXXXXX-343-73.png"
		}, {
			pos: -72,
			tipPic: "./img/TB1yVc6RFXXXXaSaXXXXXXXXXXX-343-73.png"
		}, {
			pos: -48,
			tipPic: "./img/TB1rh4PRVXXXXb9XXXXXXXXXXXX-343-73.png"
		}, {
			pos: -24,
			tipPic: "./img/TB1kHdZRVXXXXXjXXXXXXXXXXXX-343-73.png"
		}, {
			pos: 0,
			tipPic: "./img/TB1yPpqRVXXXXX_XVXXXXXXXXXX-343-73.png"
		}];
	e.default = {
		show: r,
		hide: a,
		showAndHide: s
	}
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r() {
		d.style.visibility = "visible",
			d.style.opacity = 1
	}

	function o() {
		d.style.opacity = 0,
			setTimeout(function() {
				return d.style.visibility = "hidden"
			}, 300)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var a = n(11),
		s = (i(a),
			n(30)),
		l = i(s),
		c = n(10),
		u = i(c),
		h = u.default.TRY_OVERLOOK,
		d = document.querySelector("#lookAround");
	d.addEventListener("tap", function() {
			d.classList.toggle("stoped"),
				l.default.trigger(h)
		}),
		e.default = {
			show: r,
			hide: o
		}
}, function(t, e) {
	"use strict";

	function n() {
		r.style.visibility = "visible"
	}

	function i() {
		r.style.visibility = "hidden"
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var r = document.querySelector("#control-board");
	e.default = {
		show: n,
		hide: i
	}
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}

	function r() {
		var t = f.default.isIOS && !f.default.ip6;
		t ? b.src = p : b.src = m,
			x.src = v
	}

	function o() {
		a(),
			l(),
			setTimeout(c, g),
			setTimeout(s, g + _)
	}

	function a() {
		y.style.visibility = "visible",
			y.style.opacity = 1
	}

	function s() {
		y.style.opacity = 0,
			setTimeout(function() {
				return y.style.visibility = "hidden"
			}, 300)
	}

	function l() {
		b.style.visibility = "visible",
			b.style.opacity = 1,
			setTimeout(u, g)
	}

	function c() {
		x.style.visibility = "visible",
			x.style.opacity = 1,
			setTimeout(h, _)
	}

	function u() {
		b.style.opacity = 0,
			setTimeout(function() {
				return b.style.visibility = "hidden"
			}, 300)
	}

	function h() {
		x.style.opacity = 0,
			setTimeout(function() {
				return x.style.visibility = "hidden"
			}, 300)
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var d = n(11),
		f = i(d),
		p = "./img/TB1hMdiSXXXXXc8XpXXXXXXXXXX-458-274.png",
		m = "./img/TB1miBmSXXXXXcEXpXXXXXXXXXX-458-274.png",
		v = "./img/TB15xweRVXXXXXqaXXXXXXXXXXX-101-346.png",
		g = 2e3,
		_ = 2e3,
		y = document.querySelector("#userTips"),
		b = document.querySelector(".play-tips"),
		x = document.querySelector(".stop-tips");
	e.default = {
		init: r,
		showTips: o
	}
}, function(t, e, n) {
	"use strict";

	function i(t) {
		return t && t.__esModule ? t : {
			default: t
		}
	}
	var r = n(11),
		o = i(r),
		a = n(56),
		s = document.querySelector("#back"),
		l = document.querySelector("#music");
	s.addEventListener("tap", function() {
			(0,
				a.nativeBack)()
		}),
		l.addEventListener("tap", function() {
			o.default.isAudioPlay = !o.default.isAudioPlay,
				l.classList.toggle("paused")
		})
}, function(t, e, n) {
	"use strict";

	function i(t) {
		if(t && t.__esModule)
			return t;
		var e = {};
		if(null != t)
			for(var n in t)
				Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
		return e.default = t,
			e
	}

	function r(t, e) {
		if(!(t instanceof e))
			throw new TypeError("Cannot call a class as a function")
	}
	Object.defineProperty(e, "__esModule", {
		value: !0
	});
	var o = function() {
			function t(t, e) {
				for(var n = 0; n < e.length; n++) {
					var i = e[n];
					i.enumerable = i.enumerable || !1,
						i.configurable = !0,
						"value" in i && (i.writable = !0),
						Object.defineProperty(t, i.key, i)
				}
			}
			return function(e, n, i) {
				return n && t(e.prototype, n),
					i && t(e, i),
					e
			}
		}(),
		a = n(13),
		s = i(a),
		l = function() {
			function t() {
				r(this, t),
					this.isInit_ = !1,
					this.isActive_ = !1,
					this.initCallbacks_ = [],
					this.bindAppEvent()
			}
			return o(t, [{
					key: "start",
					value: function(t) {
						return this.startFn_ = t,
							this
					}
				}, {
					key: "stop",
					value: function(t) {
						return this.stopFn_ = t,
							this
					}
				}, {
					key: "register",
					value: function(t) {
						return this.initCallbacks_.push(t),
							this
					}
				}, {
					key: "init",
					value: function() {
						this.initCallbacks_.forEach(function(t) {
							t.isInit_ || (t(),
								t.isInit_ = !0)
						})
					}
				}, {
					key: "active",
					value: function() {
						var t = this;
						s.call("WVApplication", "appState", {}, function(e) {
							"active" === e.state && (t.init(),
								t.startFn_ && t.startFn_(),
								t.isActive_ = !0)
						}, function(e) {
							t.sleep()
						})
					}
				}, {
					key: "sleep",
					value: function() {
						this.isActive_ = !1,
							this.stopFn_ && this.stopFn_()
					}
				}, {
					key: "isActive",
					value: function() {
						return this.isActive_
					}
				}, {
					key: "bindAppEvent",
					value: function() {
						var t = this;
						document.addEventListener("WV.Event.APP.Active", function() {
								t.active()
							}, !1),
							document.addEventListener("WV.Event.APP.Background", function() {
								t.sleep()
							}, !1),
							document.addEventListener("WV.Event.APP.Lock", function() {
								t.sleep()
							}, !1)
					}
				}]),
				t
		}();
	e.default = l
}, function(t, e) {
	var n = function() {
		var t = Date.now(),
			e = t,
			n = 0,
			i = 1 / 0,
			r = 0,
			o = 0,
			a = 1 / 0,
			s = 0,
			l = 0,
			c = 0,
			u = document.createElement("div");
		u.id = "stats",
			u.addEventListener("mousedown", function(t) {
				t.preventDefault(),
					_(++c % 2)
			}, !1),
			u.style.cssText = "width:80px;opacity:0.9;cursor:pointer";
		var h = document.createElement("div");
		h.id = "fps",
			h.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#002",
			u.appendChild(h);
		var d = document.createElement("div");
		d.id = "fpsText",
			d.style.cssText = "color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px",
			d.innerHTML = "FPS",
			h.appendChild(d);
		var f = document.createElement("div");
		for(f.id = "fpsGraph",
			f.style.cssText = "position:relative;width:74px;height:30px;background-color:#0ff",
			h.appendChild(f); 74 > f.children.length;) {
			var p = document.createElement("span");
			p.style.cssText = "width:1px;height:30px;float:left;background-color:#113",
				f.appendChild(p)
		}
		var m = document.createElement("div");
		m.id = "ms",
			m.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#020;display:none",
			u.appendChild(m);
		var v = document.createElement("div");
		v.id = "msText",
			v.style.cssText = "color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px",
			v.innerHTML = "MS",
			m.appendChild(v);
		var g = document.createElement("div");
		for(g.id = "msGraph",
			g.style.cssText = "position:relative;width:74px;height:30px;background-color:#0f0",
			m.appendChild(g); 74 > g.children.length;)
			p = document.createElement("span"),
			p.style.cssText = "width:1px;height:30px;float:left;background-color:#131",
			g.appendChild(p);
		var _ = function(t) {
			switch(c = t) {
				case 0:
					h.style.display = "block",
						m.style.display = "none";
					break;
				case 1:
					h.style.display = "none",
						m.style.display = "block"
			}
		};
		return {
			REVISION: 12,
			domElement: u,
			setMode: _,
			begin: function() {
				t = Date.now()
			},
			end: function() {
				var c = Date.now();
				n = c - t,
					i = Math.min(i, n),
					r = Math.max(r, n),
					v.textContent = n + " MS (" + i + "-" + r + ")";
				var u = Math.min(30, 30 - 30 * (n / 200));
				return g.appendChild(g.firstChild).style.height = u + "px",
					l++,
					c > e + 1e3 && (o = Math.round(1e3 * l / (c - e)),
						a = Math.min(a, o),
						s = Math.max(s, o),
						d.textContent = o + " FPS (" + a + "-" + s + ")",
						u = Math.min(30, 30 - 30 * (o / 100)),
						f.appendChild(f.firstChild).style.height = u + "px",
						e = c,
						l = 0),
					c
			},
			update: function() {
				t = this.end()
			}
		}
	};
	"object" == typeof t && (t.exports = n)
}]);
//# sourceMappingURL=weixin.bundle.js.map